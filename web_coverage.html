
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>web: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">

				<option value="file0">run-script-service/web/event_bridge.go (100.0%)</option>

				<option value="file1">run-script-service/web/frontend_setup.go (82.6%)</option>

				<option value="file2">run-script-service/web/handlers_files.go (78.3%)</option>

				<option value="file3">run-script-service/web/handlers_script_files.go (68.0%)</option>

				<option value="file4">run-script-service/web/server.go (61.5%)</option>

				<option value="file5">run-script-service/web/vue_build_manager.go (31.8%)</option>

				<option value="file6">run-script-service/web/websocket.go (19.7%)</option>

				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>

				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>

			</div>
		</div>
		<div id="content">

		<pre class="file" id="file0" style="display: none">package web

import (
        "run-script-service/service"
)

// EventBridge connects service events to WebSocket broadcasting
type EventBridge struct {
        wsHub            *WebSocketHub
        eventBroadcaster *service.EventBroadcaster
        events           chan *service.ScriptStatusEvent
        unsubscribe      func()
}

// NewEventBridge creates a bridge between service events and WebSocket hub
func NewEventBridge(wsHub *WebSocketHub, eventBroadcaster *service.EventBroadcaster) *EventBridge <span class="cov8" title="1">{
        events := make(chan *service.ScriptStatusEvent, 100)
        unsubscribe := eventBroadcaster.Subscribe(events)

        bridge := &amp;EventBridge{
                wsHub:            wsHub,
                eventBroadcaster: eventBroadcaster,
                events:           events,
                unsubscribe:      unsubscribe,
        }

        // Start processing events
        go bridge.processEvents()

        return bridge
}</span>

// processEvents processes script status events and broadcasts them via WebSocket
func (eb *EventBridge) processEvents() <span class="cov8" title="1">{
        for event := range eb.events </span><span class="cov8" title="1">{
                // Convert service event to WebSocket message format
                data := map[string]interface{}{
                        "script_name": event.ScriptName,
                        "status":      event.Status,
                        "exit_code":   event.ExitCode,
                        "duration":    event.Duration,
                        "timestamp":   event.Timestamp.Format("2006-01-02T15:04:05Z07:00"),
                }

                // Broadcast via WebSocket
                if err := eb.wsHub.BroadcastMessage("script_status", data); err != nil </span>{<span class="cov0" title="0">
                        // Log error but continue processing
                        // In a production system, you might want proper logging here
                }</span>
        }
}

// Close stops the event bridge
func (eb *EventBridge) Close() <span class="cov8" title="1">{
        if eb.unsubscribe != nil </span><span class="cov8" title="1">{
                eb.unsubscribe()
        }</span>
        <span class="cov8" title="1">close(eb.events)</span>
}
</pre>

		<pre class="file" id="file1" style="display: none">package web

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
)

// VuePackageJSON represents the structure of package.json for Vue.js project
type VuePackageJSON struct {
        Name            string            `json:"name"`
        Version         string            `json:"version"`
        Private         bool              `json:"private"`
        Scripts         map[string]string `json:"scripts"`
        Dependencies    map[string]string `json:"dependencies"`
        DevDependencies map[string]string `json:"devDependencies"`
}

// VueFrontendStructure defines the Vue.js frontend project structure
type VueFrontendStructure struct {
        BaseDir string
}

// NewVueFrontendStructure creates a new Vue frontend structure helper
func NewVueFrontendStructure(baseDir string) *VueFrontendStructure <span class="cov8" title="1">{
        return &amp;VueFrontendStructure{
                BaseDir: baseDir,
        }
}</span>

// setupVueFrontendStructure creates the Vue.js frontend directory structure
func setupVueFrontendStructure(frontendDir string) error <span class="cov8" title="1">{
        structure := NewVueFrontendStructure(frontendDir)
        return structure.Create()
}</span>

// Create builds the complete Vue.js frontend structure
func (vfs *VueFrontendStructure) Create() error <span class="cov8" title="1">{
        // Create directory structure
        if err := vfs.createDirectories(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create configuration files
        <span class="cov8" title="1">if err := vfs.createConfigurationFiles(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create source files
        <span class="cov8" title="1">if err := vfs.createSourceFiles(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// createDirectories creates the Vue.js directory structure
func (vfs *VueFrontendStructure) createDirectories() error <span class="cov8" title="1">{
        // Create main frontend directory
        if err := os.MkdirAll(vfs.BaseDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create frontend directory: %w", err)
        }</span>

        // Define Vue.js standard directory structure
        <span class="cov8" title="1">dirs := []string{
                "src",
                "src/components",
                "src/views",
                "src/composables",
                "src/services",
        }

        for _, dir := range dirs </span><span class="cov8" title="1">{
                dirPath := filepath.Join(vfs.BaseDir, dir)
                if err := os.MkdirAll(dirPath, 0755); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create directory %s: %w", dirPath, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// createConfigurationFiles creates configuration files for Vue.js project
func (vfs *VueFrontendStructure) createConfigurationFiles() error <span class="cov8" title="1">{
        configFiles := []func() error{
                vfs.createPackageJSON,
                vfs.createViteConfig,
                vfs.createIndexHTML,
        }

        for _, createFile := range configFiles </span><span class="cov8" title="1">{
                if err := createFile(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// createSourceFiles creates source code files for Vue.js project
func (vfs *VueFrontendStructure) createSourceFiles() error <span class="cov8" title="1">{
        sourceFiles := []func() error{
                vfs.createMainJS,
                vfs.createAppVue,
        }

        for _, createFile := range sourceFiles </span><span class="cov8" title="1">{
                if err := createFile(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// createPackageJSON creates the package.json file with Vue.js dependencies
func (vfs *VueFrontendStructure) createPackageJSON() error <span class="cov8" title="1">{
        packageJSON := VuePackageJSON{
                Name:    "run-script-service-frontend",
                Version: "1.0.0",
                Private: true,
                Scripts: map[string]string{
                        "serve": "vite",
                        "build": "vite build",
                        "dev":   "vite",
                },
                Dependencies: map[string]string{
                        "vue":          "^3.4.0",
                        "vue-router":   "^4.2.0",
                        "@vueuse/core": "^10.7.0",
                },
                DevDependencies: map[string]string{
                        "vite":               "^5.0.0",
                        "@vitejs/plugin-vue": "^4.5.0",
                        "sass":               "^1.69.0",
                },
        }

        data, err := json.MarshalIndent(packageJSON, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal package.json: %w", err)
        }</span>

        <span class="cov8" title="1">packagePath := filepath.Join(vfs.BaseDir, "package.json")
        return os.WriteFile(packagePath, data, 0644)</span>
}

// createViteConfig creates the vite.config.js file
func (vfs *VueFrontendStructure) createViteConfig() error <span class="cov8" title="1">{
        viteConfig := `import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

export default defineConfig({
  plugins: [vue()],
  base: '/static/',
  build: {
    outDir: '../static',
    assetsInlineLimit: 8192,
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['vue', 'vue-router']
        }
      }
    }
  }
})
`
        viteConfigPath := filepath.Join(vfs.BaseDir, "vite.config.js")
        return os.WriteFile(viteConfigPath, []byte(viteConfig), 0644)
}</span>

// createIndexHTML creates the index.html file
func (vfs *VueFrontendStructure) createIndexHTML() error <span class="cov8" title="1">{
        indexHTML := `&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
  &lt;title&gt;Run Script Service&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id="app"&gt;&lt;/div&gt;
  &lt;script type="module" src="/src/main.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
`
        indexPath := filepath.Join(vfs.BaseDir, "index.html")
        return os.WriteFile(indexPath, []byte(indexHTML), 0644)
}</span>

// createMainJS creates the main.js file
func (vfs *VueFrontendStructure) createMainJS() error <span class="cov8" title="1">{
        mainJS := `import { createApp } from 'vue'
import App from './App.vue'

createApp(App).mount('#app')
`
        mainJSPath := filepath.Join(vfs.BaseDir, "src", "main.js")
        return os.WriteFile(mainJSPath, []byte(mainJS), 0644)
}</span>

// createAppVue creates the App.vue file
func (vfs *VueFrontendStructure) createAppVue() error <span class="cov8" title="1">{
        appVue := `&lt;template&gt;
  &lt;div id="app"&gt;
    &lt;h1&gt;Run Script Service&lt;/h1&gt;
    &lt;p&gt;Vue.js frontend is loading...&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: 'App'
}
&lt;/script&gt;

&lt;style&gt;
#app {
  font-family: Avenir, Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
  color: #2c3e50;
  margin-top: 60px;
}
&lt;/style&gt;
`
        appVuePath := filepath.Join(vfs.BaseDir, "src", "App.vue")
        return os.WriteFile(appVuePath, []byte(appVue), 0644)
}</span>
</pre>

		<pre class="file" id="file2" style="display: none">// Package web provides file operation handlers for the HTTP API server
package web

import (
        "fmt"
        "net/http"
        "strings"

        "github.com/gin-gonic/gin"

        "run-script-service/service"
)

// FileOperationRequest represents a file operation request
type FileOperationRequest struct {
        Path    string `json:"path,omitempty"`
        Content string `json:"content,omitempty"`
}

// ValidationRequest represents a script validation request
type ValidationRequest struct {
        Content string `json:"content" binding:"required"`
}

// ValidationResponse represents validation results
type ValidationResponse struct {
        Valid  bool     `json:"valid"`
        Issues []string `json:"issues,omitempty"`
}

// SetFileManager sets the file manager for the web server
func (ws *WebServer) SetFileManager(fm *service.FileManager) <span class="cov8" title="1">{
        ws.fileManager = fm
        ws.setupFileRoutes()
}</span>

// setupFileRoutes configures file operation API routes with authentication
func (ws *WebServer) setupFileRoutes() <span class="cov8" title="1">{
        if ws.fileManager == nil || ws.authMiddleware == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Create protected file routes group
        <span class="cov8" title="1">api := ws.router.Group("/api")
        protected := api.Group("/")
        protected.Use(ws.authMiddleware.RequireAuth())

        // File operation endpoints (protected)
        protected.GET("/files/*path", ws.handleGetFile)
        protected.PUT("/files/*path", ws.handlePutFile)
        protected.POST("/files/validate", ws.handleValidateFile)
        protected.GET("/files-list/*path", ws.handleListFiles)</span>
}

// handleGetFile reads and returns a file's content
func (ws *WebServer) handleGetFile(c *gin.Context) <span class="cov8" title="1">{
        if ws.fileManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "File manager not initialized",
                })
                return
        }</span>

        // Extract path from URL parameter
        <span class="cov8" title="1">filePath := c.Param("path")
        if filePath == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   "File path is required",
                })
                return
        }</span>

        // Remove leading slash from path parameter
        <span class="cov8" title="1">if filePath[0] == '/' </span><span class="cov8" title="1">{
                filePath = filePath[1:]
        }</span>

        <span class="cov8" title="1">fileContent, err := ws.fileManager.ReadFile(filePath)
        if err != nil </span><span class="cov8" title="1">{
                statusCode := http.StatusInternalServerError
                if err.Error() == "access denied: path not allowed" </span><span class="cov8" title="1">{
                        statusCode = http.StatusForbidden
                }</span> else<span class="cov8" title="1"> if strings.Contains(err.Error(), "no such file or directory") </span><span class="cov8" title="1">{
                        statusCode = http.StatusNotFound
                }</span>

                <span class="cov8" title="1">c.JSON(statusCode, APIResponse{
                        Success: false,
                        Error:   err.Error(),
                })
                return</span>
        }

        <span class="cov8" title="1">c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data:    fileContent,
        })</span>
}

// handlePutFile writes content to a file
func (ws *WebServer) handlePutFile(c *gin.Context) <span class="cov8" title="1">{
        if ws.fileManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "File manager not initialized",
                })
                return
        }</span>

        // Extract path from URL parameter
        <span class="cov8" title="1">filePath := c.Param("path")
        if filePath == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   "File path is required",
                })
                return
        }</span>

        // Remove leading slash from path parameter
        <span class="cov8" title="1">if filePath[0] == '/' </span><span class="cov8" title="1">{
                filePath = filePath[1:]
        }</span>

        <span class="cov8" title="1">var request FileOperationRequest
        if err := c.ShouldBindJSON(&amp;request); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   fmt.Sprintf("Invalid request body: %v", err),
                })
                return
        }</span>

        // Use content from request body
        <span class="cov8" title="1">content := request.Content

        err := ws.fileManager.WriteFile(filePath, content)
        if err != nil </span><span class="cov8" title="1">{
                statusCode := http.StatusInternalServerError
                if err.Error() == "access denied: path not allowed" </span><span class="cov8" title="1">{
                        statusCode = http.StatusForbidden
                }</span>

                <span class="cov8" title="1">c.JSON(statusCode, APIResponse{
                        Success: false,
                        Error:   err.Error(),
                })
                return</span>
        }

        <span class="cov8" title="1">c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data: map[string]interface{}{
                        "message": fmt.Sprintf("File '%s' written successfully", filePath),
                        "path":    filePath,
                },
        })</span>
}

// handleValidateFile validates script syntax
func (ws *WebServer) handleValidateFile(c *gin.Context) <span class="cov8" title="1">{
        if ws.fileManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "File manager not initialized",
                })
                return
        }</span>

        <span class="cov8" title="1">var request ValidationRequest
        if err := c.ShouldBindJSON(&amp;request); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   fmt.Sprintf("Invalid request body: %v", err),
                })
                return
        }</span>

        <span class="cov8" title="1">issues := ws.fileManager.ValidateScriptSyntax(request.Content)

        response := ValidationResponse{
                Valid:  len(issues) == 0,
                Issues: issues,
        }

        c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data:    response,
        })</span>
}

// handleListFiles lists files in a directory
func (ws *WebServer) handleListFiles(c *gin.Context) <span class="cov8" title="1">{
        if ws.fileManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "File manager not initialized",
                })
                return
        }</span>

        // Extract path from URL parameter
        <span class="cov8" title="1">dirPath := c.Param("path")
        if dirPath == "" </span><span class="cov0" title="0">{
                dirPath = "." // Default to current directory
        }</span>

        // Remove leading slash from path parameter
        <span class="cov8" title="1">if dirPath[0] == '/' </span><span class="cov8" title="1">{
                dirPath = dirPath[1:]
        }</span>

        <span class="cov8" title="1">files, err := ws.fileManager.ListFiles(dirPath)
        if err != nil </span><span class="cov8" title="1">{
                statusCode := http.StatusInternalServerError
                if err.Error() == "access denied: path not allowed" </span><span class="cov8" title="1">{
                        statusCode = http.StatusForbidden
                }</span> else<span class="cov0" title="0"> if strings.Contains(err.Error(), "no such file or directory") </span><span class="cov0" title="0">{
                        statusCode = http.StatusNotFound
                }</span>

                <span class="cov8" title="1">c.JSON(statusCode, APIResponse{
                        Success: false,
                        Error:   err.Error(),
                })
                return</span>
        }

        // Convert file info to JSON-serializable format
        <span class="cov8" title="1">fileList := make([]map[string]interface{}, len(files))
        for i, file := range files </span><span class="cov8" title="1">{
                fileList[i] = map[string]interface{}{
                        "name":     file.Name(),
                        "size":     file.Size(),
                        "mode":     file.Mode().String(),
                        "is_dir":   file.IsDir(),
                        "mod_time": file.ModTime().Unix(),
                }
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data:    fileList,
        })</span>
}
</pre>

		<pre class="file" id="file3" style="display: none">// Package web provides script file management handlers for the HTTP API server
package web

import (
        "fmt"
        "net/http"

        "github.com/gin-gonic/gin"

        "run-script-service/service"
)

// CreateScriptFileRequest represents a request to create a new script file
type CreateScriptFileRequest struct {
        Name     string `json:"name" binding:"required"`
        Filename string `json:"filename" binding:"required"`
        Content  string `json:"content" binding:"required"`
        Interval int    `json:"interval" binding:"required"`
        Enabled  bool   `json:"enabled"`
        Timeout  int    `json:"timeout"`
}

// UpdateScriptFileRequest represents a request to update a script file
type UpdateScriptFileRequest struct {
        Content string `json:"content" binding:"required"`
}

// setupScriptFileRoutes configures script file management API routes with authentication
func (ws *WebServer) setupScriptFileRoutes() <span class="cov8" title="1">{
        if ws.scriptFileManager == nil </span><span class="cov8" title="1">{
                return
        }</span>

        // Create script file routes group
        <span class="cov8" title="1">api := ws.router.Group("/api")

        // If auth middleware is available, use protected routes
        if ws.authMiddleware != nil </span><span class="cov0" title="0">{
                protected := api.Group("/")
                protected.Use(ws.authMiddleware.RequireAuth())

                // Script file management endpoints (protected)
                protected.GET("/script-files", ws.handleGetScriptFiles)
                protected.GET("/script-files/:filename", ws.handleGetScriptFile)
                protected.POST("/script-files", ws.handleCreateScriptFile)
                protected.PUT("/script-files/:filename", ws.handleUpdateScriptFile)
                protected.DELETE("/script-files/:filename", ws.handleDeleteScriptFile)
        }</span> else<span class="cov8" title="1"> {
                // For testing - unprotected routes
                api.GET("/script-files", ws.handleGetScriptFiles)
                api.GET("/script-files/:filename", ws.handleGetScriptFile)
                api.POST("/script-files", ws.handleCreateScriptFile)
                api.PUT("/script-files/:filename", ws.handleUpdateScriptFile)
                api.DELETE("/script-files/:filename", ws.handleDeleteScriptFile)
        }</span>
}

// handleGetScriptFiles lists all script files
func (ws *WebServer) handleGetScriptFiles(c *gin.Context) <span class="cov8" title="1">{
        if ws.scriptFileManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "Script file manager not initialized",
                })
                return
        }</span>

        <span class="cov8" title="1">scripts, err := ws.scriptFileManager.ListScripts()
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   fmt.Sprintf("Failed to list scripts: %v", err),
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data:    scripts,
        })</span>
}

// handleGetScriptFile retrieves a single script file with its content
func (ws *WebServer) handleGetScriptFile(c *gin.Context) <span class="cov8" title="1">{
        filename := c.Param("filename")

        if ws.scriptFileManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "Script file manager not initialized",
                })
                return
        }</span>

        <span class="cov8" title="1">script, err := ws.scriptFileManager.GetScript(filename)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusNotFound, APIResponse{
                        Success: false,
                        Error:   err.Error(),
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data:    script,
        })</span>
}

// handleCreateScriptFile creates a new script file and configuration
func (ws *WebServer) handleCreateScriptFile(c *gin.Context) <span class="cov8" title="1">{
        var request CreateScriptFileRequest

        if err := c.ShouldBindJSON(&amp;request); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   fmt.Sprintf("Invalid request: %v", err),
                })
                return
        }</span>

        <span class="cov8" title="1">if ws.scriptFileManager == nil || ws.scriptManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "Script managers not initialized",
                })
                return
        }</span>

        // Create the script file
        <span class="cov8" title="1">if err := ws.scriptFileManager.CreateScript(request.Filename, request.Content); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   err.Error(),
                })
                return
        }</span>

        // Create script configuration
        <span class="cov8" title="1">scriptConfig := service.ScriptConfig{
                Name:        request.Name,
                Filename:    request.Filename,
                Path:        ws.scriptFileManager.GetScriptPath(request.Filename),
                Interval:    request.Interval,
                Enabled:     request.Enabled,
                MaxLogLines: 100, // Default value
                Timeout:     request.Timeout,
        }

        // Add to script manager
        if err := ws.scriptManager.AddScript(scriptConfig); err != nil </span><span class="cov0" title="0">{
                // If adding config failed, cleanup the created file
                ws.scriptFileManager.DeleteScript(request.Filename)

                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   fmt.Sprintf("Failed to add script configuration: %v", err),
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusCreated, APIResponse{
                Success: true,
                Data:    map[string]string{"message": "Script created successfully"},
        })</span>
}

// handleUpdateScriptFile updates the content of an existing script file
func (ws *WebServer) handleUpdateScriptFile(c *gin.Context) <span class="cov8" title="1">{
        filename := c.Param("filename")

        var request UpdateScriptFileRequest
        if err := c.ShouldBindJSON(&amp;request); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   fmt.Sprintf("Invalid request: %v", err),
                })
                return
        }</span>

        <span class="cov8" title="1">if ws.scriptFileManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "Script file manager not initialized",
                })
                return
        }</span>

        <span class="cov8" title="1">if err := ws.scriptFileManager.UpdateScript(filename, request.Content); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   err.Error(),
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data:    map[string]string{"message": "Script updated successfully"},
        })</span>
}

// handleDeleteScriptFile deletes a script file and removes it from configuration
func (ws *WebServer) handleDeleteScriptFile(c *gin.Context) <span class="cov8" title="1">{
        filename := c.Param("filename")

        if ws.scriptFileManager == nil || ws.scriptManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "Script managers not initialized",
                })
                return
        }</span>

        // Find and remove from script manager first (by filename)
        <span class="cov8" title="1">scripts, err := ws.scriptManager.GetScripts()
        if err == nil </span><span class="cov8" title="1">{
                for _, script := range scripts </span><span class="cov8" title="1">{
                        if script.Filename == filename </span><span class="cov8" title="1">{
                                ws.scriptManager.RemoveScript(script.Name)
                                break</span>
                        }
                }
        }

        // Delete the file
        <span class="cov8" title="1">if err := ws.scriptFileManager.DeleteScript(filename); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   err.Error(),
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data:    map[string]string{"message": "Script deleted successfully"},
        })</span>
}
</pre>

		<pre class="file" id="file4" style="display: none">// Package web provides HTTP API server functionality
package web

import (
        "context"
        "embed"
        "fmt"
        "io"
        "io/fs"
        "log"
        "net/http"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "time"

        "github.com/gin-contrib/cors"
        "github.com/gin-gonic/gin"

        "run-script-service/auth"
        "run-script-service/service"
)

//go:embed frontend/dist/*
var frontendFS embed.FS

// WebServer represents the HTTP API server
type WebServer struct {
        router            *gin.Engine
        service           *service.Service
        scriptManager     *service.ScriptManager
        scriptFileManager *service.ScriptFileManager
        fileManager       *service.FileManager
        wsHub             *WebSocketHub
        systemMonitor     *service.SystemMonitor
        authHandler       *auth.AuthHandler
        authMiddleware    *auth.AuthMiddleware
        debugLogger       *service.DebugLogger
        port              int
}

// APIResponse represents the standard API response format
type APIResponse struct {
        Success bool        `json:"success"`
        Data    interface{} `json:"data,omitempty"`
        Error   string      `json:"error,omitempty"`
}

// LogEntry represents a structured log entry for the frontend
type LogEntry struct {
        Timestamp string `json:"timestamp"`
        Message   string `json:"message"`
        Level     string `json:"level"` // "info", "warning", "error"
        Script    string `json:"script,omitempty"`
}

// enhancedRecoveryMiddleware provides enhanced error handling with structured JSON responses
func enhancedRecoveryMiddleware() gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                defer func() </span><span class="cov8" title="1">{
                        if err := recover(); err != nil </span><span class="cov8" title="1">{
                                // Log the panic with request context for debugging
                                log.Printf("Panic recovered: %v - Request: %s %s, User-Agent: %s, X-Request-ID: %s",
                                        err,
                                        c.Request.Method,
                                        c.Request.URL.Path,
                                        c.GetHeader("User-Agent"),
                                        c.GetHeader("X-Request-ID"))

                                // Return structured JSON error response
                                c.JSON(http.StatusInternalServerError, APIResponse{
                                        Success: false,
                                        Error:   "Internal server error",
                                })
                                c.Abort()
                        }</span>
                }()
                <span class="cov8" title="1">c.Next()</span>
        }
}

// NewWebServer creates a new web server instance
func NewWebServer(svc *service.Service, port int, secretKey string) *WebServer <span class="cov8" title="1">{
        // Set Gin to release mode for production
        gin.SetMode(gin.ReleaseMode)

        router := gin.New()

        // Add middleware
        router.Use(gin.Logger())
        router.Use(enhancedRecoveryMiddleware())
        router.Use(cors.Default())

        // Create WebSocket hub
        wsHub := NewWebSocketHub()
        go wsHub.Run()

        // Initialize authentication
        authHandler := auth.NewAuthHandler(secretKey)
        authMiddleware := auth.NewAuthMiddleware(authHandler.GetSessionManager())

        server := &amp;WebServer{
                router:         router,
                service:        svc,
                wsHub:          wsHub,
                authHandler:    authHandler,
                authMiddleware: authMiddleware,
                debugLogger:    service.NewDebugLogger(),
                port:           port,
        }

        // Setup routes
        server.setupRoutes()

        return server
}</span>

// SetScriptManager sets the script manager for the web server
func (ws *WebServer) SetScriptManager(sm *service.ScriptManager) <span class="cov8" title="1">{
        ws.scriptManager = sm
}</span>

// SetScriptFileManager sets the script file manager for the web server
func (ws *WebServer) SetScriptFileManager(sfm *service.ScriptFileManager) <span class="cov8" title="1">{
        ws.scriptFileManager = sfm
}</span>

// GetWebSocketHub returns the WebSocket hub for broadcasting messages
func (ws *WebServer) GetWebSocketHub() *WebSocketHub <span class="cov8" title="1">{
        return ws.wsHub
}</span>

// SetSystemMonitor sets the system monitor for the web server
func (ws *WebServer) SetSystemMonitor(monitor *service.SystemMonitor) <span class="cov8" title="1">{
        ws.systemMonitor = monitor
}</span>

// StartSystemMetricsBroadcasting starts periodic system metrics broadcasting via WebSocket
func (ws *WebServer) StartSystemMetricsBroadcasting(ctx context.Context, interval time.Duration) error <span class="cov8" title="1">{
        if ws.systemMonitor == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("system monitor not configured")
        }</span>

        // Create event publisher that broadcasts via WebSocket
        <span class="cov8" title="1">publisher := func(msgType string, data map[string]interface{}) error </span><span class="cov0" title="0">{
                if ws.wsHub != nil </span><span class="cov0" title="0">{
                        return ws.wsHub.BroadcastMessage(msgType, data)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        // Start periodic broadcasting in a goroutine
        <span class="cov8" title="1">go ws.systemMonitor.StartPeriodicBroadcasting(ctx, interval, publisher)

        return nil</span>
}

// BroadcastConfigUpdate broadcasts configuration update events to all connected WebSocket clients
func (ws *WebServer) BroadcastConfigUpdate(event service.ConfigUpdateEvent) <span class="cov8" title="1">{
        if ws.wsHub == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">data := map[string]interface{}{
                "script_name": event.ScriptName,
                "status":      event.Status,
                "changes":     event.Changes,
                "applied":     event.Applied,
                "scheduled":   event.Scheduled,
                "message":     event.Message,
                "timestamp":   event.Timestamp,
        }

        if err := ws.wsHub.BroadcastMessage("config_update", data); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to broadcast config update: %v", err)
        }</span>
}

// setupRoutes configures all API routes
func (ws *WebServer) setupRoutes() <span class="cov8" title="1">{
        // Create a sub filesystem for the dist directory
        distFS, err := fs.Sub(frontendFS, "frontend/dist")
        if err != nil </span><span class="cov0" title="0">{
                ws.debugLogger.Debugf("embed fs.Sub failed: %v, using fallback", err)
                // Fallback to file system if embed fails (development mode)
                ws.router.Static("/static", "./web/frontend/dist")
                ws.router.GET("/", func(c *gin.Context) </span><span class="cov0" title="0">{
                        c.File("./web/frontend/dist/index.html")
                }</span>)
        } else<span class="cov8" title="1"> {
                ws.debugLogger.Debugf("Using embedded filesystem")
                // Use embedded filesystem for static files (public)
                ws.router.StaticFS("/static", http.FS(distFS))

                // Login route (unprotected)
                ws.router.GET("/login", func(c *gin.Context) </span><span class="cov0" title="0">{
                        indexFile, err := distFS.Open("index.html")
                        if err != nil </span><span class="cov0" title="0">{
                                ws.debugLogger.Debugf("Failed to open embedded index.html: %v", err)
                                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to load frontend"})
                                return
                        }</span>
                        <span class="cov0" title="0">defer indexFile.Close()

                        c.Header("Content-Type", "text/html")
                        http.ServeContent(c.Writer, c.Request, "index.html", time.Now(), indexFile.(io.ReadSeeker))</span>
                })

                // Root route serves index.html from embedded FS (protected)
                <span class="cov8" title="1">ws.router.GET("/", ws.authMiddleware.RequireAuth(), func(c *gin.Context) </span><span class="cov0" title="0">{
                        indexFile, err := distFS.Open("index.html")
                        if err != nil </span><span class="cov0" title="0">{
                                ws.debugLogger.Debugf("Failed to open embedded index.html: %v", err)
                                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to load frontend"})
                                return
                        }</span>
                        <span class="cov0" title="0">defer indexFile.Close()

                        c.Header("Content-Type", "text/html")
                        http.ServeContent(c.Writer, c.Request, "index.html", time.Now(), indexFile.(io.ReadSeeker))</span>
                })

                // Serve index.html for SPA routes (NoRoute handler) - protected
                <span class="cov8" title="1">ws.router.NoRoute(func(c *gin.Context) </span><span class="cov8" title="1">{
                        path := c.Request.URL.Path

                        // If it's an API route, let it 404
                        if strings.HasPrefix(path, "/api/") || strings.HasPrefix(path, "/ws") </span><span class="cov8" title="1">{
                                c.JSON(http.StatusNotFound, gin.H{"error": "Not found"})
                                return
                        }</span>

                        // Check authentication for SPA routes
                        <span class="cov8" title="1">if !ws.authMiddleware.IsAuthenticated(c) </span><span class="cov8" title="1">{
                                c.Redirect(http.StatusFound, "/login")
                                return
                        }</span>

                        // For all other routes, serve index.html (Vue.js SPA)
                        <span class="cov0" title="0">indexFile, err := distFS.Open("index.html")
                        if err != nil </span><span class="cov0" title="0">{
                                ws.debugLogger.Debugf("Failed to open embedded index.html in NoRoute: %v", err)
                                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to load frontend"})
                                return
                        }</span>
                        <span class="cov0" title="0">defer indexFile.Close()

                        c.Header("Content-Type", "text/html")
                        http.ServeContent(c.Writer, c.Request, "index.html", time.Now(), indexFile.(io.ReadSeeker))</span>
                })
        }

        // WebSocket endpoint (protected)
        <span class="cov8" title="1">ws.router.GET("/ws", ws.authMiddleware.RequireAuth(), func(c *gin.Context) </span><span class="cov8" title="1">{
                HandleWebSocket(ws.wsHub, c)
        }</span>)

        <span class="cov8" title="1">api := ws.router.Group("/api")

        // Authentication routes (unprotected)
        auth := api.Group("/auth")
        auth.POST("/login", ws.authHandler.Login)
        auth.POST("/logout", ws.authHandler.Logout)
        auth.GET("/status", ws.authHandler.AuthStatus)

        // Protected routes (require authentication)
        protected := api.Group("/")
        protected.Use(ws.authMiddleware.RequireAuth())

        // System status endpoint
        protected.GET("/status", ws.handleStatus)

        // Script management endpoints
        protected.GET("/scripts", ws.handleGetScripts)
        protected.POST("/scripts", ws.handlePostScript)
        protected.POST("/scripts/template", ws.handlePostScriptTemplate)
        protected.GET("/scripts/:name", ws.handleGetScript)
        protected.PUT("/scripts/:name", ws.handleUpdateScript)
        protected.DELETE("/scripts/:name", ws.handleDeleteScript)
        protected.POST("/scripts/:name/run", ws.handleRunScript)
        protected.POST("/scripts/:name/enable", ws.handleEnableScript)
        protected.POST("/scripts/:name/disable", ws.handleDisableScript)

        // Log management endpoints
        protected.GET("/logs", ws.handleGetLogs)
        protected.GET("/logs/:script", ws.handleGetScriptLogs)
        protected.GET("/logs/raw/:script", ws.handleGetRawLogs) // New simple endpoint
        protected.DELETE("/logs/:script", ws.handleClearScriptLogs)

        // Configuration endpoints
        protected.GET("/config", ws.handleGetConfig)
        protected.PUT("/config", ws.handleUpdateConfig)

        // Git project discovery endpoints
        protected.GET("/git-projects", ws.handleGetGitProjects)

        // Script file management routes (if available)
        ws.setupScriptFileRoutes()</span>
}

// handleStatus returns system status information
func (ws *WebServer) handleStatus(c *gin.Context) <span class="cov8" title="1">{
        uptime := "Unknown"
        runningScripts := 0
        totalScripts := 0

        // Get script counts if script manager is available
        if ws.scriptManager != nil </span><span class="cov8" title="1">{
                config := ws.scriptManager.GetConfig()
                totalScripts = len(config.Scripts)

                // Count running/enabled scripts
                for _, script := range config.Scripts </span><span class="cov8" title="1">{
                        if script.Enabled &amp;&amp; ws.scriptManager.IsScriptRunning(script.Name) </span><span class="cov0" title="0">{
                                runningScripts++
                        }</span>
                }
        }

        // Calculate uptime if system monitor is available
        <span class="cov8" title="1">if ws.systemMonitor != nil </span><span class="cov8" title="1">{
                uptimeStr := ws.systemMonitor.GetUptime()
                if uptimeStr != "" </span><span class="cov8" title="1">{
                        uptime = uptimeStr
                }</span>
        }

        <span class="cov8" title="1">statusData := map[string]interface{}{
                "status":         "running",
                "uptime":         uptime,
                "runningScripts": runningScripts,
                "totalScripts":   totalScripts,
        }

        c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data:    statusData,
        })</span>
}

// handleGetScripts returns all scripts
func (ws *WebServer) handleGetScripts(c *gin.Context) <span class="cov8" title="1">{
        if ws.scriptManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "Script manager not initialized",
                })
                return
        }</span>

        // Get script configs from the manager
        <span class="cov8" title="1">var scripts []map[string]interface{}
        for _, scriptConfig := range ws.scriptManager.GetConfig().Scripts </span><span class="cov8" title="1">{
                running := ws.scriptManager.IsScriptRunning(scriptConfig.Name)

                scripts = append(scripts, map[string]interface{}{
                        "name":          scriptConfig.Name,
                        "path":          scriptConfig.Path,
                        "interval":      scriptConfig.Interval,
                        "enabled":       scriptConfig.Enabled,
                        "max_log_lines": scriptConfig.MaxLogLines,
                        "timeout":       scriptConfig.Timeout,
                        "running":       running,
                })
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data:    scripts,
        })</span>
}

// handlePostScript creates a new script
func (ws *WebServer) handlePostScript(c *gin.Context) <span class="cov8" title="1">{
        if ws.scriptManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "Script manager not initialized",
                })
                return
        }</span>

        <span class="cov8" title="1">var scriptConfig service.ScriptConfig
        if err := c.ShouldBindJSON(&amp;scriptConfig); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   fmt.Sprintf("Invalid request body: %v", err),
                })
                return
        }</span>

        // Validate required fields
        <span class="cov8" title="1">if scriptConfig.Name == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   "Script name is required",
                })
                return
        }</span>

        <span class="cov8" title="1">if scriptConfig.Path == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   "Script path is required",
                })
                return
        }</span>

        // Set defaults for optional fields
        <span class="cov8" title="1">if scriptConfig.Interval &lt;= 0 </span><span class="cov0" title="0">{
                scriptConfig.Interval = 60 // Default to 1 minute
        }</span>
        <span class="cov8" title="1">if scriptConfig.MaxLogLines &lt;= 0 </span><span class="cov0" title="0">{
                scriptConfig.MaxLogLines = 100 // Default to 100 lines
        }</span>

        // Add the script
        <span class="cov8" title="1">if err := ws.scriptManager.AddScript(scriptConfig); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusConflict, APIResponse{
                        Success: false,
                        Error:   err.Error(),
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusCreated, APIResponse{
                Success: true,
                Data: map[string]interface{}{
                        "name":          scriptConfig.Name,
                        "path":          scriptConfig.Path,
                        "interval":      scriptConfig.Interval,
                        "enabled":       scriptConfig.Enabled,
                        "max_log_lines": scriptConfig.MaxLogLines,
                        "timeout":       scriptConfig.Timeout,
                },
        })</span>
}

// handlePostScriptTemplate creates a new script from a template
func (ws *WebServer) handlePostScriptTemplate(c *gin.Context) <span class="cov8" title="1">{
        if ws.scriptManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "Script manager not initialized",
                })
                return
        }</span>

        <span class="cov8" title="1">var template service.ScriptTemplate
        if err := c.ShouldBindJSON(&amp;template); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   fmt.Sprintf("Invalid request body: %v", err),
                })
                return
        }</span>

        // Create script generator
        <span class="cov8" title="1">scriptGenerator := service.NewScriptGenerator()

        // Generate script from template
        generatedScript, err := scriptGenerator.GenerateScript(&amp;template)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   fmt.Sprintf("Script generation failed: %v", err),
                })
                return
        }</span>

        // Convert generated script to ScriptConfig for script manager
        <span class="cov8" title="1">scriptConfig := service.ScriptConfig{
                Name:        generatedScript.Name,
                Path:        generatedScript.Path,
                Interval:    convertIntervalToSeconds(generatedScript.Config.Interval),
                Enabled:     true,
                MaxLogLines: generatedScript.Config.MaxLogLines,
                Timeout:     generatedScript.Config.Timeout,
        }

        // Set defaults for optional fields
        if scriptConfig.Interval &lt;= 0 </span><span class="cov0" title="0">{
                scriptConfig.Interval = 3600 // Default to 1 hour
        }</span>
        <span class="cov8" title="1">if scriptConfig.MaxLogLines &lt;= 0 </span><span class="cov0" title="0">{
                scriptConfig.MaxLogLines = 100
        }</span>

        // Write the generated script to file
        <span class="cov8" title="1">if err := writeScriptToFile(generatedScript.Path, generatedScript.Content); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   fmt.Sprintf("Failed to write script file: %v", err),
                })
                return
        }</span>

        // Add the script to the manager
        <span class="cov8" title="1">if err := ws.scriptManager.AddScript(scriptConfig); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusConflict, APIResponse{
                        Success: false,
                        Error:   err.Error(),
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data: map[string]interface{}{
                        "name":         generatedScript.Name,
                        "path":         generatedScript.Path,
                        "type":         template.Type,
                        "project_path": template.ProjectPath,
                        "config":       generatedScript.Config,
                },
        })</span>
}

// Helper function to convert interval string to seconds
func convertIntervalToSeconds(interval string) int <span class="cov8" title="1">{
        // Simple conversion for common intervals
        switch interval </span>{
        case "5m":<span class="cov0" title="0">
                return 300</span>
        case "30m":<span class="cov8" title="1">
                return 1800</span>
        case "1h":<span class="cov8" title="1">
                return 3600</span>
        case "6h":<span class="cov0" title="0">
                return 21600</span>
        case "24h":<span class="cov0" title="0">
                return 86400</span>
        default:<span class="cov0" title="0">
                return 3600</span> // Default to 1 hour
        }
}

// Helper function to write script content to file
func writeScriptToFile(path, content string) error <span class="cov8" title="1">{
        file, err := os.OpenFile(path, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0755)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        _, err = file.WriteString(content)
        return err</span>
}

// handleRunScript executes a script once
func (ws *WebServer) handleRunScript(c *gin.Context) <span class="cov8" title="1">{
        if ws.scriptManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "Script manager not initialized",
                })
                return
        }</span>

        <span class="cov8" title="1">scriptName := c.Param("name")
        if scriptName == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   "Script name is required",
                })
                return
        }</span>

        // Run the script with a timeout context
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(c.Request.Context(), 30*time.Second)
        defer cancel()

        if err := ws.scriptManager.RunScriptOnce(ctx, scriptName); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusNotFound, APIResponse{
                        Success: false,
                        Error:   err.Error(),
                })
                return
        }</span>

        // Note: Logs are now handled via raw file access in /logs/raw/:script endpoint

        <span class="cov0" title="0">c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data: map[string]interface{}{
                        "message": fmt.Sprintf("Script %s executed successfully", scriptName),
                        "script":  scriptName,
                },
        })</span>
}

// handleGetScript returns information about a specific script
func (ws *WebServer) handleGetScript(c *gin.Context) <span class="cov8" title="1">{
        if ws.scriptManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "Script manager not initialized",
                })
                return
        }</span>

        <span class="cov8" title="1">scriptName := c.Param("name")
        if scriptName == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   "Script name is required",
                })
                return
        }</span>

        // Find the script in configuration
        <span class="cov8" title="1">config := ws.scriptManager.GetConfig()
        for _, scriptConfig := range config.Scripts </span><span class="cov8" title="1">{
                if scriptConfig.Name == scriptName </span><span class="cov8" title="1">{
                        running := ws.scriptManager.IsScriptRunning(scriptConfig.Name)

                        scriptData := map[string]interface{}{
                                "name":          scriptConfig.Name,
                                "path":          scriptConfig.Path,
                                "interval":      scriptConfig.Interval,
                                "enabled":       scriptConfig.Enabled,
                                "max_log_lines": scriptConfig.MaxLogLines,
                                "timeout":       scriptConfig.Timeout,
                                "running":       running,
                        }

                        c.JSON(http.StatusOK, APIResponse{
                                Success: true,
                                Data:    scriptData,
                        })
                        return
                }</span>
        }

        <span class="cov8" title="1">c.JSON(http.StatusNotFound, APIResponse{
                Success: false,
                Error:   fmt.Sprintf("Script '%s' not found", scriptName),
        })</span>
}

// handleUpdateScript updates a script configuration
func (ws *WebServer) handleUpdateScript(c *gin.Context) <span class="cov8" title="1">{
        if ws.scriptManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "Script manager not initialized",
                })
                return
        }</span>

        <span class="cov8" title="1">scriptName := c.Param("name")
        if scriptName == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   "Script name is required",
                })
                return
        }</span>

        <span class="cov8" title="1">var updateData service.ScriptConfig
        if err := c.ShouldBindJSON(&amp;updateData); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   fmt.Sprintf("Invalid request body: %v", err),
                })
                return
        }</span>

        // Set defaults for optional fields
        <span class="cov8" title="1">if updateData.Interval &lt;= 0 </span><span class="cov0" title="0">{
                updateData.Interval = 60 // Default to 1 minute
        }</span>
        <span class="cov8" title="1">if updateData.MaxLogLines &lt;= 0 </span><span class="cov0" title="0">{
                updateData.MaxLogLines = 100 // Default to 100 lines
        }</span>

        // Update the script with detailed feedback
        <span class="cov8" title="1">updateResult := ws.scriptManager.UpdateScriptWithFeedback(scriptName, updateData)

        if !updateResult.Success </span><span class="cov8" title="1">{
                // Broadcast failure event
                ws.BroadcastConfigUpdate(service.ConfigUpdateEvent{
                        Type:       "config_update",
                        ScriptName: scriptName,
                        Status:     "failed",
                        Changes:    []service.ConfigChangeInfo{},
                        Applied:    false,
                        Scheduled:  false,
                        Message:    updateResult.Message,
                        Timestamp:  time.Now().Format(time.RFC3339),
                })

                c.JSON(http.StatusNotFound, APIResponse{
                        Success: false,
                        Error:   updateResult.Message,
                })
                return
        }</span>

        // Broadcast successful update event
        <span class="cov8" title="1">status := "applied"
        if updateResult.Scheduled </span><span class="cov0" title="0">{
                status = "scheduled"
        }</span>

        <span class="cov8" title="1">ws.BroadcastConfigUpdate(service.ConfigUpdateEvent{
                Type:       "config_update",
                ScriptName: scriptName,
                Status:     status,
                Changes:    updateResult.Changes,
                Applied:    updateResult.Applied,
                Scheduled:  updateResult.Scheduled,
                Message:    updateResult.Message,
                Timestamp:  time.Now().Format(time.RFC3339),
        })

        c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data: map[string]interface{}{
                        "message":       updateResult.Message,
                        "script":        scriptName,
                        "applied":       updateResult.Applied,
                        "scheduled":     updateResult.Scheduled,
                        "changes":       updateResult.Changes,
                        "name":          updateData.Name,
                        "path":          updateData.Path,
                        "interval":      updateData.Interval,
                        "enabled":       updateData.Enabled,
                        "max_log_lines": updateData.MaxLogLines,
                        "timeout":       updateData.Timeout,
                },
        })</span>
}

// handleDeleteScript removes a script
func (ws *WebServer) handleDeleteScript(c *gin.Context) <span class="cov8" title="1">{
        if ws.scriptManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "Script manager not initialized",
                })
                return
        }</span>

        <span class="cov8" title="1">scriptName := c.Param("name")
        if scriptName == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   "Script name is required",
                })
                return
        }</span>

        // Remove the script
        <span class="cov8" title="1">if err := ws.scriptManager.RemoveScript(scriptName); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusNotFound, APIResponse{
                        Success: false,
                        Error:   err.Error(),
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data: map[string]interface{}{
                        "message": fmt.Sprintf("Script %s deleted successfully", scriptName),
                        "script":  scriptName,
                },
        })</span>
}

// handleScriptToggle handles both enable and disable script operations
func (ws *WebServer) handleScriptToggle(c *gin.Context, enable bool) <span class="cov8" title="1">{
        if ws.scriptManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "Script manager not initialized",
                })
                return
        }</span>

        <span class="cov8" title="1">scriptName := c.Param("name")
        if scriptName == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   "Script name is required",
                })
                return
        }</span>

        <span class="cov8" title="1">var err error
        var action string
        if enable </span><span class="cov8" title="1">{
                err = ws.scriptManager.EnableScript(scriptName)
                action = "enabled"
        }</span> else<span class="cov8" title="1"> {
                err = ws.scriptManager.DisableScript(scriptName)
                action = "disabled"
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, APIResponse{
                        Success: false,
                        Error:   err.Error(),
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data: map[string]interface{}{
                        "message": fmt.Sprintf("Script %s %s successfully", scriptName, action),
                        "script":  scriptName,
                        "enabled": enable,
                },
        })</span>
}

// handleEnableScript enables a script
func (ws *WebServer) handleEnableScript(c *gin.Context) <span class="cov8" title="1">{
        ws.handleScriptToggle(c, true)
}</span>

// handleDisableScript disables a script
func (ws *WebServer) handleDisableScript(c *gin.Context) <span class="cov8" title="1">{
        ws.handleScriptToggle(c, false)
}</span>

// handleGetLogs returns structured log entries as expected by frontend
func (ws *WebServer) handleGetLogs(c *gin.Context) <span class="cov8" title="1">{
        scriptName := c.Query("script")
        limit := c.DefaultQuery("limit", "50")

        // Parse limit
        maxEntries := 50
        if parsedLimit, err := strconv.Atoi(limit); err == nil &amp;&amp; parsedLimit &gt; 0 </span><span class="cov8" title="1">{
                maxEntries = parsedLimit
        }</span>

        // If no script specified, return aggregated logs from all scripts
        <span class="cov8" title="1">if scriptName == "" </span><span class="cov8" title="1">{
                allLogs := ws.getAggregatedLogs(maxEntries)
                c.JSON(http.StatusOK, APIResponse{
                        Success: true,
                        Data:    allLogs,
                })
                return
        }</span>

        // Get logs for specific script
        <span class="cov0" title="0">scriptLogs := ws.getScriptLogs(scriptName, maxEntries)
        c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data:    scriptLogs,
        })</span>
}

// handleGetScriptLogs returns raw log content for a specific script
func (ws *WebServer) handleGetScriptLogs(c *gin.Context) <span class="cov8" title="1">{
        scriptName := c.Param("script")
        if scriptName == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   "Script name is required",
                })
                return
        }</span>

        // Get log file path
        <span class="cov8" title="1">dir, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                dir, _ = os.Getwd()
        }</span> else<span class="cov8" title="1"> {
                dir = filepath.Dir(dir)
        }</span>

        <span class="cov8" title="1">logFile := filepath.Join(dir, fmt.Sprintf("%s.log", scriptName))

        // Check if log file exists
        if _, err := os.Stat(logFile); os.IsNotExist(err) </span><span class="cov8" title="1">{
                c.JSON(http.StatusOK, APIResponse{
                        Success: true,
                        Data: map[string]interface{}{
                                "content": "",
                                "script":  scriptName,
                                "message": "No log file found",
                        },
                })
                return
        }</span>

        // Read raw log file content
        <span class="cov0" title="0">content, err := os.ReadFile(logFile)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   fmt.Sprintf("Failed to read log file: %v", err),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data: map[string]interface{}{
                        "content": string(content),
                        "script":  scriptName,
                },
        })</span>
}

// handleClearScriptLogs clears logs for a specific script (simplified)
func (ws *WebServer) handleClearScriptLogs(c *gin.Context) <span class="cov8" title="1">{
        scriptName := strings.TrimSpace(c.Param("script"))
        if scriptName == "" </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   "Script name is required",
                })
                return
        }</span>

        // Get log file path
        <span class="cov8" title="1">dir, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                dir, _ = os.Getwd()
        }</span> else<span class="cov8" title="1"> {
                dir = filepath.Dir(dir)
        }</span>

        <span class="cov8" title="1">logFile := filepath.Join(dir, fmt.Sprintf("%s.log", scriptName))

        // Clear the log file by truncating it
        if err := os.Truncate(logFile, 0); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   fmt.Sprintf("Failed to clear log file: %v", err),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data: map[string]interface{}{
                        "message": fmt.Sprintf("Logs cleared for script %s", scriptName),
                        "script":  scriptName,
                },
        })</span>
}

// handleGetRawLogs returns raw log file content (simple approach)
func (ws *WebServer) handleGetRawLogs(c *gin.Context) <span class="cov8" title="1">{
        scriptName := c.Param("script")
        if scriptName == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   "Script name is required",
                })
                return
        }</span>

        // Get log file path
        <span class="cov8" title="1">dir, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                dir, _ = os.Getwd()
        }</span> else<span class="cov8" title="1"> {
                dir = filepath.Dir(dir)
        }</span>

        <span class="cov8" title="1">logFile := filepath.Join(dir, fmt.Sprintf("%s.log", scriptName))

        // Check if log file exists
        if _, err := os.Stat(logFile); os.IsNotExist(err) </span><span class="cov8" title="1">{
                c.JSON(http.StatusOK, APIResponse{
                        Success: true,
                        Data: map[string]interface{}{
                                "script":  scriptName,
                                "content": "",
                                "message": "No log file found",
                        },
                })
                return
        }</span>

        // Read log file content
        <span class="cov0" title="0">content, err := os.ReadFile(logFile)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   fmt.Sprintf("Failed to read log file: %v", err),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data: map[string]interface{}{
                        "script":  scriptName,
                        "content": string(content),
                },
        })</span>
}

// ConfigResponse represents the configuration format expected by the frontend
type ConfigResponse struct {
        WebPort      int    `json:"webPort"`
        Interval     string `json:"interval"`
        LogRetention int    `json:"logRetention"`
        AutoRefresh  bool   `json:"autoRefresh"`
}

// handleGetConfig returns system configuration
func (ws *WebServer) handleGetConfig(c *gin.Context) <span class="cov8" title="1">{
        if ws.scriptManager == nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "Script manager not initialized",
                })
                return
        }</span>

        <span class="cov8" title="1">config := ws.scriptManager.GetConfig()

        // Convert to frontend-expected format
        response := ConfigResponse{
                WebPort:      config.WebPort,
                Interval:     "1h", // default interval as string
                LogRetention: 100,  // default log retention
                AutoRefresh:  true, // default auto-refresh setting
        }

        c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data:    response,
        })</span>
}

// handleUpdateConfig updates system configuration
func (ws *WebServer) handleUpdateConfig(c *gin.Context) <span class="cov8" title="1">{
        if ws.scriptManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "Script manager not initialized",
                })
                return
        }</span>

        <span class="cov8" title="1">var updateData map[string]interface{}
        if err := c.ShouldBindJSON(&amp;updateData); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   fmt.Sprintf("Invalid request body: %v", err),
                })
                return
        }</span>

        // Get current configuration
        <span class="cov8" title="1">config := ws.scriptManager.GetConfig()

        // Update web port if provided (handle both camelCase and snake_case)
        if webPort, ok := updateData["webPort"]; ok </span><span class="cov0" title="0">{
                if port, isFloat := webPort.(float64); isFloat </span><span class="cov0" title="0">{
                        if port &gt;= 1 &amp;&amp; port &lt;= 65535 </span><span class="cov0" title="0">{
                                config.WebPort = int(port)
                        }</span> else<span class="cov0" title="0"> {
                                c.JSON(http.StatusBadRequest, APIResponse{
                                        Success: false,
                                        Error:   "Web port must be between 1 and 65535",
                                })
                                return
                        }</span>
                } else<span class="cov0" title="0"> {
                        c.JSON(http.StatusBadRequest, APIResponse{
                                Success: false,
                                Error:   "Web port must be a number",
                        })
                        return
                }</span>
        } else<span class="cov8" title="1"> if webPort, ok := updateData["web_port"]; ok </span><span class="cov8" title="1">{
                if port, isFloat := webPort.(float64); isFloat </span><span class="cov8" title="1">{
                        if port &gt;= 1 &amp;&amp; port &lt;= 65535 </span><span class="cov8" title="1">{
                                config.WebPort = int(port)
                        }</span> else<span class="cov0" title="0"> {
                                c.JSON(http.StatusBadRequest, APIResponse{
                                        Success: false,
                                        Error:   "Web port must be between 1 and 65535",
                                })
                                return
                        }</span>
                } else<span class="cov0" title="0"> {
                        c.JSON(http.StatusBadRequest, APIResponse{
                                Success: false,
                                Error:   "Web port must be a number",
                        })
                        return
                }</span>
        }

        // Save updated configuration
        <span class="cov8" title="1">if err := ws.scriptManager.SaveConfig(); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   fmt.Sprintf("Failed to save configuration: %v", err),
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data: map[string]interface{}{
                        "message": "Configuration updated successfully",
                        "config":  config,
                },
        })</span>
}

// Start starts the web server
func (ws *WebServer) Start() error <span class="cov8" title="1">{
        addr := fmt.Sprintf(":%d", ws.port)
        return ws.router.Run(addr)
}</span>

// getAggregatedLogs returns logs from all scripts in LogEntry format
func (ws *WebServer) getAggregatedLogs(maxEntries int) []LogEntry <span class="cov8" title="1">{
        // Initialize with non-nil slice to ensure JSON serializes as [] not null
        allLogs := make([]LogEntry, 0)

        if ws.scriptManager == nil </span><span class="cov8" title="1">{
                return allLogs
        }</span>

        // Get all configured scripts
        <span class="cov0" title="0">config := ws.scriptManager.GetConfig()
        for _, script := range config.Scripts </span><span class="cov0" title="0">{
                scriptLogs := ws.getScriptLogs(script.Name, maxEntries)
                allLogs = append(allLogs, scriptLogs...)
        }</span>

        // If we have more logs than requested, truncate to most recent
        <span class="cov0" title="0">if len(allLogs) &gt; maxEntries </span><span class="cov0" title="0">{
                allLogs = allLogs[len(allLogs)-maxEntries:]
        }</span>

        <span class="cov0" title="0">return allLogs</span>
}

// getScriptLogs returns logs for a specific script in LogEntry format
func (ws *WebServer) getScriptLogs(scriptName string, maxEntries int) []LogEntry <span class="cov8" title="1">{
        // Initialize with non-nil slice to ensure JSON serializes as [] not null
        logs := make([]LogEntry, 0)

        // Get log file path
        dir, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                dir, _ = os.Getwd()
        }</span> else<span class="cov8" title="1"> {
                dir = filepath.Dir(dir)
        }</span>

        <span class="cov8" title="1">logFile := filepath.Join(dir, fmt.Sprintf("%s.log", scriptName))

        // Check if log file exists
        if _, err := os.Stat(logFile); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return logs // Return empty array
        }</span>

        // Read log file content
        <span class="cov0" title="0">content, err := os.ReadFile(logFile)
        if err != nil </span><span class="cov0" title="0">{
                return logs // Return empty array on error
        }</span>

        // Parse log content into LogEntry objects
        <span class="cov0" title="0">lines := strings.Split(string(content), "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Simple log parsing - assume format: timestamp level message
                // For now, create basic LogEntry objects from raw log lines
                <span class="cov0" title="0">logEntry := LogEntry{
                        Timestamp: time.Now().Format(time.RFC3339), // Default timestamp
                        Message:   line,
                        Level:     "info", // Default level
                        Script:    scriptName,
                }

                // Try to extract timestamp and level from line if possible
                if len(line) &gt; 19 &amp;&amp; line[10] == 'T' </span><span class="cov0" title="0">{ // ISO timestamp format
                        if timestampEnd := strings.Index(line[20:], " "); timestampEnd &gt; 0 </span><span class="cov0" title="0">{
                                logEntry.Timestamp = line[:20+timestampEnd]
                                remaining := strings.TrimSpace(line[20+timestampEnd:])

                                // Check for level indicators
                                if strings.Contains(strings.ToLower(remaining), "error") </span><span class="cov0" title="0">{
                                        logEntry.Level = "error"
                                }</span> else<span class="cov0" title="0"> if strings.Contains(strings.ToLower(remaining), "warn") </span><span class="cov0" title="0">{
                                        logEntry.Level = "warning"
                                }</span>

                                <span class="cov0" title="0">logEntry.Message = remaining</span>
                        }
                }

                <span class="cov0" title="0">logs = append(logs, logEntry)</span>
        }

        // Limit to maxEntries (most recent)
        <span class="cov0" title="0">if len(logs) &gt; maxEntries </span><span class="cov0" title="0">{
                logs = logs[len(logs)-maxEntries:]
        }</span>

        <span class="cov0" title="0">return logs</span>
}

// handleGetGitProjects discovers and returns Git projects in a specified directory
func (ws *WebServer) handleGetGitProjects(c *gin.Context) <span class="cov8" title="1">{
        // Get directory parameter from query
        dir := c.DefaultQuery("dir", os.Getenv("HOME"))
        if dir == "" </span><span class="cov0" title="0">{
                dir = os.Getenv("HOME") // Fallback to home directory
        }</span>

        // Create Git discovery service
        <span class="cov8" title="1">gitService := service.NewGitDiscoveryService()
        projects, err := gitService.DiscoverGitProjects(dir)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   fmt.Sprintf("Failed to discover Git projects: %v", err),
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data: map[string]interface{}{
                        "projects": projects,
                },
        })</span>
}
</pre>

		<pre class="file" id="file5" style="display: none">package web

import (
        "fmt"
        "os"
        "path/filepath"
)

// VueBuildManager handles the Vue.js frontend build process
type VueBuildManager struct {
        ProjectRoot string
        FrontendDir string
        StaticDir   string
}

// NewVueBuildManager creates a new Vue build manager
func NewVueBuildManager(projectRoot string) *VueBuildManager <span class="cov8" title="1">{
        return &amp;VueBuildManager{
                ProjectRoot: projectRoot,
                FrontendDir: filepath.Join(projectRoot, "web", "frontend"),
                StaticDir:   filepath.Join(projectRoot, "web", "frontend", "dist"),
        }
}</span>

// InitializeFrontendProject sets up the complete Vue.js frontend project structure
func (vbm *VueBuildManager) InitializeFrontendProject() error <span class="cov0" title="0">{
        // Create main frontend directory
        if err := os.MkdirAll(vbm.FrontendDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create frontend directory: %w", err)
        }</span>

        // Initialize TypeScript Vue project (new approach)
        <span class="cov0" title="0">if err := vbm.initializeTypeScriptProject(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize TypeScript project: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// initializeTypeScriptProject sets up a complete TypeScript + Vue.js project
func (vbm *VueBuildManager) initializeTypeScriptProject() error <span class="cov0" title="0">{
        // For now, we assume the TypeScript frontend files are already in place
        // This method validates that all required TypeScript files exist

        // Check if TypeScript files exist (they should have been created by external process)
        requiredFiles := []string{
                "package.json",
                "tsconfig.json",
                "vite.config.ts",
                "vitest.config.ts",
                "index.html",
                "src/main.ts",
                "src/App.vue",
                "src/router/index.ts",
                "src/types/api.ts",
                "src/services/api.ts",
                "src/composables/useScripts.ts",
                "src/composables/useLogs.ts",
                "src/composables/useSystemMetrics.ts",
                "src/composables/useWebSocket.ts",
                "src/views/Dashboard.vue",
                "src/style.css",
                "tests/setup.ts",
                "tests/unit/services/api.test.ts",
                "tests/unit/composables/useScripts.test.ts",
                "tests/unit/components/Dashboard.test.ts",
        }

        missingFiles := []string{}
        for _, file := range requiredFiles </span><span class="cov0" title="0">{
                filePath := filepath.Join(vbm.FrontendDir, file)
                if _, err := os.Stat(filePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        missingFiles = append(missingFiles, file)
                }</span>
        }

        <span class="cov0" title="0">if len(missingFiles) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("missing required TypeScript files: %v", missingFiles)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetFrontendDir returns the frontend directory path
func (vbm *VueBuildManager) GetFrontendDir() string <span class="cov8" title="1">{
        return vbm.FrontendDir
}</span>

// GetStaticDir returns the static directory path
func (vbm *VueBuildManager) GetStaticDir() string <span class="cov8" title="1">{
        return vbm.StaticDir
}</span>

// CheckFrontendExists checks if the frontend directory structure exists
func (vbm *VueBuildManager) CheckFrontendExists() bool <span class="cov8" title="1">{
        requiredPaths := []string{
                filepath.Join(vbm.FrontendDir, "package.json"),
                filepath.Join(vbm.FrontendDir, "src", "main.ts"),
                filepath.Join(vbm.FrontendDir, "src", "App.vue"),
                filepath.Join(vbm.FrontendDir, "tsconfig.json"),
                filepath.Join(vbm.FrontendDir, "vite.config.ts"),
        }

        for _, path := range requiredPaths </span><span class="cov8" title="1">{
                if _, err := os.Stat(path); os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}
</pre>

		<pre class="file" id="file6" style="display: none">package web

import (
        "encoding/json"
        "log"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/gorilla/websocket"
)

// WebSocketMessage represents a message sent through WebSocket
type WebSocketMessage struct {
        Type      string                 `json:"type"`
        Timestamp time.Time              `json:"timestamp"`
        Data      map[string]interface{} `json:"data"`
}

var upgrader = websocket.Upgrader{
        CheckOrigin: func(r *http.Request) bool <span class="cov0" title="0">{
                return true // Allow connections from any origin
        }</span>,
}

// WebSocketClient represents a connected WebSocket client
type WebSocketClient struct {
        hub  *WebSocketHub
        conn *websocket.Conn
        send chan []byte
}

// WebSocketHub manages WebSocket connections and message broadcasting
type WebSocketHub struct {
        // Registered clients
        clients map[*WebSocketClient]bool

        // Inbound messages from the clients
        broadcast chan []byte

        // Register requests from the clients
        register chan *WebSocketClient

        // Unregister requests from clients
        unregister chan *WebSocketClient

        // Maximum number of concurrent connections
        maxConnections int
}

const (
        // MaxWebSocketConnections defines the maximum number of concurrent WebSocket connections
        MaxWebSocketConnections = 100
)

// NewWebSocketHub creates a new WebSocket hub
func NewWebSocketHub() *WebSocketHub <span class="cov8" title="1">{
        return &amp;WebSocketHub{
                broadcast:      make(chan []byte, 256),
                register:       make(chan *WebSocketClient),
                unregister:     make(chan *WebSocketClient),
                clients:        make(map[*WebSocketClient]bool),
                maxConnections: MaxWebSocketConnections,
        }
}</span>

// Run starts the WebSocket hub
func (h *WebSocketHub) Run() <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                case client := &lt;-h.register:<span class="cov0" title="0">
                        // Check connection limit
                        if len(h.clients) &gt;= h.maxConnections </span><span class="cov0" title="0">{
                                log.Printf("WebSocket connection limit reached (%d), rejecting new connection", h.maxConnections)
                                close(client.send)
                                client.conn.Close()
                        }</span> else<span class="cov0" title="0"> {
                                h.clients[client] = true
                                log.Printf("WebSocket client connected, total: %d", len(h.clients))
                        }</span>

                case client := &lt;-h.unregister:<span class="cov0" title="0">
                        if _, ok := h.clients[client]; ok </span><span class="cov0" title="0">{
                                delete(h.clients, client)
                                close(client.send)
                                log.Printf("WebSocket client disconnected, total: %d", len(h.clients))
                        }</span>

                case message := &lt;-h.broadcast:<span class="cov8" title="1">
                        for client := range h.clients </span><span class="cov0" title="0">{
                                select </span>{
                                case client.send &lt;- message:<span class="cov0" title="0"></span>
                                default:<span class="cov0" title="0">
                                        // Client can't receive message, disconnect it
                                        close(client.send)
                                        delete(h.clients, client)
                                        client.conn.Close()</span>
                                }
                        }
                }
        }
}

// BroadcastMessage sends a message to all connected clients
func (h *WebSocketHub) BroadcastMessage(msgType string, data map[string]interface{}) error <span class="cov8" title="1">{
        message := WebSocketMessage{
                Type:      msgType,
                Timestamp: time.Now(),
                Data:      data,
        }

        messageBytes, err := json.Marshal(message)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">select </span>{
        case h.broadcast &lt;- messageBytes:<span class="cov8" title="1"></span>
        default:<span class="cov0" title="0"></span>
                // Channel is full, skip message
        }

        <span class="cov8" title="1">return nil</span>
}

// GetConnectionCount returns the number of active connections
func (h *WebSocketHub) GetConnectionCount() int <span class="cov8" title="1">{
        return len(h.clients)
}</span>

// HandleWebSocket handles WebSocket connections
func HandleWebSocket(hub *WebSocketHub, c *gin.Context) <span class="cov8" title="1">{
        conn, err := upgrader.Upgrade(c.Writer, c.Request, nil)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("WebSocket upgrade error: %v", err)
                return
        }</span>

        <span class="cov0" title="0">client := &amp;WebSocketClient{
                hub:  hub,
                conn: conn,
                send: make(chan []byte, 256),
        }

        client.hub.register &lt;- client

        // Start goroutines for reading and writing
        go client.writePump()
        go client.readPump()</span>
}

// readPump handles reading messages from the WebSocket connection
func (c *WebSocketClient) readPump() <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                c.hub.unregister &lt;- c
                c.conn.Close()
        }</span>()

        <span class="cov0" title="0">c.conn.SetReadLimit(512)
        c.conn.SetReadDeadline(time.Now().Add(60 * time.Second))
        c.conn.SetPongHandler(func(string) error </span><span class="cov0" title="0">{
                c.conn.SetReadDeadline(time.Now().Add(60 * time.Second))
                return nil
        }</span>)

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                _, _, err := c.conn.ReadMessage()
                if err != nil </span><span class="cov0" title="0">{
                        if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) </span><span class="cov0" title="0">{
                                log.Printf("WebSocket error: %v", err)
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
        }
}

// writePump handles writing messages to the WebSocket connection
func (c *WebSocketClient) writePump() <span class="cov0" title="0">{
        ticker := time.NewTicker(54 * time.Second)
        defer func() </span><span class="cov0" title="0">{
                ticker.Stop()
                c.conn.Close()
        }</span>()

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case message, ok := &lt;-c.send:<span class="cov0" title="0">
                        c.conn.SetWriteDeadline(time.Now().Add(10 * time.Second))
                        if !ok </span><span class="cov0" title="0">{
                                c.conn.WriteMessage(websocket.CloseMessage, []byte{})
                                return
                        }</span>

                        <span class="cov0" title="0">w, err := c.conn.NextWriter(websocket.TextMessage)
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">w.Write(message)

                        // Add queued messages to the current message
                        n := len(c.send)
                        for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                                w.Write([]byte{'\n'})
                                w.Write(&lt;-c.send)
                        }</span>

                        <span class="cov0" title="0">if err := w.Close(); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>

                case &lt;-ticker.C:<span class="cov0" title="0">
                        c.conn.SetWriteDeadline(time.Now().Add(10 * time.Second))
                        if err := c.conn.WriteMessage(websocket.PingMessage, nil); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }
}
</pre>

		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
