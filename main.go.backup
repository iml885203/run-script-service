package main

import (
	"bufio"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"os"
	"os/exec"
	"os/signal"
	"path/filepath"
	"strconv"
	"strings"
	"syscall"
	"time"
)

type Config struct {
	Interval int `json:"interval"`
}

type Service struct {
	config     Config
	scriptPath string
	logPath    string
	configPath string
	maxLines   int
	running    bool
	ctx        context.Context
	cancel     context.CancelFunc
}

func NewService() *Service {
	dir, err := os.Executable()
	if err != nil {
		dir, _ = os.Getwd()
	} else {
		dir = filepath.Dir(dir)
	}

	s := &Service{
		config:     Config{Interval: 3600}, // Default 1 hour
		scriptPath: filepath.Join(dir, "run.sh"),
		logPath:    filepath.Join(dir, "run.log"),
		configPath: filepath.Join(dir, "service_config.json"),
		maxLines:   100,
		running:    false,
	}

	s.ctx, s.cancel = context.WithCancel(context.Background())
	s.loadConfig()
	return s
}

func (s *Service) loadConfig() {
	if _, err := os.Stat(s.configPath); os.IsNotExist(err) {
		return
	}

	data, err := os.ReadFile(s.configPath)
	if err != nil {
		log.Printf("Error reading config: %v", err)
		return
	}

	if err := json.Unmarshal(data, &s.config); err != nil {
		log.Printf("Error parsing config: %v", err)
	}
}

func (s *Service) saveConfig() error {
	data, err := json.MarshalIndent(s.config, "", "  ")
	if err != nil {
		return fmt.Errorf("error marshaling config: %v", err)
	}

	if err := os.WriteFile(s.configPath, data, 0644); err != nil {
		return fmt.Errorf("error writing config: %v", err)
	}

	return nil
}

func (s *Service) setInterval(interval int) error {
	s.config.Interval = interval
	if err := s.saveConfig(); err != nil {
		return err
	}
	fmt.Printf("Interval set to %d seconds\n", interval)
	return nil
}

func (s *Service) trimLog() error {
	file, err := os.Open(s.logPath)
	if os.IsNotExist(err) {
		return nil
	}
	if err != nil {
		return err
	}
	defer file.Close()

	var lines []string
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		lines = append(lines, scanner.Text())
	}

	if err := scanner.Err(); err != nil {
		return err
	}

	if len(lines) <= s.maxLines {
		return nil
	}

	// Keep only the last maxLines lines
	linesToKeep := lines[len(lines)-s.maxLines:]

	outFile, err := os.Create(s.logPath)
	if err != nil {
		return err
	}
	defer outFile.Close()

	for _, line := range linesToKeep {
		if _, err := outFile.WriteString(line + "\n"); err != nil {
			return err
		}
	}

	return nil
}

func (s *Service) executeScript() {
	timestamp := time.Now().Format("2006-01-02 15:04:05")

	cmd := exec.Command(s.scriptPath)
	cmd.Dir = filepath.Dir(s.scriptPath)

	stdout, err := cmd.StdoutPipe()
	if err != nil {
		s.logError(timestamp, fmt.Sprintf("Error creating stdout pipe: %v", err))
		return
	}

	stderr, err := cmd.StderrPipe()
	if err != nil {
		s.logError(timestamp, fmt.Sprintf("Error creating stderr pipe: %v", err))
		return
	}

	if err := cmd.Start(); err != nil {
		s.logError(timestamp, fmt.Sprintf("Error starting command: %v", err))
		return
	}

	stdoutBytes, _ := io.ReadAll(stdout)
	stderrBytes, _ := io.ReadAll(stderr)

	err = cmd.Wait()
	exitCode := 0
	if err != nil {
		if exitError, ok := err.(*exec.ExitError); ok {
			exitCode = exitError.ExitCode()
		} else {
			s.logError(timestamp, fmt.Sprintf("Error waiting for command: %v", err))
			return
		}
	}

	// Write to log
	logEntry := fmt.Sprintf("[%s] Exit code: %d\n", timestamp, exitCode)
	if len(stdoutBytes) > 0 {
		logEntry += fmt.Sprintf("STDOUT: %s\n", strings.TrimSpace(string(stdoutBytes)))
	}
	if len(stderrBytes) > 0 {
		logEntry += fmt.Sprintf("STDERR: %s\n", strings.TrimSpace(string(stderrBytes)))
	}
	logEntry += strings.Repeat("-", 50) + "\n"

	if err := s.writeLog(logEntry); err != nil {
		log.Printf("Error writing to log: %v", err)
	}

	if err := s.trimLog(); err != nil {
		log.Printf("Error trimming log: %v", err)
	}

	fmt.Printf("Script executed at %s, exit code: %d\n", timestamp, exitCode)
}

func (s *Service) logError(timestamp, message string) {
	errorMsg := fmt.Sprintf("[%s] ERROR: %s\n%s\n", timestamp, message, strings.Repeat("-", 50))
	if err := s.writeLog(errorMsg); err != nil {
		log.Printf("Error writing error to log: %v", err)
	}
	log.Printf("Error executing script: %s", message)
}

func (s *Service) writeLog(content string) error {
	file, err := os.OpenFile(s.logPath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		return err
	}
	defer file.Close()

	_, err = file.WriteString(content)
	return err
}

func (s *Service) run() {
	s.running = true
	fmt.Printf("Service started with %d second interval\n", s.config.Interval)

	// Set up signal handling
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, syscall.SIGTERM, syscall.SIGINT)

	ticker := time.NewTicker(time.Duration(s.config.Interval) * time.Second)
	defer ticker.Stop()

	// Execute immediately on start
	s.executeScript()

	for {
		select {
		case <-s.ctx.Done():
			fmt.Println("Service stopping...")
			return
		case <-sigChan:
			fmt.Println("Received shutdown signal")
			s.stop()
			return
		case <-ticker.C:
			if s.running {
				s.executeScript()
			}
		}
	}
}

func (s *Service) stop() {
	s.running = false
	s.cancel()
}

func (s *Service) showConfig() {
	fmt.Printf("Current configuration:\n")
	fmt.Printf("  Interval: %d seconds (%s)\n", s.config.Interval, formatDuration(s.config.Interval))
	fmt.Printf("  Script: %s\n", s.scriptPath)
	fmt.Printf("  Log: %s\n", s.logPath)
	fmt.Printf("  Config: %s\n", s.configPath)
}

func formatDuration(seconds int) string {
	if seconds < 60 {
		return fmt.Sprintf("%ds", seconds)
	} else if seconds < 3600 {
		return fmt.Sprintf("%dm", seconds/60)
	} else {
		return fmt.Sprintf("%dh", seconds/3600)
	}
}

func parseInterval(intervalStr string) (int, error) {
	if len(intervalStr) == 0 {
		return 0, fmt.Errorf("empty interval")
	}

	suffix := intervalStr[len(intervalStr)-1:]
	valueStr := intervalStr[:len(intervalStr)-1]

	value, err := strconv.Atoi(valueStr)
	if err != nil {
		// Try parsing as plain number (seconds)
		return strconv.Atoi(intervalStr)
	}

	switch suffix {
	case "s":
		return value, nil
	case "m":
		return value * 60, nil
	case "h":
		return value * 3600, nil
	default:
		// No suffix, treat as seconds
		return strconv.Atoi(intervalStr)
	}
}

func main() {
	service := NewService()

	if len(os.Args) < 2 {
		service.run()
		return
	}

	command := os.Args[1]

	switch command {
	case "run":
		service.run()
	case "set-interval":
		if len(os.Args) != 3 {
			fmt.Println("Usage: ./run-script-service set-interval <interval>")
			fmt.Println("Examples: 30s, 5m, 1h, 3600")
			os.Exit(1)
		}
		interval, err := parseInterval(os.Args[2])
		if err != nil {
			fmt.Printf("Invalid interval: %v\n", err)
			os.Exit(1)
		}
		if err := service.setInterval(interval); err != nil {
			fmt.Printf("Error setting interval: %v\n", err)
			os.Exit(1)
		}
	case "show-config":
		service.showConfig()
	default:
		fmt.Printf("Unknown command: %s\n", command)
		fmt.Println("Available commands: run, set-interval, show-config")
		os.Exit(1)
	}
}
