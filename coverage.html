
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>auth: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">run-script-service/auth/handler.go (85.2%)</option>
				
				<option value="file1">run-script-service/auth/middleware.go (100.0%)</option>
				
				<option value="file2">run-script-service/auth/session.go (83.9%)</option>
				
				<option value="file3">run-script-service/main.go (57.8%)</option>
				
				<option value="file4">run-script-service/mocks/filesystem.go (26.7%)</option>
				
				<option value="file5">run-script-service/service/config.go (51.6%)</option>
				
				<option value="file6">run-script-service/service/debug_logger.go (100.0%)</option>
				
				<option value="file7">run-script-service/service/env_loader.go (89.3%)</option>
				
				<option value="file8">run-script-service/service/event.go (100.0%)</option>
				
				<option value="file9">run-script-service/service/executor.go (74.4%)</option>
				
				<option value="file10">run-script-service/service/file_manager.go (85.1%)</option>
				
				<option value="file11">run-script-service/service/git_discovery.go (88.2%)</option>
				
				<option value="file12">run-script-service/service/log_manager.go (33.0%)</option>
				
				<option value="file13">run-script-service/service/monitor.go (70.4%)</option>
				
				<option value="file14">run-script-service/service/script_file_manager.go (87.9%)</option>
				
				<option value="file15">run-script-service/service/script_generator.go (84.8%)</option>
				
				<option value="file16">run-script-service/service/script_manager.go (44.3%)</option>
				
				<option value="file17">run-script-service/service/script_runner.go (76.1%)</option>
				
				<option value="file18">run-script-service/service/service.go (89.5%)</option>
				
				<option value="file19">run-script-service/service/streaming_executor.go (83.1%)</option>
				
				<option value="file20">run-script-service/web/event_bridge.go (100.0%)</option>
				
				<option value="file21">run-script-service/web/frontend_setup.go (82.6%)</option>
				
				<option value="file22">run-script-service/web/handlers_files.go (78.3%)</option>
				
				<option value="file23">run-script-service/web/handlers_script_files.go (68.0%)</option>
				
				<option value="file24">run-script-service/web/server.go (50.6%)</option>
				
				<option value="file25">run-script-service/web/vue_build_manager.go (13.6%)</option>
				
				<option value="file26">run-script-service/web/websocket.go (18.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package auth

import (
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
)

// AuthHandler handles authentication-related HTTP requests
type AuthHandler struct {
        sessionManager *SessionManager
        secretKey      string
}

// LoginRequest represents the login request payload
type LoginRequest struct {
        SecretKey string `json:"secretKey" binding:"required"`
}

// NewAuthHandler creates a new authentication handler
func NewAuthHandler(secretKey string) *AuthHandler <span class="cov8" title="1">{
        sessionManager := NewSessionManagerWithTimeout(24 * time.Hour) // 24-hour session timeout
        return &amp;AuthHandler{
                sessionManager: sessionManager,
                secretKey:      secretKey,
        }
}</span>

// GetSessionManager returns the session manager instance
func (ah *AuthHandler) GetSessionManager() *SessionManager <span class="cov8" title="1">{
        return ah.sessionManager
}</span>

// Login handles the login endpoint
func (ah *AuthHandler) Login(c *gin.Context) <span class="cov8" title="1">{
        var req LoginRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request body",
                })
                return
        }</span>

        // Verify secret key
        <span class="cov8" title="1">if req.SecretKey != ah.secretKey </span><span class="cov8" title="1">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "Invalid secret key",
                })
                return
        }</span>

        // Create session (using "authenticated" as user ID since we only have secret-based auth)
        <span class="cov8" title="1">sessionToken, err := ah.sessionManager.CreateSession("authenticated")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to create session",
                })
                return
        }</span>

        // Set session cookie
        <span class="cov8" title="1">c.SetCookie(
                "session",                   // name
                sessionToken,                // value
                int(24*time.Hour.Seconds()), // max age (24 hours)
                "/",                         // path
                "",                          // domain
                false,                       // secure (set to true in production with HTTPS)
                true,                        // httpOnly
        )

        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Login successful",
        })</span>
}

// Logout handles the logout endpoint
func (ah *AuthHandler) Logout(c *gin.Context) <span class="cov8" title="1">{
        // Get session cookie
        sessionCookie, err := c.Request.Cookie("session")
        if err == nil </span><span class="cov8" title="1">{
                // Destroy the session
                ah.sessionManager.DestroySession(sessionCookie.Value)
        }</span>

        // Clear the session cookie
        <span class="cov8" title="1">c.SetCookie(
                "session",
                "",
                -1,    // max age (expired)
                "/",   // path
                "",    // domain
                false, // secure
                true,  // httpOnly
        )

        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Logout successful",
        })</span>
}

// AuthStatus returns the current authentication status
func (ah *AuthHandler) AuthStatus(c *gin.Context) <span class="cov8" title="1">{
        // Check if session cookie exists
        sessionCookie, err := c.Request.Cookie("session")
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusOK, gin.H{
                        "success": true,
                        "data": gin.H{
                                "authenticated": false,
                        },
                })
                return
        }</span>

        // Validate session
        <span class="cov8" title="1">_, valid := ah.sessionManager.ValidateSession(sessionCookie.Value)

        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data": gin.H{
                        "authenticated": valid,
                },
        })</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package auth

import (
        "net/http"

        "github.com/gin-gonic/gin"
)

// AuthMiddleware provides authentication middleware for HTTP requests
type AuthMiddleware struct {
        sessionManager *SessionManager
}

// NewAuthMiddleware creates a new authentication middleware
func NewAuthMiddleware(sessionManager *SessionManager) *AuthMiddleware <span class="cov8" title="1">{
        return &amp;AuthMiddleware{
                sessionManager: sessionManager,
        }
}</span>

// IsAuthenticated checks if the current request is authenticated
func (am *AuthMiddleware) IsAuthenticated(c *gin.Context) bool <span class="cov8" title="1">{
        // Get session cookie
        sessionCookie, err := c.Request.Cookie("session")
        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>

        // Validate session
        <span class="cov8" title="1">_, valid := am.sessionManager.ValidateSession(sessionCookie.Value)
        return valid</span>
}

// RequireAuth returns a Gin middleware that requires authentication
func (am *AuthMiddleware) RequireAuth() gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                // Get session cookie
                sessionCookie, err := c.Request.Cookie("session")
                if err != nil </span><span class="cov8" title="1">{
                        c.JSON(http.StatusUnauthorized, gin.H{
                                "success": false,
                                "error":   "Authentication required",
                        })
                        c.Abort()
                        return
                }</span>

                // Validate session
                <span class="cov8" title="1">userID, valid := am.sessionManager.ValidateSession(sessionCookie.Value)
                if !valid </span><span class="cov8" title="1">{
                        c.JSON(http.StatusUnauthorized, gin.H{
                                "success": false,
                                "error":   "Invalid or expired session",
                        })
                        c.Abort()
                        return
                }</span>

                // Set user ID in context for handlers to use
                <span class="cov8" title="1">c.Set("userID", userID)
                c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package auth provides authentication and session management
package auth

import (
        "crypto/rand"
        "encoding/hex"
        "fmt"
        "sync"
        "time"
)

// Session represents an authentication session
type Session struct {
        UserID    string
        CreatedAt time.Time
        ExpiresAt time.Time
}

// SessionManager manages authentication sessions
type SessionManager struct {
        sessions map[string]*Session
        timeout  time.Duration
        mutex    sync.RWMutex
}

// NewSessionManager creates a new session manager with default 24 hour timeout
func NewSessionManager() *SessionManager <span class="cov8" title="1">{
        return NewSessionManagerWithTimeout(24 * time.Hour)
}</span>

// NewSessionManagerWithTimeout creates a new session manager with custom timeout
func NewSessionManagerWithTimeout(timeout time.Duration) *SessionManager <span class="cov8" title="1">{
        return &amp;SessionManager{
                sessions: make(map[string]*Session),
                timeout:  timeout,
        }
}</span>

// CreateSession creates a new session and returns the session token
func (sm *SessionManager) CreateSession(userID string) (string, error) <span class="cov8" title="1">{
        // Generate cryptographically secure session token
        token, err := generateSessionToken()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to generate session token: %v", err)
        }</span>

        <span class="cov8" title="1">sm.mutex.Lock()
        defer sm.mutex.Unlock()

        // Create session
        session := &amp;Session{
                UserID:    userID,
                CreatedAt: time.Now(),
                ExpiresAt: time.Now().Add(sm.timeout),
        }

        sm.sessions[token] = session

        return token, nil</span>
}

// ValidateSession validates a session token and returns the user ID if valid
func (sm *SessionManager) ValidateSession(token string) (string, bool) <span class="cov8" title="1">{
        sm.mutex.RLock()
        defer sm.mutex.RUnlock()

        session, exists := sm.sessions[token]
        if !exists </span><span class="cov8" title="1">{
                return "", false
        }</span>

        // Check if session has expired
        <span class="cov8" title="1">if time.Now().After(session.ExpiresAt) </span><span class="cov8" title="1">{
                // Clean up expired session
                go func() </span><span class="cov0" title="0">{
                        sm.mutex.Lock()
                        defer sm.mutex.Unlock()
                        delete(sm.sessions, token)
                }</span>()
                <span class="cov8" title="1">return "", false</span>
        }

        <span class="cov8" title="1">return session.UserID, true</span>
}

// DestroySession removes a session
func (sm *SessionManager) DestroySession(token string) error <span class="cov8" title="1">{
        sm.mutex.Lock()
        defer sm.mutex.Unlock()

        delete(sm.sessions, token)
        return nil
}</span>

// generateSessionToken generates a cryptographically secure random session token
func generateSessionToken() (string, error) <span class="cov8" title="1">{
        bytes := make([]byte, 32) // 256 bits
        _, err := rand.Read(bytes)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return hex.EncodeToString(bytes), nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package main provides the run-script-service daemon executable.
package main

import (
        "context"
        "crypto/rand"
        "encoding/hex"
        "fmt"
        "os"
        "os/exec"
        "os/signal"
        "path/filepath"
        "strconv"
        "strings"
        "syscall"
        "time"

        "run-script-service/service"
        "run-script-service/web"
)

// CommandResult represents the result of command processing
type CommandResult struct {
        shouldRunService bool
        webMode          bool
}

// handleCommand processes command line arguments and returns appropriate action
func handleCommand(args []string, scriptPath, logPath, configPath string, maxLines int) (CommandResult, error) <span class="cov8" title="1">{
        svc := service.NewService(scriptPath, logPath, configPath, maxLines)

        if len(args) &lt; 2 </span><span class="cov8" title="1">{
                return CommandResult{shouldRunService: true, webMode: true}, nil
        }</span>

        <span class="cov8" title="1">command := args[1]

        switch command </span>{
        case "run":<span class="cov8" title="1">
                // Always enable web mode by default
                result := CommandResult{shouldRunService: true, webMode: true}
                return result, nil</span>
        case "set-interval":<span class="cov8" title="1">
                if len(args) != 3 </span><span class="cov8" title="1">{
                        return CommandResult{shouldRunService: false},
                                fmt.Errorf("usage: ./run-script-service set-interval &lt;interval&gt;\nexamples: 30s, 5m, 1h, 3600")
                }</span>
                <span class="cov8" title="1">interval, err := parseInterval(args[2])
                if err != nil </span><span class="cov8" title="1">{
                        return CommandResult{shouldRunService: false},
                                fmt.Errorf("invalid interval: %v", err)
                }</span>
                <span class="cov8" title="1">if err := svc.SetInterval(interval); err != nil </span><span class="cov0" title="0">{
                        return CommandResult{shouldRunService: false},
                                fmt.Errorf("error setting interval: %v", err)
                }</span>
                <span class="cov8" title="1">return CommandResult{shouldRunService: false}, nil</span>
        case "show-config":<span class="cov8" title="1">
                svc.ShowConfig()
                return CommandResult{shouldRunService: false}, nil</span>
        case "add-script":<span class="cov8" title="1">
                return handleAddScript(args[2:], configPath)</span>
        case "list-scripts":<span class="cov8" title="1">
                return handleListScripts(configPath)</span>
        case "enable-script":<span class="cov8" title="1">
                if len(args) != 3 </span><span class="cov0" title="0">{
                        return CommandResult{shouldRunService: false},
                                fmt.Errorf("usage: ./run-script-service enable-script &lt;script-name&gt;")
                }</span>
                <span class="cov8" title="1">return handleEnableScript(args[2], configPath)</span>
        case "disable-script":<span class="cov8" title="1">
                if len(args) != 3 </span><span class="cov0" title="0">{
                        return CommandResult{shouldRunService: false},
                                fmt.Errorf("usage: ./run-script-service disable-script &lt;script-name&gt;")
                }</span>
                <span class="cov8" title="1">return handleDisableScript(args[2], configPath)</span>
        case "remove-script":<span class="cov8" title="1">
                if len(args) != 3 </span><span class="cov0" title="0">{
                        return CommandResult{shouldRunService: false},
                                fmt.Errorf("usage: ./run-script-service remove-script &lt;script-name&gt;")
                }</span>
                <span class="cov8" title="1">return handleRemoveScript(args[2], configPath)</span>
        case "run-script":<span class="cov8" title="1">
                if len(args) != 3 </span><span class="cov0" title="0">{
                        return CommandResult{shouldRunService: false},
                                fmt.Errorf("usage: ./run-script-service run-script &lt;script-name&gt;")
                }</span>
                <span class="cov8" title="1">return handleRunScript(args[2], configPath)</span>
        case "logs":<span class="cov8" title="1">
                return handleLogs(args[2:], configPath)</span>
        case "clear-logs":<span class="cov8" title="1">
                return handleClearLogs(args[2:], configPath)</span>
        case "set-web-port":<span class="cov8" title="1">
                if len(args) != 3 </span><span class="cov0" title="0">{
                        return CommandResult{shouldRunService: false},
                                fmt.Errorf("usage: ./run-script-service set-web-port &lt;port&gt;")
                }</span>
                <span class="cov8" title="1">return handleSetWebPort(args[2], configPath)</span>
        case "daemon":<span class="cov0" title="0">
                if len(args) &lt; 3 </span><span class="cov0" title="0">{
                        return CommandResult{shouldRunService: false},
                                fmt.Errorf("usage: ./run-script-service daemon &lt;start|stop|status|restart|logs&gt;")
                }</span>
                <span class="cov0" title="0">return handleDaemonCommand(args[2], configPath)</span>
        default:<span class="cov8" title="1">
                availableCommands := "run, set-interval, show-config, add-script, " +
                        "list-scripts, enable-script, disable-script, remove-script, run-script, logs, clear-logs, set-web-port, daemon"
                return CommandResult{shouldRunService: false},
                        fmt.Errorf("unknown command: %s\navailable commands: %s", command, availableCommands)</span>
        }
}

func main() <span class="cov0" title="0">{
        // Get paths relative to executable
        dir, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                dir, _ = os.Getwd()
        }</span> else<span class="cov0" title="0"> {
                dir = filepath.Dir(dir)
        }</span>

        <span class="cov0" title="0">scriptPath := filepath.Join(dir, "run.sh")
        logPath := filepath.Join(dir, "run.log")
        configPath := filepath.Join(dir, "service_config.json")
        maxLines := 100

        result, err := handleCommand(os.Args, scriptPath, logPath, configPath, maxLines)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("%v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if result.shouldRunService </span><span class="cov0" title="0">{
                if result.webMode </span><span class="cov0" title="0">{
                        runMultiScriptServiceWithWeb(configPath)
                }</span> else<span class="cov0" title="0"> {
                        runMultiScriptService(configPath)
                }</span>
        }
}

func runService(svc *service.Service) <span class="cov0" title="0">{
        // Set up signal handling
        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGTERM, syscall.SIGINT)

        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        // Start service in a goroutine
        done := make(chan bool)
        go func() </span><span class="cov0" title="0">{
                svc.Start(ctx)
                done &lt;- true
        }</span>()

        // Wait for signal or service completion
        <span class="cov0" title="0">select </span>{
        case &lt;-sigChan:<span class="cov0" title="0">
                fmt.Println("Received shutdown signal")
                svc.Stop()
                cancel()
                &lt;-done</span> // Wait for service to finish
        case &lt;-done:<span class="cov0" title="0"></span>
                // Service finished naturally
        }
}

func runMultiScriptService(configPath string) <span class="cov0" title="0">{
        // Load service configuration
        var config service.ServiceConfig
        err := service.LoadServiceConfig(configPath, &amp;config)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to load config: %v\n", err)
                os.Exit(1)
        }</span>

        // Set default web port if not configured
        <span class="cov0" title="0">if config.WebPort == 0 </span><span class="cov0" title="0">{
                config.WebPort = 8080
        }</span>

        // Create script manager
        <span class="cov0" title="0">manager := service.NewScriptManager(&amp;config)

        // Set up signal handling
        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGTERM, syscall.SIGINT)

        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        // Start all enabled scripts
        err = manager.StartAllEnabled(ctx)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to start scripts: %v\n", err)
                cancel()
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Println("Multi-script service started")
        fmt.Printf("Running scripts: %v\n", manager.GetRunningScripts())

        // Wait for shutdown signal
        &lt;-sigChan
        fmt.Println("Received shutdown signal")

        // Stop all scripts
        manager.StopAll()
        cancel()

        fmt.Println("Service stopped")</span>
}

// Testable version of runMultiScriptService that returns results instead of calling os.Exit
type ServiceResult struct {
        Manager *service.ScriptManager
        Config  *service.ServiceConfig
}

func runMultiScriptServiceTestable(configPath string, ctx context.Context) (*ServiceResult, error) <span class="cov8" title="1">{
        // Load service configuration
        var config service.ServiceConfig
        err := service.LoadServiceConfig(configPath, &amp;config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Set default web port if not configured
        <span class="cov8" title="1">if config.WebPort == 0 </span><span class="cov8" title="1">{
                config.WebPort = 8080
        }</span>

        // Create script manager
        <span class="cov8" title="1">manager := service.NewScriptManager(&amp;config)

        // Start all enabled scripts
        err = manager.StartAllEnabled(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;ServiceResult{
                Manager: manager,
                Config:  &amp;config,
        }, nil</span>
}

func parseInterval(intervalStr string) (int, error) <span class="cov8" title="1">{
        if intervalStr == "" </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("empty interval")
        }</span>

        <span class="cov8" title="1">suffix := intervalStr[len(intervalStr)-1:]
        valueStr := intervalStr[:len(intervalStr)-1]

        value, err := strconv.Atoi(valueStr)
        if err != nil </span><span class="cov8" title="1">{
                // Try parsing as plain number (seconds)
                result, parseErr := strconv.Atoi(intervalStr)
                if parseErr != nil </span><span class="cov8" title="1">{
                        return 0, parseErr
                }</span>
                <span class="cov0" title="0">if result &lt; 0 </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("negative interval not allowed")
                }</span>
                <span class="cov0" title="0">return result, nil</span>
        }

        <span class="cov8" title="1">switch suffix </span>{
        case "s":<span class="cov8" title="1">
                if value &lt; 0 </span><span class="cov8" title="1">{
                        return 0, fmt.Errorf("negative interval not allowed")
                }</span>
                <span class="cov8" title="1">return value, nil</span>
        case "m":<span class="cov8" title="1">
                if value &lt; 0 </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("negative interval not allowed")
                }</span>
                <span class="cov8" title="1">return value * 60, nil</span>
        case "h":<span class="cov8" title="1">
                if value &lt; 0 </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("negative interval not allowed")
                }</span>
                <span class="cov8" title="1">return value * 3600, nil</span>
        default:<span class="cov8" title="1">
                // No suffix, treat as seconds
                result, err := strconv.Atoi(intervalStr)
                if err != nil </span><span class="cov8" title="1">{
                        return 0, err
                }</span>
                <span class="cov8" title="1">if result &lt; 0 </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("negative interval not allowed")
                }</span>
                <span class="cov8" title="1">return result, nil</span>
        }
}

// parseScriptFlags parses command line flags for script management
func parseScriptFlags(args []string) (map[string]string, error) <span class="cov8" title="1">{
        flags := make(map[string]string)

        for _, arg := range args </span><span class="cov8" title="1">{
                if !strings.HasPrefix(arg, "--") </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">parts := strings.SplitN(arg[2:], "=", 2)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid flag format: %s (expected --key=value)", arg)
                }</span>

                <span class="cov8" title="1">flags[parts[0]] = parts[1]</span>
        }

        // Check required flags for add-script
        <span class="cov8" title="1">required := []string{"name", "path", "interval"}
        for _, req := range required </span><span class="cov8" title="1">{
                if _, ok := flags[req]; !ok </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("missing required flag: --%s", req)
                }</span>
        }

        <span class="cov8" title="1">return flags, nil</span>
}

// handleAddScript adds a new script to the configuration
func handleAddScript(args []string, configPath string) (CommandResult, error) <span class="cov8" title="1">{
        flags, err := parseScriptFlags(args)
        if err != nil </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, err
        }</span>

        // Parse interval
        <span class="cov8" title="1">interval, err := parseInterval(flags["interval"])
        if err != nil </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, fmt.Errorf("invalid interval: %v", err)
        }</span>

        // Parse optional flags
        <span class="cov8" title="1">maxLogLines := 100
        if val, ok := flags["max-log-lines"]; ok </span><span class="cov0" title="0">{
                if parsed, parseErr := strconv.Atoi(val); parseErr == nil &amp;&amp; parsed &gt; 0 </span><span class="cov0" title="0">{
                        maxLogLines = parsed
                }</span>
        }

        <span class="cov8" title="1">timeout := 0
        if val, ok := flags["timeout"]; ok </span><span class="cov0" title="0">{
                if parsed, parseErr := strconv.Atoi(val); parseErr == nil &amp;&amp; parsed &gt;= 0 </span><span class="cov0" title="0">{
                        timeout = parsed
                }</span>
        }

        // Load existing configuration
        <span class="cov8" title="1">var config service.ServiceConfig
        err = service.LoadServiceConfig(configPath, &amp;config)
        if err != nil </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, fmt.Errorf("failed to load config: %v", err)
        }</span>

        // Check if script name already exists
        <span class="cov8" title="1">for _, script := range config.Scripts </span><span class="cov0" title="0">{
                if script.Name == flags["name"] </span><span class="cov0" title="0">{
                        return CommandResult{shouldRunService: false}, fmt.Errorf("script with name '%s' already exists", flags["name"])
                }</span>
        }

        // Add new script
        <span class="cov8" title="1">newScript := service.ScriptConfig{
                Name:        flags["name"],
                Path:        flags["path"],
                Interval:    interval,
                Enabled:     true,
                MaxLogLines: maxLogLines,
                Timeout:     timeout,
        }

        if validateErr := newScript.Validate(); validateErr != nil </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, fmt.Errorf("invalid script configuration: %v", validateErr)
        }</span>

        <span class="cov8" title="1">config.Scripts = append(config.Scripts, newScript)

        // Save configuration
        err = service.SaveServiceConfig(configPath, &amp;config)
        if err != nil </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, fmt.Errorf("failed to save config: %v", err)
        }</span>

        <span class="cov8" title="1">fmt.Printf("Script '%s' added successfully\n", flags["name"])
        return CommandResult{shouldRunService: false}, nil</span>
}

// handleListScripts lists all configured scripts
func handleListScripts(configPath string) (CommandResult, error) <span class="cov8" title="1">{
        var config service.ServiceConfig
        err := service.LoadServiceConfig(configPath, &amp;config)
        if err != nil </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, fmt.Errorf("failed to load config: %v", err)
        }</span>

        <span class="cov8" title="1">if len(config.Scripts) == 0 </span><span class="cov0" title="0">{
                fmt.Println("No scripts configured")
                return CommandResult{shouldRunService: false}, nil
        }</span>

        <span class="cov8" title="1">fmt.Printf("%-15s %-50s %-10s %-8s %-10s %-7s\n", "NAME", "PATH", "INTERVAL", "ENABLED", "MAX_LOGS", "TIMEOUT")
        fmt.Println(strings.Repeat("-", 100))

        for _, script := range config.Scripts </span><span class="cov8" title="1">{
                enabled := "false"
                if script.Enabled </span><span class="cov8" title="1">{
                        enabled = "true"
                }</span>

                <span class="cov8" title="1">timeout := "none"
                if script.Timeout &gt; 0 </span><span class="cov8" title="1">{
                        timeout = fmt.Sprintf("%ds", script.Timeout)
                }</span>

                <span class="cov8" title="1">fmt.Printf("%-15s %-50s %-10ds %-8s %-10d %-7s\n",
                        script.Name, script.Path, script.Interval, enabled, script.MaxLogLines, timeout)</span>
        }

        <span class="cov8" title="1">return CommandResult{shouldRunService: false}, nil</span>
}

// handleScriptToggle enables or disables a script
func handleScriptToggle(scriptName, configPath string, enable bool) (CommandResult, error) <span class="cov8" title="1">{
        var config service.ServiceConfig
        err := service.LoadServiceConfig(configPath, &amp;config)
        if err != nil </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, fmt.Errorf("failed to load config: %v", err)
        }</span>

        <span class="cov8" title="1">found := false
        for i, script := range config.Scripts </span><span class="cov8" title="1">{
                if script.Name == scriptName </span><span class="cov8" title="1">{
                        config.Scripts[i].Enabled = enable
                        found = true
                        break</span>
                }
        }

        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                return CommandResult{shouldRunService: false}, fmt.Errorf("script '%s' not found", scriptName)
        }</span>

        <span class="cov8" title="1">err = service.SaveServiceConfig(configPath, &amp;config)
        if err != nil </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, fmt.Errorf("failed to save config: %v", err)
        }</span>

        <span class="cov8" title="1">action := "disabled"
        if enable </span><span class="cov8" title="1">{
                action = "enabled"
        }</span>
        <span class="cov8" title="1">fmt.Printf("Script '%s' %s\n", scriptName, action)
        return CommandResult{shouldRunService: false}, nil</span>
}

// handleEnableScript enables a script
func handleEnableScript(scriptName, configPath string) (CommandResult, error) <span class="cov8" title="1">{
        return handleScriptToggle(scriptName, configPath, true)
}</span>

// handleDisableScript disables a script
func handleDisableScript(scriptName, configPath string) (CommandResult, error) <span class="cov8" title="1">{
        return handleScriptToggle(scriptName, configPath, false)
}</span>

// handleRemoveScript removes a script from configuration
func handleRemoveScript(scriptName, configPath string) (CommandResult, error) <span class="cov8" title="1">{
        var config service.ServiceConfig
        err := service.LoadServiceConfig(configPath, &amp;config)
        if err != nil </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, fmt.Errorf("failed to load config: %v", err)
        }</span>

        <span class="cov8" title="1">found := false
        newScripts := make([]service.ScriptConfig, 0, len(config.Scripts))
        for _, script := range config.Scripts </span><span class="cov8" title="1">{
                if script.Name != scriptName </span><span class="cov8" title="1">{
                        newScripts = append(newScripts, script)
                }</span> else<span class="cov8" title="1"> {
                        found = true
                }</span>
        }

        <span class="cov8" title="1">if !found </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, fmt.Errorf("script '%s' not found", scriptName)
        }</span>

        <span class="cov8" title="1">config.Scripts = newScripts

        err = service.SaveServiceConfig(configPath, &amp;config)
        if err != nil </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, fmt.Errorf("failed to save config: %v", err)
        }</span>

        <span class="cov8" title="1">fmt.Printf("Script '%s' removed\n", scriptName)
        return CommandResult{shouldRunService: false}, nil</span>
}

// handleRunScript executes a script once
func handleRunScript(scriptName, configPath string) (CommandResult, error) <span class="cov8" title="1">{
        var config service.ServiceConfig
        err := service.LoadServiceConfig(configPath, &amp;config)
        if err != nil </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, fmt.Errorf("failed to load config: %v", err)
        }</span>

        <span class="cov8" title="1">var scriptConfig *service.ScriptConfig
        for i, script := range config.Scripts </span><span class="cov8" title="1">{
                if script.Name == scriptName </span><span class="cov8" title="1">{
                        scriptConfig = &amp;config.Scripts[i]
                        break</span>
                }
        }

        <span class="cov8" title="1">if scriptConfig == nil </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, fmt.Errorf("script '%s' not found", scriptName)
        }</span>

        // Create a temporary script runner and execute once
        <span class="cov8" title="1">logPath := fmt.Sprintf("%s.log", scriptName)
        runner := service.NewScriptRunner(*scriptConfig, logPath)

        ctx := context.Background()
        err = runner.RunOnce(ctx)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Script '%s' execution failed: %v\n", scriptName, err)
        }</span> else<span class="cov8" title="1"> {
                fmt.Printf("Script '%s' executed successfully\n", scriptName)
        }</span>

        <span class="cov8" title="1">return CommandResult{shouldRunService: false}, nil</span>
}

// handleLogs displays logs for scripts
func handleLogs(args []string, _ string) (CommandResult, error) <span class="cov8" title="1">{
        flags, err := parseLogFlags(args)
        if err != nil </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, err
        }</span>

        // Determine logs directory path
        <span class="cov8" title="1">dir, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                dir, _ = os.Getwd()
        }</span> else<span class="cov8" title="1"> {
                dir = filepath.Dir(dir)
        }</span>
        <span class="cov8" title="1">logsDir := filepath.Join(dir, "logs")

        // Create log manager
        logManager := service.NewLogManager(logsDir)

        // Build query
        query := &amp;service.LogQuery{}

        if scriptName, ok := flags["script"]; ok </span><span class="cov8" title="1">{
                query.ScriptName = scriptName
        }</span>

        <span class="cov8" title="1">if exitCode, ok := flags["exit-code"]; ok </span><span class="cov8" title="1">{
                code, parseErr := strconv.Atoi(exitCode)
                if parseErr != nil </span><span class="cov0" title="0">{
                        return CommandResult{shouldRunService: false}, fmt.Errorf("invalid exit-code: %v", parseErr)
                }</span>
                <span class="cov8" title="1">query.ExitCode = &amp;code</span>
        }

        <span class="cov8" title="1">if limit, ok := flags["limit"]; ok </span><span class="cov8" title="1">{
                limitNum, parseErr := strconv.Atoi(limit)
                if parseErr != nil </span><span class="cov0" title="0">{
                        return CommandResult{shouldRunService: false}, fmt.Errorf("invalid limit: %v", parseErr)
                }</span>
                <span class="cov8" title="1">query.Limit = limitNum</span>
        }

        // Query logs
        <span class="cov8" title="1">entries, err := logManager.QueryLogs(query)
        if err != nil </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, fmt.Errorf("failed to query logs: %v", err)
        }</span>

        // Display logs
        <span class="cov8" title="1">if len(entries) == 0 </span><span class="cov8" title="1">{
                fmt.Println("No log entries found")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Found %d log entries:\n\n", len(entries))
                for _, entry := range entries </span><span class="cov0" title="0">{
                        fmt.Printf("[%s] %s (exit: %d, duration: %dms)\n",
                                entry.Timestamp.Format("2006-01-02 15:04:05"),
                                entry.ScriptName,
                                entry.ExitCode,
                                entry.Duration)
                        if entry.Stdout != "" </span><span class="cov0" title="0">{
                                fmt.Printf("  STDOUT: %s\n", entry.Stdout)
                        }</span>
                        <span class="cov0" title="0">if entry.Stderr != "" </span><span class="cov0" title="0">{
                                fmt.Printf("  STDERR: %s\n", entry.Stderr)
                        }</span>
                        <span class="cov0" title="0">fmt.Println()</span>
                }
        }

        <span class="cov8" title="1">return CommandResult{shouldRunService: false}, nil</span>
}

// handleClearLogs clears logs for a specific script
func handleClearLogs(args []string, _ string) (CommandResult, error) <span class="cov8" title="1">{
        flags, err := parseLogFlags(args)
        if err != nil </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, err
        }</span>

        <span class="cov8" title="1">scriptName, ok := flags["script"]
        if !ok </span><span class="cov8" title="1">{
                return CommandResult{shouldRunService: false},
                        fmt.Errorf("usage: ./run-script-service clear-logs --script=&lt;script-name&gt;")
        }</span>

        // Determine logs directory path
        <span class="cov8" title="1">dir, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                dir, _ = os.Getwd()
        }</span> else<span class="cov8" title="1"> {
                dir = filepath.Dir(dir)
        }</span>
        <span class="cov8" title="1">logsDir := filepath.Join(dir, "logs")

        // Clear the specific log file
        logFile := filepath.Join(logsDir, fmt.Sprintf("%s.log", scriptName))

        if _, statErr := os.Stat(logFile); os.IsNotExist(statErr) </span><span class="cov8" title="1">{
                fmt.Printf("No log file found for script '%s'\n", scriptName)
                return CommandResult{shouldRunService: false}, nil
        }</span>

        <span class="cov0" title="0">err = os.Remove(logFile)
        if err != nil </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, fmt.Errorf("failed to clear logs: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Logs cleared for script '%s'\n", scriptName)
        return CommandResult{shouldRunService: false}, nil</span>
}

// parseLogFlags parses log command flags
func parseLogFlags(args []string) (map[string]string, error) <span class="cov8" title="1">{
        flags := make(map[string]string)

        for _, arg := range args </span><span class="cov8" title="1">{
                if arg == "--all" </span><span class="cov8" title="1">{
                        // --all is equivalent to no script filter
                        continue</span>
                }

                <span class="cov8" title="1">if strings.HasPrefix(arg, "--") </span><span class="cov8" title="1">{
                        parts := strings.SplitN(arg[2:], "=", 2)
                        if len(parts) == 2 </span><span class="cov8" title="1">{
                                flags[parts[0]] = parts[1]
                        }</span> else<span class="cov0" title="0"> {
                                return nil, fmt.Errorf("invalid flag format: %s (expected --key=value)", arg)
                        }</span>
                } else<span class="cov8" title="1"> {
                        return nil, fmt.Errorf("invalid argument: %s", arg)
                }</span>
        }

        <span class="cov8" title="1">return flags, nil</span>
}

// handleSetWebPort sets the web server port
func handleSetWebPort(portStr, configPath string) (CommandResult, error) <span class="cov8" title="1">{
        port, err := strconv.Atoi(portStr)
        if err != nil </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, fmt.Errorf("invalid port number: %v", err)
        }</span>

        <span class="cov8" title="1">if port &lt; 1 || port &gt; 65535 </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, fmt.Errorf("port must be between 1 and 65535")
        }</span>

        // Load existing configuration
        <span class="cov8" title="1">var config service.ServiceConfig
        err = service.LoadServiceConfig(configPath, &amp;config)
        if err != nil </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, fmt.Errorf("failed to load config: %v", err)
        }</span>

        // Update web port
        <span class="cov8" title="1">config.WebPort = port

        // Save configuration
        err = service.SaveServiceConfig(configPath, &amp;config)
        if err != nil </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, fmt.Errorf("failed to save config: %v", err)
        }</span>

        <span class="cov8" title="1">fmt.Printf("Web port set to %d\n", port)
        return CommandResult{shouldRunService: false}, nil</span>
}

// runMultiScriptServiceWithWeb runs the service with web interface
func runMultiScriptServiceWithWeb(configPath string) <span class="cov0" title="0">{
        // Load enhanced configuration with .env file support
        envPath := ".env"
        enhancedConfig, err := loadEnhancedConfig(configPath, envPath)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to load config: %v\n", err)
                os.Exit(1)
        }</span>

        // Get current directory for file operations
        <span class="cov0" title="0">dir, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                dir, _ = os.Getwd()
        }</span> else<span class="cov0" title="0"> {
                dir = filepath.Dir(dir)
        }</span>

        // Create file manager for secure file operations
        <span class="cov0" title="0">fileManager := service.NewFileManager(dir)

        // Create script file manager for inline script management
        scriptFileManager := service.NewScriptFileManager(dir)

        // Create script manager
        scriptManager := service.NewScriptManagerWithPath(&amp;enhancedConfig.Config, configPath)

        // Create system monitor
        systemMonitor := service.NewSystemMonitor()

        // Get secret key from enhanced configuration (supports .env files)
        secretKey := enhancedConfig.GetSecretKey()
        if secretKey == "" </span><span class="cov0" title="0">{
                // Generate a random secret key and warn about it
                secretKey = generateRandomKey()
                fmt.Printf("WARNING: No WEB_SECRET_KEY environment variable set!\n")
                fmt.Printf("Generated random secret key: %s\n", secretKey)
                fmt.Printf("Set WEB_SECRET_KEY environment variable or add to .env file to use a persistent key.\n")
                fmt.Printf("For production, use: export WEB_SECRET_KEY=your-secure-secret-here\n")
                fmt.Printf("Or create .env file with: WEB_SECRET_KEY=your-secure-secret-here\n\n")
        }</span>

        // Create web server (simplified, no LogManager dependency)
        <span class="cov0" title="0">webPort := enhancedConfig.GetWebPort()
        webServer := web.NewWebServer(nil, webPort, secretKey)
        webServer.SetScriptManager(scriptManager)
        webServer.SetFileManager(fileManager)
        webServer.SetScriptFileManager(scriptFileManager)
        webServer.SetSystemMonitor(systemMonitor)

        // Set up signal handling
        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGTERM, syscall.SIGINT)

        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        // Start all enabled scripts
        err = scriptManager.StartAllEnabled(ctx)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to start scripts: %v\n", err)
                cancel()
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Println("Multi-script service with web interface started")
        fmt.Printf("Running scripts: %v\n", scriptManager.GetRunningScripts())
        fmt.Printf("Web interface available at http://localhost:%d\n", webPort)

        // Start system metrics broadcasting (every 30 seconds)
        err = webServer.StartSystemMetricsBroadcasting(ctx, 30*time.Second)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to start system metrics broadcasting: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("System metrics broadcasting started")
        }</span>

        // Start web server in goroutine
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                if err := webServer.Start(); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Web server failed: %v\n", err)
                        cancel()
                }</span>
        }()

        // Wait for shutdown signal
        <span class="cov0" title="0">&lt;-sigChan
        fmt.Println("Received shutdown signal")

        // Stop all scripts and web server
        scriptManager.StopAll()
        cancel()

        fmt.Println("Service stopped")</span>
}

// validateWebServiceSetup validates that web service can be properly initialized
// Returns true if all required components can be created and configured properly
func validateWebServiceSetup(configPath string) bool <span class="cov8" title="1">{
        // Load enhanced configuration with .env file support
        envPath := ".env"
        enhancedConfig, err := loadEnhancedConfig(configPath, envPath)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Validate that required components can be created
        <span class="cov8" title="1">if enhancedConfig == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Validate configuration structure
        <span class="cov8" title="1">if err := validateServiceConfig(&amp;enhancedConfig.Config); err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Validate web port configuration
        <span class="cov8" title="1">webPort := enhancedConfig.GetWebPort()
        if webPort &lt;= 0 || webPort &gt; 65535 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}

// validateServiceConfig validates the service configuration structure
func validateServiceConfig(config *service.ServiceConfig) error <span class="cov8" title="1">{
        if config == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("config cannot be nil")
        }</span>

        // Validate scripts configuration
        <span class="cov8" title="1">for _, script := range config.Scripts </span><span class="cov8" title="1">{
                if script.Name == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("script name cannot be empty")
                }</span>
                <span class="cov8" title="1">if script.Path == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("script path cannot be empty")
                }</span>
                <span class="cov8" title="1">if script.Interval &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("script interval must be positive")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// PID file management functions
func getPidFilePath() string <span class="cov8" title="1">{
        dir, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                dir, _ = os.Getwd()
        }</span> else<span class="cov8" title="1"> {
                dir = filepath.Dir(dir)
        }</span>
        <span class="cov8" title="1">return filepath.Join(dir, "run-script-service.pid")</span>
}

func writePidFile(pid int) error <span class="cov8" title="1">{
        pidFile := getPidFilePath()
        return os.WriteFile(pidFile, []byte(fmt.Sprintf("%d", pid)), 0644)
}</span>

func readPidFile() (int, error) <span class="cov8" title="1">{
        pidFile := getPidFilePath()
        data, err := os.ReadFile(pidFile)
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>
        <span class="cov8" title="1">return strconv.Atoi(strings.TrimSpace(string(data)))</span>
}

func removePidFile() error <span class="cov8" title="1">{
        pidFile := getPidFilePath()
        return os.Remove(pidFile)
}</span>

func isProcessRunning(pid int) bool <span class="cov8" title="1">{
        process, err := os.FindProcess(pid)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">err = process.Signal(syscall.Signal(0))
        return err == nil</span>
}

// handleDaemonCommand handles daemon subcommands (start/stop/status/restart/logs)
func handleDaemonCommand(subCommand, configPath string) (CommandResult, error) <span class="cov8" title="1">{
        switch subCommand </span>{
        case "start":<span class="cov8" title="1">
                return handleDaemonStart(configPath)</span>
        case "stop":<span class="cov8" title="1">
                return handleDaemonStop()</span>
        case "status":<span class="cov8" title="1">
                return handleDaemonStatus()</span>
        case "restart":<span class="cov8" title="1">
                return handleDaemonRestart(configPath)</span>
        case "logs":<span class="cov8" title="1">
                return handleDaemonLogs()</span>
        default:<span class="cov8" title="1">
                return CommandResult{shouldRunService: false},
                        fmt.Errorf("unknown daemon subcommand: %s\navailable subcommands: start, stop, status, restart, logs", subCommand)</span>
        }
}

// handleDaemonStart starts the service as a background daemon
func handleDaemonStart(configPath string) (CommandResult, error) <span class="cov8" title="1">{
        // Check if already running
        if pid, err := readPidFile(); err == nil &amp;&amp; isProcessRunning(pid) </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false},
                        fmt.Errorf("service is already running (PID: %d)", pid)
        }</span>

        // Get executable path
        <span class="cov8" title="1">execPath, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false},
                        fmt.Errorf("failed to get executable path: %v", err)
        }</span>

        // Get working directory
        <span class="cov8" title="1">workDir := filepath.Dir(execPath)

        // Auto-build frontend if needed
        if err := ensureFrontendBuilt(workDir); err != nil </span><span class="cov8" title="1">{
                fmt.Printf("Warning: Frontend build failed: %v\n", err)
                fmt.Println("Continuing with existing build...")
        }</span>

        // Create log file for daemon output
        <span class="cov8" title="1">logFile := filepath.Join(workDir, "daemon.log")
        file, err := os.OpenFile(logFile, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false},
                        fmt.Errorf("failed to create log file: %v", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // Start the daemon process
        cmd := exec.Command(execPath, "run")
        cmd.Dir = workDir
        cmd.Stdout = file
        cmd.Stderr = file
        cmd.SysProcAttr = &amp;syscall.SysProcAttr{
                Setsid: true, // Create new session
        }

        err = cmd.Start()
        if err != nil </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false},
                        fmt.Errorf("failed to start daemon: %v", err)
        }</span>

        // Write PID file
        <span class="cov8" title="1">err = writePidFile(cmd.Process.Pid)
        if err != nil </span><span class="cov0" title="0">{
                cmd.Process.Kill()
                return CommandResult{shouldRunService: false},
                        fmt.Errorf("failed to write PID file: %v", err)
        }</span>

        <span class="cov8" title="1">fmt.Printf("Service started successfully (PID: %d)\n", cmd.Process.Pid)
        fmt.Printf("Web interface available at http://localhost:8080\n")
        fmt.Printf("Logs: %s\n", logFile)

        return CommandResult{shouldRunService: false}, nil</span>
}

// handleDaemonStop stops the running daemon
func handleDaemonStop() (CommandResult, error) <span class="cov8" title="1">{
        pid, err := readPidFile()
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return CommandResult{shouldRunService: false}, fmt.Errorf("service is not running")
                }</span>
                <span class="cov0" title="0">return CommandResult{shouldRunService: false}, fmt.Errorf("failed to read PID file: %v", err)</span>
        }

        <span class="cov8" title="1">if !isProcessRunning(pid) </span><span class="cov0" title="0">{
                removePidFile()
                return CommandResult{shouldRunService: false}, fmt.Errorf("service is not running")
        }</span>

        <span class="cov8" title="1">process, err := os.FindProcess(pid)
        if err != nil </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, fmt.Errorf("failed to find process: %v", err)
        }</span>

        // Send SIGTERM for graceful shutdown
        <span class="cov8" title="1">err = process.Signal(syscall.SIGTERM)
        if err != nil </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, fmt.Errorf("failed to stop service: %v", err)
        }</span>

        // Wait a bit for graceful shutdown
        <span class="cov8" title="1">time.Sleep(2 * time.Second)

        // Check if still running, force kill if necessary
        if isProcessRunning(pid) </span><span class="cov8" title="1">{
                err = process.Kill()
                if err != nil </span><span class="cov0" title="0">{
                        return CommandResult{shouldRunService: false}, fmt.Errorf("failed to force kill service: %v", err)
                }</span>
                <span class="cov8" title="1">fmt.Println("Service force killed")</span>
        } else<span class="cov0" title="0"> {
                fmt.Println("Service stopped gracefully")
        }</span>

        // Remove PID file
        <span class="cov8" title="1">removePidFile()

        return CommandResult{shouldRunService: false}, nil</span>
}

// handleDaemonStatus shows the status of the daemon
func handleDaemonStatus() (CommandResult, error) <span class="cov8" title="1">{
        pid, err := readPidFile()
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        fmt.Println("Service is not running")
                        return CommandResult{shouldRunService: false}, nil
                }</span>
                <span class="cov0" title="0">return CommandResult{shouldRunService: false}, fmt.Errorf("failed to read PID file: %v", err)</span>
        }

        <span class="cov0" title="0">if isProcessRunning(pid) </span><span class="cov0" title="0">{
                fmt.Printf("Service is running (PID: %d)\n", pid)
                fmt.Println("Web interface: http://localhost:8080")
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("Service is not running (stale PID file)")
                removePidFile()
        }</span>

        <span class="cov0" title="0">return CommandResult{shouldRunService: false}, nil</span>
}

// handleDaemonRestart restarts the daemon
func handleDaemonRestart(configPath string) (CommandResult, error) <span class="cov8" title="1">{
        // Stop if running
        _, err := handleDaemonStop()
        if err != nil &amp;&amp; !strings.Contains(err.Error(), "not running") </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, err
        }</span>

        // Wait a moment
        <span class="cov8" title="1">time.Sleep(1 * time.Second)

        // Start again
        return handleDaemonStart(configPath)</span>
}

// handleDaemonLogs shows the daemon service logs
func handleDaemonLogs() (CommandResult, error) <span class="cov8" title="1">{
        dir, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                dir, _ = os.Getwd()
        }</span> else<span class="cov8" title="1"> {
                dir = filepath.Dir(dir)
        }</span>

        <span class="cov8" title="1">logFile := filepath.Join(dir, "daemon.log")

        // Check if log file exists
        if _, err := os.Stat(logFile); os.IsNotExist(err) </span><span class="cov0" title="0">{
                fmt.Println("No daemon logs found. Start the service first with: ./run-script-service daemon start")
                return CommandResult{shouldRunService: false}, nil
        }</span>

        // Read and display the log file
        <span class="cov8" title="1">content, err := os.ReadFile(logFile)
        if err != nil </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, fmt.Errorf("failed to read daemon logs: %v", err)
        }</span>

        <span class="cov8" title="1">if len(content) == 0 </span><span class="cov8" title="1">{
                fmt.Println("Daemon log file is empty")
        }</span> else<span class="cov0" title="0"> {
                fmt.Print(string(content))
        }</span>

        <span class="cov8" title="1">return CommandResult{shouldRunService: false}, nil</span>
}

// ensureFrontendBuilt checks if frontend needs building and builds it if necessary
func ensureFrontendBuilt(workDir string) error <span class="cov8" title="1">{
        frontendDir := filepath.Join(workDir, "web", "frontend")
        distDir := filepath.Join(frontendDir, "dist")

        // Check if frontend project exists
        if _, err := os.Stat(filepath.Join(frontendDir, "package.json")); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return fmt.Errorf("frontend project not found at %s", frontendDir)
        }</span>

        // Check if dist directory exists and has files
        <span class="cov0" title="0">if info, err := os.Stat(distDir); os.IsNotExist(err) || !info.IsDir() </span><span class="cov0" title="0">{
                fmt.Println("Frontend dist directory not found, building frontend...")
                return buildFrontend(frontendDir)
        }</span>

        // Check if dist directory is empty
        <span class="cov0" title="0">files, err := os.ReadDir(distDir)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read dist directory: %v", err)
        }</span>

        <span class="cov0" title="0">if len(files) == 0 </span><span class="cov0" title="0">{
                fmt.Println("Frontend dist directory is empty, building frontend...")
                return buildFrontend(frontendDir)
        }</span>

        // Check if package.json is newer than dist (basic staleness check)
        <span class="cov0" title="0">packageJsonPath := filepath.Join(frontendDir, "package.json")
        packageInfo, err := os.Stat(packageJsonPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to stat package.json: %v", err)
        }</span>

        <span class="cov0" title="0">distInfo, err := os.Stat(distDir)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to stat dist directory: %v", err)
        }</span>

        <span class="cov0" title="0">if packageInfo.ModTime().After(distInfo.ModTime()) </span><span class="cov0" title="0">{
                fmt.Println("Frontend source appears newer than build, rebuilding frontend...")
                return buildFrontend(frontendDir)
        }</span>

        <span class="cov0" title="0">fmt.Println("Frontend build appears up to date")
        return nil</span>
}

// buildFrontend builds the frontend using pnpm/vite
func buildFrontend(frontendDir string) error <span class="cov0" title="0">{
        fmt.Printf("Building frontend in %s...\n", frontendDir)

        // Check if node_modules exists, install dependencies if not
        nodeModulesDir := filepath.Join(frontendDir, "node_modules")
        if _, err := os.Stat(nodeModulesDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                fmt.Println("Installing frontend dependencies...")
                if err := runCommand("pnpm", []string{"install"}, frontendDir); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("pnpm install failed: %v", err)
                }</span>
        }

        // Run the build command
        <span class="cov0" title="0">fmt.Println("Running frontend build...")
        if err := runCommand("pnpm", []string{"build"}, frontendDir); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("pnpm build failed: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("Frontend build completed successfully")
        return nil</span>
}

// runCommand executes a command in the specified directory
func runCommand(command string, args []string, workingDir string) error <span class="cov8" title="1">{
        cmd := exec.Command(command, args...)
        cmd.Dir = workingDir
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr

        return cmd.Run()
}</span>

// loadEnhancedConfig loads configuration with .env file support
func loadEnhancedConfig(configPath, envPath string) (*service.EnhancedConfig, error) <span class="cov8" title="1">{
        config := service.NewEnhancedConfig()
        err := config.LoadWithEnv(configPath, envPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return config, nil</span>
}

// generateRandomKey generates a cryptographically secure random key
func generateRandomKey() string <span class="cov8" title="1">{
        bytes := make([]byte, 32) // 256-bit key
        _, err := rand.Read(bytes)
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to time-based key if crypto/rand fails
                return fmt.Sprintf("fallback-key-%d", time.Now().UnixNano())
        }</span>
        <span class="cov8" title="1">return hex.EncodeToString(bytes)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Package mocks provides mock implementations for testing purposes.
package mocks

import (
        "os"
        "time"
)

// FileSystem interface abstracts file system operations for testing
type FileSystem interface {
        WriteFile(filename string, data []byte, perm os.FileMode) error
        ReadFile(filename string) ([]byte, error)
        OpenFile(name string, flag int, perm os.FileMode) (*os.File, error)
        Stat(name string) (os.FileInfo, error)
}

// MockFileSystem provides a mock implementation for testing
type MockFileSystem struct {
        Files         map[string][]byte
        WriteFileFunc func(filename string, data []byte, perm os.FileMode) error
        ReadFileFunc  func(filename string) ([]byte, error)
        StatFunc      func(name string) (os.FileInfo, error)
}

// NewMockFileSystem creates a new mock file system for testing.
func NewMockFileSystem() *MockFileSystem <span class="cov0" title="0">{
        return &amp;MockFileSystem{
                Files: make(map[string][]byte),
        }
}</span>

// WriteFile implements the FileSystem interface for mock testing.
func (m *MockFileSystem) WriteFile(filename string, data []byte, perm os.FileMode) error <span class="cov0" title="0">{
        if m.WriteFileFunc != nil </span><span class="cov0" title="0">{
                return m.WriteFileFunc(filename, data, perm)
        }</span>
        <span class="cov0" title="0">m.Files[filename] = data
        return nil</span>
}

// ReadFile implements the FileSystem interface for mock testing.
func (m *MockFileSystem) ReadFile(filename string) ([]byte, error) <span class="cov0" title="0">{
        if m.ReadFileFunc != nil </span><span class="cov0" title="0">{
                return m.ReadFileFunc(filename)
        }</span>
        <span class="cov0" title="0">if data, exists := m.Files[filename]; exists </span><span class="cov0" title="0">{
                return data, nil
        }</span>
        <span class="cov0" title="0">return nil, os.ErrNotExist</span>
}

// OpenFile implements the FileSystem interface for mock testing.
func (m *MockFileSystem) OpenFile(name string, flag int, perm os.FileMode) (*os.File, error) <span class="cov0" title="0">{
        // For simplicity, this mock doesn't implement OpenFile
        return nil, os.ErrNotExist
}</span>

// Stat implements the FileSystem interface for mock testing.
func (m *MockFileSystem) Stat(name string) (os.FileInfo, error) <span class="cov0" title="0">{
        if m.StatFunc != nil </span><span class="cov0" title="0">{
                return m.StatFunc(name)
        }</span>
        <span class="cov0" title="0">if _, exists := m.Files[name]; exists </span><span class="cov0" title="0">{
                return &amp;mockFileInfo{name: name}, nil
        }</span>
        <span class="cov0" title="0">return nil, os.ErrNotExist</span>
}

type mockFileInfo struct {
        name string
}

func (m *mockFileInfo) Name() string       <span class="cov0" title="0">{ return m.name }</span>
func (m *mockFileInfo) Size() int64        <span class="cov0" title="0">{ return 0 }</span>
func (m *mockFileInfo) Mode() os.FileMode  <span class="cov0" title="0">{ return 0644 }</span>
func (m *mockFileInfo) ModTime() time.Time <span class="cov0" title="0">{ return time.Time{} }</span>
func (m *mockFileInfo) IsDir() bool        <span class="cov0" title="0">{ return false }</span>
func (m *mockFileInfo) Sys() interface{}   <span class="cov0" title="0">{ return nil }</span>

// TimeProvider interface abstracts time operations for testing
type TimeProvider interface {
        Now() time.Time
        Sleep(d time.Duration)
        After(d time.Duration) &lt;-chan time.Time
}

// MockTime provides a mock implementation for testing
type MockTime struct {
        fixedTime *time.Time
}

// NewMockTime creates a new mock time provider for testing.
func NewMockTime() *MockTime <span class="cov8" title="1">{
        return &amp;MockTime{}
}</span>

// SetFixedTime sets a fixed time for testing purposes.
func (m *MockTime) SetFixedTime(t time.Time) <span class="cov8" title="1">{
        m.fixedTime = &amp;t
}</span>

// Now implements the TimeProvider interface for mock testing.
func (m *MockTime) Now() time.Time <span class="cov8" title="1">{
        if m.fixedTime != nil </span><span class="cov8" title="1">{
                return *m.fixedTime
        }</span>
        <span class="cov8" title="1">return time.Now()</span>
}

// Sleep implements the TimeProvider interface for mock testing.
func (m *MockTime) Sleep(d time.Duration) {<span class="cov8" title="1">
        // In mock, sleep is instant (don't actually sleep)
}</span>

// After implements the TimeProvider interface for mock testing.
func (m *MockTime) After(d time.Duration) &lt;-chan time.Time <span class="cov8" title="1">{
        // In mock, return a channel that receives immediately
        ch := make(chan time.Time, 1)
        ch &lt;- time.Now()
        return ch
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Package service provides core functionality for the run-script-service daemon.
package service

import (
        "encoding/json"
        "fmt"
        "log"
        "os"
        "path/filepath"
        "strconv"
)

// ScriptConfig represents configuration for a single script
type ScriptConfig struct {
        Name        string `json:"name"`
        Filename    string `json:"filename,omitempty"` // For inline script management
        Path        string `json:"path"`
        Interval    int    `json:"interval"` // seconds
        Enabled     bool   `json:"enabled"`
        MaxLogLines int    `json:"max_log_lines"`
        Timeout     int    `json:"timeout"` // seconds, 0 means no limit
}

// UpdateResponse represents the detailed response for script updates
type UpdateResponse struct {
        Success       bool               `json:"success"`
        Message       string             `json:"message"`
        Applied       bool               `json:"applied"`
        Scheduled     bool               `json:"scheduled"`
        Changes       []ConfigChangeInfo `json:"changes"`
        NextExecution *string            `json:"next_execution,omitempty"`
}

// ConfigChangeInfo represents information about a specific configuration change
type ConfigChangeInfo struct {
        Field    string      `json:"field"`
        OldValue interface{} `json:"old_value"`
        NewValue interface{} `json:"new_value"`
        Applied  bool        `json:"applied"`
        Reason   string      `json:"reason,omitempty"`
}

// ConfigUpdateEvent represents a configuration update event for WebSocket broadcasting
type ConfigUpdateEvent struct {
        Type       string             `json:"type"` // "config_update"
        ScriptName string             `json:"script_name"`
        Status     string             `json:"status"` // "applied", "scheduled", "failed"
        Changes    []ConfigChangeInfo `json:"changes"`
        Applied    bool               `json:"applied"`
        Scheduled  bool               `json:"scheduled"`
        Message    string             `json:"message"`
        Timestamp  string             `json:"timestamp"`
}

// ServiceConfig represents the overall service configuration
type ServiceConfig struct {
        Scripts []ScriptConfig `json:"scripts"`
        WebPort int            `json:"web_port"`
}

// Config is a legacy struct for backward compatibility
type Config struct {
        Interval int `json:"interval"`
}

// EnhancedConfig combines service configuration with environment variable loading
type EnhancedConfig struct {
        Config    ServiceConfig
        envLoader *EnvLoader
}

// Validate checks if the script configuration is valid
func (sc *ScriptConfig) Validate() error <span class="cov0" title="0">{
        return sc.ValidateWithOptions(true)
}</span>

// ValidateWithOptions checks if the script configuration is valid with optional file existence check
func (sc *ScriptConfig) ValidateWithOptions(checkFileExists bool) error <span class="cov8" title="1">{
        if sc.Name == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("script name cannot be empty")
        }</span>
        <span class="cov8" title="1">if sc.Path == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("script path cannot be empty")
        }</span>
        <span class="cov8" title="1">if sc.Interval &lt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("interval cannot be negative")
        }</span>
        <span class="cov8" title="1">if sc.MaxLogLines &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("max_log_lines cannot be negative")
        }</span>
        <span class="cov8" title="1">if sc.Timeout &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("timeout cannot be negative")
        }</span>

        // Optionally check if script file exists and is executable
        <span class="cov8" title="1">if checkFileExists </span><span class="cov0" title="0">{
                scriptPath := sc.Path
                if !filepath.IsAbs(scriptPath) </span><span class="cov0" title="0">{
                        // Convert relative path to absolute path
                        workDir, err := os.Getwd()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("unable to get working directory: %v", err)
                        }</span>
                        <span class="cov0" title="0">scriptPath = filepath.Join(workDir, sc.Path)</span>
                }

                <span class="cov0" title="0">info, err := os.Stat(scriptPath)
                if err != nil </span><span class="cov0" title="0">{
                        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                                return fmt.Errorf("script file does not exist: %s", sc.Path)
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("unable to access script file %s: %v", sc.Path, err)</span>
                }

                // Check if it's a regular file (not a directory)
                <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                        return fmt.Errorf("script path is a directory, not a file: %s", sc.Path)
                }</span>

                // Check if file is executable
                <span class="cov0" title="0">if info.Mode()&amp;0111 == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("script file is not executable: %s (mode: %v)", sc.Path, info.Mode())
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// LoadConfig loads configuration from the specified file path
func LoadConfig(configPath string, config *Config) error <span class="cov8" title="1">{
        if _, err := os.Stat(configPath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return nil // Keep default config
        }</span>

        <span class="cov8" title="1">data, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error reading config: %v", err)
                return nil // Keep default config, don't fail
        }</span>

        <span class="cov8" title="1">if err := json.Unmarshal(data, config); err != nil </span><span class="cov8" title="1">{
                log.Printf("Error parsing config: %v", err)
                return nil // Keep default config, don't fail
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// SaveConfig saves configuration to the specified file path
func SaveConfig(configPath string, config *Config) error <span class="cov8" title="1">{
        data, err := json.MarshalIndent(config, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error marshaling config: %v", err)
        }</span>

        <span class="cov8" title="1">if err := os.WriteFile(configPath, data, 0600); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error writing config: %v", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// LoadServiceConfig loads the new multi-script configuration with backward compatibility
func LoadServiceConfig(configPath string, config *ServiceConfig) error <span class="cov8" title="1">{
        if _, err := os.Stat(configPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil // Keep default config
        }</span>

        <span class="cov8" title="1">data, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error reading config: %v", err)
                return nil // Keep default config, don't fail
        }</span>

        // Try to parse as new format first
        <span class="cov8" title="1">var tempConfig ServiceConfig
        if err := json.Unmarshal(data, &amp;tempConfig); err == nil </span><span class="cov8" title="1">{
                // Check if it looks like new format (has "scripts" field or "web_port" field)
                var rawConfig map[string]interface{}
                if err := json.Unmarshal(data, &amp;rawConfig); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error parsing config as map: %v", err)
                }</span>

                <span class="cov8" title="1">if _, hasScripts := rawConfig["scripts"]; hasScripts || rawConfig["web_port"] != nil </span><span class="cov8" title="1">{
                        // Successfully parsed as new format
                        for i, script := range tempConfig.Scripts </span><span class="cov8" title="1">{
                                // Only validate basic fields during config loading, not file existence
                                if err := script.ValidateWithOptions(false); err != nil </span><span class="cov0" title="0">{
                                        log.Printf("Invalid script config %d: %v", i, err)
                                        return nil // Keep default config
                                }</span>
                        }
                        <span class="cov8" title="1">*config = tempConfig
                        return nil</span>
                }
        }

        // Try to parse as legacy format for backward compatibility
        <span class="cov8" title="1">var legacyConfig Config
        if err := json.Unmarshal(data, &amp;legacyConfig); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error parsing config: %v", err)
                return nil // Keep default config, don't fail
        }</span>

        // Convert legacy config to new format
        <span class="cov8" title="1">config.Scripts = []ScriptConfig{
                {
                        Name:        "main",
                        Path:        "./run.sh", // default script path
                        Interval:    legacyConfig.Interval,
                        Enabled:     true,
                        MaxLogLines: 100, // default
                        Timeout:     0,   // no timeout
                },
        }
        if config.WebPort == 0 </span><span class="cov0" title="0">{
                config.WebPort = 8080 // default
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// SaveServiceConfig saves the service configuration to file
func SaveServiceConfig(configPath string, config *ServiceConfig) error <span class="cov0" title="0">{
        data, err := json.MarshalIndent(config, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error marshaling config: %v", err)
        }</span>

        <span class="cov0" title="0">if err := os.WriteFile(configPath, data, 0600); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error writing config: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// NewEnhancedConfig creates a new enhanced configuration manager
func NewEnhancedConfig() *EnhancedConfig <span class="cov8" title="1">{
        return &amp;EnhancedConfig{
                Config: ServiceConfig{
                        Scripts: []ScriptConfig{},
                        WebPort: 8080, // default
                },
                envLoader: NewEnvLoader(),
        }
}</span>

// LoadWithEnv loads both service configuration and environment variables
func (ec *EnhancedConfig) LoadWithEnv(configPath, envPath string) error <span class="cov8" title="1">{
        // Load .env file first
        if err := ec.envLoader.LoadFromFile(envPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load env file: %v", err)
        }</span>

        // Load service configuration
        <span class="cov8" title="1">if err := LoadServiceConfig(configPath, &amp;ec.Config); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load service config: %v", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetEnv retrieves environment variable with .env file support
func (ec *EnhancedConfig) GetEnv(key string) string <span class="cov8" title="1">{
        return ec.envLoader.Get(key)
}</span>

// GetEnvWithDefault retrieves environment variable with default fallback
func (ec *EnhancedConfig) GetEnvWithDefault(key, defaultValue string) string <span class="cov0" title="0">{
        return ec.envLoader.GetWithDefault(key, defaultValue)
}</span>

// GetWebPort returns the web port, prioritizing environment variables
func (ec *EnhancedConfig) GetWebPort() int <span class="cov8" title="1">{
        // Check environment variable first
        if portStr := ec.GetEnv("WEB_PORT"); portStr != "" </span><span class="cov8" title="1">{
                if port, err := strconv.Atoi(portStr); err == nil </span><span class="cov8" title="1">{
                        return port
                }</span>
        }

        // Fallback to JSON config
        <span class="cov0" title="0">if ec.Config.WebPort &gt; 0 </span><span class="cov0" title="0">{
                return ec.Config.WebPort
        }</span>

        // Final fallback
        <span class="cov0" title="0">return 8080</span>
}

// GetSecretKey returns the secret key from environment variables
func (ec *EnhancedConfig) GetSecretKey() string <span class="cov0" title="0">{
        return ec.GetEnv("WEB_SECRET_KEY")
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package service

import (
        "fmt"
        "io"
        "os"
        "strings"
)

// DebugLogger provides conditional debug logging
type DebugLogger struct {
        enabled bool
        output  io.Writer
}

// NewDebugLogger creates a new debug logger
func NewDebugLogger() *DebugLogger <span class="cov8" title="1">{
        logger := &amp;DebugLogger{
                output: os.Stdout,
        }

        // Check environment variable for debug setting
        debugEnv := strings.ToLower(os.Getenv("DEBUG"))
        logger.enabled = debugEnv == "true" || debugEnv == "1"

        return logger
}</span>

// IsEnabled returns whether debug logging is enabled
func (d *DebugLogger) IsEnabled() bool <span class="cov8" title="1">{
        return d.enabled
}</span>

// Enable enables debug logging
func (d *DebugLogger) Enable() <span class="cov8" title="1">{
        d.enabled = true
}</span>

// Disable disables debug logging
func (d *DebugLogger) Disable() <span class="cov8" title="1">{
        d.enabled = false
}</span>

// SetOutput sets the output destination for debug messages
func (d *DebugLogger) SetOutput(w io.Writer) <span class="cov8" title="1">{
        d.output = w
}</span>

// Debugf prints a debug message if debugging is enabled
func (d *DebugLogger) Debugf(format string, args ...interface{}) <span class="cov8" title="1">{
        if !d.enabled </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">message := fmt.Sprintf(format, args...)
        fmt.Fprintln(d.output, message)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package service

import (
        "bufio"
        "os"
        "strings"
)

// EnvLoader handles loading environment variables from .env files
// with proper priority handling (environment variables &gt; .env file &gt; default)
type EnvLoader struct {
        values map[string]string
}

// NewEnvLoader creates a new environment variable loader
func NewEnvLoader() *EnvLoader <span class="cov8" title="1">{
        return &amp;EnvLoader{
                values: make(map[string]string),
        }
}</span>

// LoadFromFile loads environment variables from a .env file
// Environment variables take priority over file values
func (e *EnvLoader) LoadFromFile(filepath string) error <span class="cov8" title="1">{
        // File not existing is not an error - just continue with env vars only
        file, err := os.Open(filepath)
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov8" title="1">defer file.Close()

        scanner := bufio.NewScanner(file)
        for scanner.Scan() </span><span class="cov8" title="1">{
                line := strings.TrimSpace(scanner.Text())

                // Skip empty lines and comments
                if line == "" || strings.HasPrefix(line, "#") </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Parse key=value pairs
                <span class="cov8" title="1">parts := strings.SplitN(line, "=", 2)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">key := strings.TrimSpace(parts[0])
                value := strings.TrimSpace(parts[1])

                // Only set if not already set in environment
                if _, exists := e.values[key]; !exists </span><span class="cov8" title="1">{
                        e.values[key] = value
                }</span>
        }

        <span class="cov8" title="1">return scanner.Err()</span>
}

// Get retrieves a value, checking environment variables first, then .env file values
func (e *EnvLoader) Get(key string) string <span class="cov8" title="1">{
        // Check environment variables first (highest priority)
        if value := os.Getenv(key); value != "" </span><span class="cov8" title="1">{
                return value
        }</span>

        // Check .env file values
        <span class="cov8" title="1">if value, exists := e.values[key]; exists </span><span class="cov8" title="1">{
                return value
        }</span>

        <span class="cov8" title="1">return ""</span>
}

// GetWithDefault retrieves a value with a default fallback
func (e *EnvLoader) GetWithDefault(key, defaultValue string) string <span class="cov8" title="1">{
        if value := e.Get(key); value != "" </span><span class="cov8" title="1">{
                return value
        }</span>
        <span class="cov8" title="1">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package service

import (
        "sync"
        "time"
)

// ScriptStatusEvent represents a script status change event
type ScriptStatusEvent struct {
        ScriptName string    `json:"script_name"`
        Status     string    `json:"status"` // "starting", "running", "completed", "failed"
        ExitCode   int       `json:"exit_code"`
        Duration   int64     `json:"duration"` // Duration in milliseconds
        Timestamp  time.Time `json:"timestamp"`
}

// NewScriptStatusEvent creates a new script status event
func NewScriptStatusEvent(scriptName, status string, exitCode int, duration int64) *ScriptStatusEvent <span class="cov8" title="1">{
        return &amp;ScriptStatusEvent{
                ScriptName: scriptName,
                Status:     status,
                ExitCode:   exitCode,
                Duration:   duration,
                Timestamp:  time.Now(),
        }
}</span>

// ToJSON converts the event to a JSON-compatible map
func (e *ScriptStatusEvent) ToJSON() map[string]interface{} <span class="cov8" title="1">{
        return map[string]interface{}{
                "script_name": e.ScriptName,
                "status":      e.Status,
                "exit_code":   e.ExitCode,
                "duration":    e.Duration,
                "timestamp":   e.Timestamp.Format(time.RFC3339),
        }
}</span>

// EventBroadcaster manages event broadcasting to multiple listeners
type EventBroadcaster struct {
        listeners []chan&lt;- *ScriptStatusEvent
        mutex     sync.RWMutex
}

// NewEventBroadcaster creates a new event broadcaster
func NewEventBroadcaster() *EventBroadcaster <span class="cov8" title="1">{
        return &amp;EventBroadcaster{
                listeners: make([]chan&lt;- *ScriptStatusEvent, 0),
        }
}</span>

// Subscribe adds a listener to receive events
// Returns an unsubscribe function
func (eb *EventBroadcaster) Subscribe(eventChan chan&lt;- *ScriptStatusEvent) func() <span class="cov8" title="1">{
        eb.mutex.Lock()
        defer eb.mutex.Unlock()

        eb.listeners = append(eb.listeners, eventChan)

        // Return unsubscribe function
        return func() </span><span class="cov8" title="1">{
                eb.mutex.Lock()
                defer eb.mutex.Unlock()

                for i, listener := range eb.listeners </span><span class="cov8" title="1">{
                        if listener == eventChan </span><span class="cov8" title="1">{
                                // Remove this listener from the slice
                                eb.listeners = append(eb.listeners[:i], eb.listeners[i+1:]...)
                                break</span>
                        }
                }
        }
}

// Broadcast sends an event to all subscribers
// This is non-blocking - if a listener's channel is full, the event is dropped for that listener
func (eb *EventBroadcaster) Broadcast(event *ScriptStatusEvent) <span class="cov8" title="1">{
        eb.mutex.RLock()
        defer eb.mutex.RUnlock()

        for _, listener := range eb.listeners </span><span class="cov8" title="1">{
                select </span>{
                case listener &lt;- event:<span class="cov8" title="1"></span>
                        // Event sent successfully
                default:<span class="cov8" title="1"></span>
                        // Channel is full, drop the event for this listener
                }
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Package service provides core functionality for the run-script-service daemon.
package service

import (
        "bufio"
        "context"
        "fmt"
        "io"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
        "sync"
        "syscall"
        "time"
)

// ExecutionResult contains the results of script execution
type ExecutionResult struct {
        ExitCode  int
        Stdout    string
        Stderr    string
        Timestamp time.Time
}

// Executor handles script execution and logging
type Executor struct {
        scriptPath string
        logPath    string
        maxLines   int
        logHandler LogHandler
        timeout    time.Duration // timeout for script execution
}

// NewExecutor creates a new script executor
func NewExecutor(scriptPath, logPath string, maxLines int) *Executor <span class="cov8" title="1">{
        return &amp;Executor{
                scriptPath: scriptPath,
                logPath:    logPath,
                maxLines:   maxLines,
                timeout:    0, // no timeout by default
        }
}</span>

// NewExecutorWithTimeout creates a new script executor with timeout capability
func NewExecutorWithTimeout(scriptPath, logPath string, maxLines int, timeout time.Duration) *Executor <span class="cov8" title="1">{
        return &amp;Executor{
                scriptPath: scriptPath,
                logPath:    logPath,
                maxLines:   maxLines,
                timeout:    timeout,
        }
}</span>

// ExecuteScript executes the configured script and logs the results
func (e *Executor) ExecuteScript(args ...string) *ExecutionResult <span class="cov8" title="1">{
        // Use context with timeout for backward compatibility
        ctx := context.Background()
        return e.ExecuteScriptWithContext(ctx, args...)
}</span>

// ExecuteScriptWithContext executes the configured script with context support
func (e *Executor) ExecuteScriptWithContext(ctx context.Context, args ...string) *ExecutionResult <span class="cov8" title="1">{
        timestamp := time.Now()
        result := &amp;ExecutionResult{
                Timestamp: timestamp,
        }

        cmd := exec.CommandContext(ctx, e.scriptPath, args...)
        cmd.Dir = filepath.Dir(e.scriptPath)

        // Set process group to enable proper cleanup
        cmd.SysProcAttr = &amp;syscall.SysProcAttr{
                Setpgid: true,
        }

        stdout, err := cmd.StdoutPipe()
        if err != nil </span><span class="cov0" title="0">{
                e.logError(timestamp, fmt.Sprintf("Error creating stdout pipe: %v", err))
                result.ExitCode = -1
                return result
        }</span>

        <span class="cov8" title="1">stderr, err := cmd.StderrPipe()
        if err != nil </span><span class="cov0" title="0">{
                e.logError(timestamp, fmt.Sprintf("Error creating stderr pipe: %v", err))
                result.ExitCode = -1
                return result
        }</span>

        <span class="cov8" title="1">if startErr := cmd.Start(); startErr != nil </span><span class="cov8" title="1">{
                e.logError(timestamp, fmt.Sprintf("Error starting command: %v", startErr))
                result.ExitCode = -1
                return result
        }</span>

        // Ensure process cleanup on exit
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if cmd.Process != nil </span><span class="cov8" title="1">{
                        // Kill the entire process group to clean up any child processes
                        if pgid, err := syscall.Getpgid(cmd.Process.Pid); err == nil </span><span class="cov0" title="0">{
                                // Only kill if the process is still running and we can get the pgid
                                _ = syscall.Kill(-pgid, syscall.SIGTERM)

                                // Wait a moment for graceful shutdown, then force kill if needed
                                go func() </span><span class="cov0" title="0">{
                                        time.Sleep(100 * time.Millisecond)
                                        if cmd.ProcessState == nil || !cmd.ProcessState.Exited() </span><span class="cov0" title="0">{
                                                _ = syscall.Kill(-pgid, syscall.SIGKILL)
                                        }</span>
                                }()
                        }
                }
        }()

        <span class="cov8" title="1">stdoutBytes, _ := io.ReadAll(stdout)
        stderrBytes, _ := io.ReadAll(stderr)

        err = cmd.Wait()
        result.ExitCode = 0
        if err != nil </span><span class="cov8" title="1">{
                if exitError, ok := err.(*exec.ExitError); ok </span><span class="cov8" title="1">{
                        result.ExitCode = exitError.ExitCode()
                }</span> else<span class="cov0" title="0"> {
                        e.logError(timestamp, fmt.Sprintf("Error waiting for command: %v", err))
                        result.ExitCode = -1
                        return result
                }</span>
        }

        <span class="cov8" title="1">result.Stdout = strings.TrimSpace(string(stdoutBytes))
        result.Stderr = strings.TrimSpace(string(stderrBytes))

        // Write execution result to log
        e.writeExecutionLog(timestamp, result)

        return result</span>
}

// logError logs an error message
func (e *Executor) logError(timestamp time.Time, message string) <span class="cov8" title="1">{
        if e.logPath != "" </span><span class="cov8" title="1">{
                errorMsg := fmt.Sprintf("[%s] ERROR: %s\n%s\n",
                        timestamp.Format("2006-01-02 15:04:05"), message, strings.Repeat("-", 50))
                if err := e.WriteLog(errorMsg); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Error writing error to log: %v\n", err)
                }</span>
        }
        <span class="cov8" title="1">fmt.Printf("Error executing script: %s\n", message)</span>
}

// writeExecutionLog writes execution result to log file
func (e *Executor) writeExecutionLog(timestamp time.Time, result *ExecutionResult) <span class="cov8" title="1">{
        if e.logPath != "" </span><span class="cov8" title="1">{
                logEntry := fmt.Sprintf("[%s] Exit code: %d\n", timestamp.Format("2006-01-02 15:04:05"), result.ExitCode)
                if result.Stdout != "" </span><span class="cov8" title="1">{
                        logEntry += fmt.Sprintf("STDOUT: %s\n", result.Stdout)
                }</span>
                <span class="cov8" title="1">if result.Stderr != "" </span><span class="cov8" title="1">{
                        logEntry += fmt.Sprintf("STDERR: %s\n", result.Stderr)
                }</span>
                <span class="cov8" title="1">logEntry += strings.Repeat("-", 50) + "\n"

                if err := e.WriteLog(logEntry); err != nil </span><span class="cov8" title="1">{
                        fmt.Printf("Error writing to log: %v\n", err)
                }</span>

                <span class="cov8" title="1">if err := e.TrimLog(); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Error trimming log: %v\n", err)
                }</span>
        }
}

// WriteLog writes content to the log file
func (e *Executor) WriteLog(content string) error <span class="cov8" title="1">{
        file, err := os.OpenFile(e.logPath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0600)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        _, err = file.WriteString(content)
        return err</span>
}

// TrimLog keeps only the last maxLines lines in the log file
func (e *Executor) TrimLog() error <span class="cov8" title="1">{
        file, err := os.Open(e.logPath)
        if os.IsNotExist(err) </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        var lines []string
        scanner := bufio.NewScanner(file)
        for scanner.Scan() </span><span class="cov8" title="1">{
                lines = append(lines, scanner.Text())
        }</span>

        <span class="cov8" title="1">if scanErr := scanner.Err(); scanErr != nil </span><span class="cov0" title="0">{
                return scanErr
        }</span>

        <span class="cov8" title="1">if len(lines) &lt;= e.maxLines </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Keep only the last maxLines lines
        <span class="cov8" title="1">linesToKeep := lines[len(lines)-e.maxLines:]

        outFile, err := os.Create(e.logPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer outFile.Close()

        for _, line := range linesToKeep </span><span class="cov8" title="1">{
                if _, err := outFile.WriteString(line + "\n"); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ExecuteWithStreaming executes the script with streaming output
func (e *Executor) ExecuteWithStreaming(ctx context.Context, args ...string) *ExecutionResult <span class="cov8" title="1">{
        timestamp := time.Now()
        result := &amp;ExecutionResult{
                Timestamp: timestamp,
        }

        // Apply timeout if configured
        if e.timeout &gt; 0 </span><span class="cov8" title="1">{
                var cancel context.CancelFunc
                ctx, cancel = context.WithTimeout(ctx, e.timeout)
                defer cancel()
        }</span>

        // Notify handler of execution start
        <span class="cov8" title="1">if e.logHandler != nil </span><span class="cov8" title="1">{
                e.logHandler.HandleExecutionStart(timestamp)
        }</span>

        <span class="cov8" title="1">cmd := exec.CommandContext(ctx, e.scriptPath, args...)
        cmd.Dir = filepath.Dir(e.scriptPath)

        // Set process group to enable proper cleanup
        cmd.SysProcAttr = &amp;syscall.SysProcAttr{
                Setpgid: true,
        }

        stdout, err := cmd.StdoutPipe()
        if err != nil </span><span class="cov0" title="0">{
                e.logError(timestamp, fmt.Sprintf("Error creating stdout pipe: %v", err))
                result.ExitCode = -1
                if e.logHandler != nil </span><span class="cov0" title="0">{
                        e.logHandler.HandleExecutionEnd(timestamp, -1)
                }</span>
                <span class="cov0" title="0">return result</span>
        }

        <span class="cov8" title="1">stderr, err := cmd.StderrPipe()
        if err != nil </span><span class="cov0" title="0">{
                e.logError(timestamp, fmt.Sprintf("Error creating stderr pipe: %v", err))
                result.ExitCode = -1
                if e.logHandler != nil </span><span class="cov0" title="0">{
                        e.logHandler.HandleExecutionEnd(timestamp, -1)
                }</span>
                <span class="cov0" title="0">return result</span>
        }

        <span class="cov8" title="1">if startErr := cmd.Start(); startErr != nil </span><span class="cov0" title="0">{
                e.logError(timestamp, fmt.Sprintf("Error starting command: %v", startErr))
                result.ExitCode = -1
                if e.logHandler != nil </span><span class="cov0" title="0">{
                        e.logHandler.HandleExecutionEnd(timestamp, -1)
                }</span>
                <span class="cov0" title="0">return result</span>
        }

        // Ensure process cleanup on exit
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if cmd.Process != nil </span><span class="cov8" title="1">{
                        // Kill the entire process group to clean up any child processes
                        if pgid, err := syscall.Getpgid(cmd.Process.Pid); err == nil </span><span class="cov0" title="0">{
                                // Only kill if the process is still running and we can get the pgid
                                _ = syscall.Kill(-pgid, syscall.SIGTERM)

                                // Wait a moment for graceful shutdown, then force kill if needed
                                go func() </span><span class="cov0" title="0">{
                                        time.Sleep(100 * time.Millisecond)
                                        if cmd.ProcessState == nil || !cmd.ProcessState.Exited() </span><span class="cov0" title="0">{
                                                _ = syscall.Kill(-pgid, syscall.SIGKILL)
                                        }</span>
                                }()
                        }
                }
        }()

        // Stream output in real-time using goroutines
        <span class="cov8" title="1">var stdoutBuilder strings.Builder
        var stderrBuilder strings.Builder
        var wg sync.WaitGroup

        // Start streaming goroutines
        wg.Add(2)
        go func() </span><span class="cov8" title="1">{
                defer wg.Done()
                e.streamOutputToBuilder(stdout, "STDOUT", &amp;stdoutBuilder)
        }</span>()

        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                defer wg.Done()
                e.streamOutputToBuilder(stderr, "STDERR", &amp;stderrBuilder)
        }</span>()

        <span class="cov8" title="1">err = cmd.Wait()
        // Wait for all streaming to complete before proceeding
        wg.Wait()
        result.ExitCode = 0
        if err != nil </span><span class="cov8" title="1">{
                if exitError, ok := err.(*exec.ExitError); ok </span><span class="cov8" title="1">{
                        result.ExitCode = exitError.ExitCode()
                }</span> else<span class="cov0" title="0"> if err.Error() == "signal: killed" &amp;&amp; ctx.Err() == context.DeadlineExceeded </span><span class="cov0" title="0">{
                        // Handle timeout specifically
                        e.logError(timestamp, fmt.Sprintf("Script execution timed out after %v", e.timeout))
                        result.ExitCode = -1
                }</span> else<span class="cov0" title="0"> {
                        e.logError(timestamp, fmt.Sprintf("Error waiting for command: %v", err))
                        result.ExitCode = -1
                }</span>
        }

        <span class="cov8" title="1">result.Stdout = strings.TrimSpace(stdoutBuilder.String())
        result.Stderr = strings.TrimSpace(stderrBuilder.String())

        // Notify handler of execution end
        if e.logHandler != nil </span><span class="cov8" title="1">{
                e.logHandler.HandleExecutionEnd(time.Now(), result.ExitCode)
        }</span>

        // Write execution result to log
        <span class="cov8" title="1">e.writeExecutionLog(timestamp, result)

        return result</span>
}

// streamOutputToBuilder processes output from a reader line by line, calls the log handler, and builds output string
func (e *Executor) streamOutputToBuilder(reader io.Reader, streamType string, builder *strings.Builder) <span class="cov8" title="1">{
        scanner := bufio.NewScanner(reader)
        for scanner.Scan() </span><span class="cov8" title="1">{
                line := scanner.Text()
                timestamp := time.Now()

                // Add to builder for backward compatibility
                builder.WriteString(line + "\n")

                // Send to log handler if available
                if e.logHandler != nil </span><span class="cov8" title="1">{
                        e.logHandler.HandleLogLine(timestamp, streamType, line)
                }</span>
        }
}

// SetLogHandler sets the log handler for streaming output
func (e *Executor) SetLogHandler(handler LogHandler) <span class="cov8" title="1">{
        e.logHandler = handler
}</span>

// ExecuteWithResult executes the script and returns both result and error
// This method provides a simpler interface for script execution with error handling
func (e *Executor) ExecuteWithResult(ctx context.Context, args ...string) (*ExecutionResult, error) <span class="cov8" title="1">{
        ctx = e.ensureContext(ctx)
        result := e.ExecuteScriptWithContext(ctx, args...)
        return e.handleExecutionResult(result)
}</span>

// ExecuteWithResultStreaming executes the script with streaming output and returns both result and error
// This method combines streaming capabilities with error handling interface, allowing real-time
// output processing while maintaining the same error handling semantics as ExecuteWithResult
func (e *Executor) ExecuteWithResultStreaming(ctx context.Context, args ...string) (*ExecutionResult, error) <span class="cov8" title="1">{
        ctx = e.ensureContext(ctx)
        result := e.ExecuteWithStreaming(ctx, args...)
        return e.handleExecutionResult(result)
}</span>

// ensureContext ensures we have a valid context, using background context as fallback
func (e *Executor) ensureContext(ctx context.Context) context.Context <span class="cov8" title="1">{
        if ctx == nil </span><span class="cov8" title="1">{
                return context.Background()
        }</span>
        <span class="cov8" title="1">return ctx</span>
}

// handleExecutionResult converts execution results to the result/error pattern
// Non-zero exit codes are converted to errors while preserving the full result
func (e *Executor) handleExecutionResult(result *ExecutionResult) (*ExecutionResult, error) <span class="cov8" title="1">{
        if result.ExitCode != 0 </span><span class="cov8" title="1">{
                return result, fmt.Errorf("script execution failed with exit code %d", result.ExitCode)
        }</span>
        <span class="cov8" title="1">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Package service provides file management functionality
package service

import (
        "fmt"
        "io/fs"
        "os"
        "path/filepath"
        "strings"
)

// FileManager handles secure file operations
type FileManager struct {
        allowedPaths []string
        deniedPaths  []string
        baseDir      string
}

// FileContent represents file content with metadata
type FileContent struct {
        Path    string `json:"path"`
        Content string `json:"content"`
        Size    int64  `json:"size"`
        Mode    string `json:"mode"`
}

// NewFileManager creates a new file manager with security constraints
func NewFileManager(baseDir string) *FileManager <span class="cov8" title="1">{
        return &amp;FileManager{
                baseDir: baseDir,
                allowedPaths: []string{
                        ".",          // Current directory
                        "./scripts",  // Scripts directory
                        "./logs",     // Logs directory
                        "./testdata", // Test data directory
                },
                deniedPaths: []string{
                        "/etc",
                        "/usr",
                        "/bin",
                        "/sbin",
                        "/root",
                        "/home",
                        "/var",
                        "/tmp",
                        "/proc",
                        "/sys",
                },
        }
}</span>

// IsPathAllowed checks if a file path is allowed for access
func (fm *FileManager) IsPathAllowed(path string) bool <span class="cov8" title="1">{
        // Clean and resolve the path
        cleanPath := filepath.Clean(path)

        // Additional security checks
        if strings.Contains(cleanPath, "..") </span><span class="cov0" title="0">{
                return false // Path traversal attempt
        }</span>

        // Convert to absolute path for security checks
        <span class="cov8" title="1">var absPath string
        if filepath.IsAbs(cleanPath) </span><span class="cov8" title="1">{
                absPath = cleanPath

                // Check denied paths first for absolute paths
                for _, denied := range fm.deniedPaths </span><span class="cov8" title="1">{
                        if strings.HasPrefix(absPath, denied) </span><span class="cov8" title="1">{
                                return false
                        }</span>
                }

                // Absolute paths outside allowed system paths are denied
                <span class="cov0" title="0">return false</span>
        } else<span class="cov8" title="1"> {
                // Relative paths are relative to baseDir
                absPath = filepath.Join(fm.baseDir, cleanPath)
        }</span>

        // Ensure the resolved path is still within baseDir
        <span class="cov8" title="1">absBaseDir, err := filepath.Abs(fm.baseDir)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">absRequestPath, err := filepath.Abs(absPath)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if !strings.HasPrefix(absRequestPath, absBaseDir) </span><span class="cov0" title="0">{
                return false // Outside base directory
        }</span>

        // For relative paths, check if they're within allowed directories
        <span class="cov8" title="1">for _, allowed := range fm.allowedPaths </span><span class="cov8" title="1">{
                allowedAbs := allowed
                if !filepath.IsAbs(allowed) </span><span class="cov8" title="1">{
                        allowedAbs = filepath.Join(fm.baseDir, allowed)
                }</span>

                // Normalize paths for comparison
                <span class="cov8" title="1">allowedAbs = filepath.Clean(allowedAbs)
                cleanAbsPath := filepath.Clean(absPath)

                // Allow exact match
                if cleanAbsPath == allowedAbs </span><span class="cov8" title="1">{
                        return true
                }</span>

                // Allow subdirectory (ensure it's actually a subdirectory, not just prefix match)
                <span class="cov8" title="1">if strings.HasPrefix(cleanAbsPath+string(filepath.Separator), allowedAbs+string(filepath.Separator)) </span><span class="cov8" title="1">{
                        return true
                }</span>

                // Allow files within the directory
                <span class="cov0" title="0">if strings.HasPrefix(cleanAbsPath, allowedAbs+string(filepath.Separator)) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// ReadFile reads a file's content safely
func (fm *FileManager) ReadFile(path string) (*FileContent, error) <span class="cov8" title="1">{
        if !fm.IsPathAllowed(path) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("access denied: path not allowed")
        }</span>

        // Resolve relative path
        <span class="cov8" title="1">fullPath := path
        if !filepath.IsAbs(path) </span><span class="cov8" title="1">{
                fullPath = filepath.Join(fm.baseDir, path)
        }</span>

        // Get file info
        <span class="cov8" title="1">info, err := os.Stat(fullPath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get file info: %w", err)
        }</span>

        // Read file content
        <span class="cov8" title="1">content, err := os.ReadFile(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read file: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;FileContent{
                Path:    path,
                Content: string(content),
                Size:    info.Size(),
                Mode:    info.Mode().String(),
        }, nil</span>
}

// WriteFile writes content to a file safely
func (fm *FileManager) WriteFile(path string, content string) error <span class="cov8" title="1">{
        if !fm.IsPathAllowed(path) </span><span class="cov8" title="1">{
                return fmt.Errorf("access denied: path not allowed")
        }</span>

        // Resolve relative path
        <span class="cov8" title="1">fullPath := path
        if !filepath.IsAbs(path) </span><span class="cov8" title="1">{
                fullPath = filepath.Join(fm.baseDir, path)
        }</span>

        // Ensure directory exists
        <span class="cov8" title="1">dir := filepath.Dir(fullPath)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create directory: %w", err)
        }</span>

        // Write file
        <span class="cov8" title="1">if err := os.WriteFile(fullPath, []byte(content), 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write file: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ValidateScriptSyntax performs basic validation on shell scripts
func (fm *FileManager) ValidateScriptSyntax(content string) []string <span class="cov8" title="1">{
        var issues []string

        lines := strings.Split(content, "\n")
        for i, line := range lines </span><span class="cov8" title="1">{
                lineNum := i + 1
                trimmed := strings.TrimSpace(line)

                // Skip empty lines and comments
                if trimmed == "" || strings.HasPrefix(trimmed, "#") </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Check for potential security issues
                <span class="cov8" title="1">if strings.Contains(trimmed, "rm -rf") </span><span class="cov8" title="1">{
                        issues = append(issues, fmt.Sprintf("Line %d: Potentially dangerous command 'rm -rf'", lineNum))
                }</span>

                <span class="cov8" title="1">if strings.Contains(trimmed, "sudo") </span><span class="cov8" title="1">{
                        issues = append(issues, fmt.Sprintf("Line %d: Use of 'sudo' detected", lineNum))
                }</span>

                // Check for basic syntax issues
                <span class="cov8" title="1">if strings.Count(trimmed, "'")%2 != 0 </span><span class="cov0" title="0">{
                        issues = append(issues, fmt.Sprintf("Line %d: Unmatched single quote", lineNum))
                }</span>

                <span class="cov8" title="1">if strings.Count(trimmed, "\"")%2 != 0 </span><span class="cov8" title="1">{
                        issues = append(issues, fmt.Sprintf("Line %d: Unmatched double quote", lineNum))
                }</span>
        }

        <span class="cov8" title="1">return issues</span>
}

// ListFiles lists files in a directory
func (fm *FileManager) ListFiles(dirPath string) ([]fs.FileInfo, error) <span class="cov8" title="1">{
        if !fm.IsPathAllowed(dirPath) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("access denied: path not allowed")
        }</span>

        // Resolve relative path
        <span class="cov8" title="1">fullPath := dirPath
        if !filepath.IsAbs(dirPath) </span><span class="cov8" title="1">{
                fullPath = filepath.Join(fm.baseDir, dirPath)
        }</span>

        <span class="cov8" title="1">entries, err := os.ReadDir(fullPath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to read directory: %w", err)
        }</span>

        <span class="cov8" title="1">var fileInfos []fs.FileInfo
        for _, entry := range entries </span><span class="cov8" title="1">{
                info, err := entry.Info()
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip files we can't get info for
                }
                <span class="cov8" title="1">fileInfos = append(fileInfos, info)</span>
        }

        <span class="cov8" title="1">return fileInfos, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package service

import (
        "fmt"
        "os"
        "path/filepath"
)

// GitProject represents a discovered Git project
type GitProject struct {
        Name        string `json:"name"`
        Path        string `json:"path"`
        Description string `json:"description,omitempty"`
        LastCommit  string `json:"last_commit,omitempty"`
}

// GitDiscoveryService handles Git project discovery in directories
type GitDiscoveryService struct {
}

// NewGitDiscoveryService creates a new Git discovery service
func NewGitDiscoveryService() *GitDiscoveryService <span class="cov8" title="1">{
        return &amp;GitDiscoveryService{}
}</span>

// DiscoverGitProjects scans a directory for Git projects
func (gds *GitDiscoveryService) DiscoverGitProjects(rootDir string) ([]GitProject, error) <span class="cov8" title="1">{
        if _, err := os.Stat(rootDir); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("directory does not exist: %s", rootDir)
        }</span>

        <span class="cov8" title="1">var projects []GitProject

        err := filepath.Walk(rootDir, func(path string, info os.FileInfo, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        return nil // Skip inaccessible directories
                }</span>

                // Check if this is a .git directory
                <span class="cov8" title="1">if info.IsDir() &amp;&amp; info.Name() == ".git" </span><span class="cov8" title="1">{
                        // The parent directory is a Git project
                        projectPath := filepath.Dir(path)
                        projectName := filepath.Base(projectPath)

                        project := GitProject{
                                Name: projectName,
                                Path: projectPath,
                        }

                        projects = append(projects, project)
                        return filepath.SkipDir // Skip walking inside .git directory
                }</span>

                <span class="cov8" title="1">return nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return projects, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Package service provides core functionality for the run-script-service daemon
package service

import (
        "bufio"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "regexp"
        "strconv"
        "strings"
        "sync"
        "time"
)

// LogManager manages multiple script loggers
type LogManager struct {
        loggers map[string]*ScriptLogger
        baseDir string
        mutex   sync.RWMutex
}

// ScriptLogger handles logging for a specific script
type ScriptLogger struct {
        scriptName string
        logPath    string
        maxLines   int
        entries    []LogEntry
        mutex      sync.RWMutex
}

// LogEntry represents a single log entry
type LogEntry struct {
        Timestamp  time.Time `json:"timestamp"`
        ScriptName string    `json:"script_name"`
        ExitCode   int       `json:"exit_code"`
        Stdout     string    `json:"stdout"`
        Stderr     string    `json:"stderr"`
        Duration   int64     `json:"duration_ms"`
}

// LogQuery defines criteria for querying logs
type LogQuery struct {
        ScriptName string    `json:"script_name,omitempty"`
        StartTime  time.Time `json:"start_time,omitempty"`
        EndTime    time.Time `json:"end_time,omitempty"`
        ExitCode   *int      `json:"exit_code,omitempty"`
        Limit      int       `json:"limit,omitempty"`
}

// NewLogManager creates a new LogManager instance
func NewLogManager(baseDir string) *LogManager <span class="cov8" title="1">{
        return &amp;LogManager{
                loggers: make(map[string]*ScriptLogger),
                baseDir: baseDir,
        }
}</span>

// GetLogger returns a logger for the specified script, creating one if it doesn't exist
func (lm *LogManager) GetLogger(scriptName string) *ScriptLogger <span class="cov8" title="1">{
        lm.mutex.Lock()
        defer lm.mutex.Unlock()

        if logger, exists := lm.loggers[scriptName]; exists </span><span class="cov8" title="1">{
                return logger
        }</span>

        <span class="cov8" title="1">logger := NewScriptLogger(scriptName, lm.baseDir, 100) // Default max lines
        lm.loggers[scriptName] = logger
        return logger</span>
}

// NewScriptLogger creates a new ScriptLogger instance
func NewScriptLogger(scriptName, baseDir string, maxLines int) *ScriptLogger <span class="cov8" title="1">{
        logPath := filepath.Join(baseDir, fmt.Sprintf("%s.log", scriptName))

        logger := &amp;ScriptLogger{
                scriptName: scriptName,
                logPath:    logPath,
                maxLines:   maxLines,
                entries:    make([]LogEntry, 0),
        }

        // Ensure log directory exists
        _ = os.MkdirAll(baseDir, 0750) // Ignore error - logger will still work, file ops may fail later

        // Load existing log file if it exists
        logger.LoadExistingLogs()

        return logger
}</span>

// AddEntry adds a new log entry to the script logger
func (sl *ScriptLogger) AddEntry(entry *LogEntry) error <span class="cov8" title="1">{
        sl.mutex.Lock()
        defer sl.mutex.Unlock()

        // Add entry to in-memory storage
        sl.entries = append(sl.entries, *entry)

        // Maintain maxLines limit
        if len(sl.entries) &gt; sl.maxLines </span><span class="cov8" title="1">{
                sl.entries = sl.entries[len(sl.entries)-sl.maxLines:]
        }</span>

        // Write to file
        <span class="cov8" title="1">return sl.writeToFile(entry)</span>
}

// writeToFile writes a log entry to the log file
func (sl *ScriptLogger) writeToFile(entry *LogEntry) error <span class="cov8" title="1">{
        file, err := os.OpenFile(sl.logPath, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0600)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open log file: %w", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        data, err := json.Marshal(entry)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal log entry: %w", err)
        }</span>

        <span class="cov8" title="1">_, err = file.Write(append(data, '\n'))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write log entry: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetEntries returns all log entries for this script
func (sl *ScriptLogger) GetEntries() []LogEntry <span class="cov8" title="1">{
        sl.mutex.RLock()
        defer sl.mutex.RUnlock()

        // Return a copy to prevent external modification
        entries := make([]LogEntry, len(sl.entries))
        copy(entries, sl.entries)
        return entries
}</span>

// QueryLogs queries logs across all managed scripts
func (lm *LogManager) QueryLogs(query *LogQuery) ([]LogEntry, error) <span class="cov0" title="0">{
        lm.mutex.RLock()
        defer lm.mutex.RUnlock()

        var results []LogEntry

        // If specific script is requested
        if query.ScriptName != "" </span><span class="cov0" title="0">{
                if logger, exists := lm.loggers[query.ScriptName]; exists </span><span class="cov0" title="0">{
                        entries := logger.GetEntries()
                        results = append(results, entries...)
                }</span>
        } else<span class="cov0" title="0"> {
                // Query all scripts
                for _, logger := range lm.loggers </span><span class="cov0" title="0">{
                        entries := logger.GetEntries()
                        results = append(results, entries...)
                }</span>
        }

        // Apply filters
        <span class="cov0" title="0">filtered := make([]LogEntry, 0)
        for i := range results </span><span class="cov0" title="0">{
                if lm.matchesQuery(&amp;results[i], query) </span><span class="cov0" title="0">{
                        filtered = append(filtered, results[i])
                }</span>
        }

        // Apply limit
        <span class="cov0" title="0">if query.Limit &gt; 0 &amp;&amp; len(filtered) &gt; query.Limit </span><span class="cov0" title="0">{
                filtered = filtered[len(filtered)-query.Limit:]
        }</span>

        <span class="cov0" title="0">return filtered, nil</span>
}

// matchesQuery checks if a log entry matches the query criteria
func (lm *LogManager) matchesQuery(entry *LogEntry, query *LogQuery) bool <span class="cov0" title="0">{
        // Check time range
        if !query.StartTime.IsZero() &amp;&amp; entry.Timestamp.Before(query.StartTime) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if !query.EndTime.IsZero() &amp;&amp; entry.Timestamp.After(query.EndTime) </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check exit code
        <span class="cov0" title="0">if query.ExitCode != nil &amp;&amp; entry.ExitCode != *query.ExitCode </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

// LoadExistingLogs loads log entries from existing log file
func (sl *ScriptLogger) LoadExistingLogs() <span class="cov8" title="1">{
        if _, err := os.Stat(sl.logPath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return // No existing log file
        }</span>

        <span class="cov0" title="0">file, err := os.Open(sl.logPath)
        if err != nil </span><span class="cov0" title="0">{
                return // Can't open file, continue without loading
        }</span>
        <span class="cov0" title="0">defer file.Close()

        scanner := bufio.NewScanner(file)
        var currentEntry *LogEntry
        var stdoutLines []string

        // Regex to match timestamp and exit code line: [2025-08-02 11:26:16] Exit code: 0
        timestampRegex := regexp.MustCompile(`^\[([^\]]+)\] Exit code: (\d+)$`)

        for scanner.Scan() </span><span class="cov0" title="0">{
                line := strings.TrimSpace(scanner.Text())

                if line == "--------------------------------------------------" </span><span class="cov0" title="0">{
                        // End of entry
                        if currentEntry != nil </span><span class="cov0" title="0">{
                                currentEntry.Stdout = strings.Join(stdoutLines, "\n")
                                sl.entries = append(sl.entries, *currentEntry)
                                currentEntry = nil
                                stdoutLines = nil
                        }</span>
                } else<span class="cov0" title="0"> if matches := timestampRegex.FindStringSubmatch(line); matches != nil </span><span class="cov0" title="0">{
                        // Start of new entry
                        timestamp, _ := time.Parse("2006-01-02 15:04:05", matches[1])
                        exitCode, _ := strconv.Atoi(matches[2])

                        currentEntry = &amp;LogEntry{
                                Timestamp:  timestamp,
                                ScriptName: sl.scriptName,
                                ExitCode:   exitCode,
                                Stdout:     "",
                                Stderr:     "",
                                Duration:   0, // Can't determine from existing logs
                        }
                        stdoutLines = make([]string, 0)
                }</span> else<span class="cov0" title="0"> if currentEntry != nil &amp;&amp; strings.HasPrefix(line, "STDOUT: ") </span><span class="cov0" title="0">{
                        // STDOUT line
                        stdoutContent := strings.TrimPrefix(line, "STDOUT: ")
                        stdoutLines = append(stdoutLines, stdoutContent)
                }</span> else<span class="cov0" title="0"> if currentEntry != nil &amp;&amp; line != "" &amp;&amp; !strings.HasPrefix(line, "STDERR: ") </span><span class="cov0" title="0">{
                        // Continuation of stdout (multi-line output)
                        stdoutLines = append(stdoutLines, line)
                }</span>
        }

        // Handle last entry if file doesn't end with separator
        <span class="cov0" title="0">if currentEntry != nil </span><span class="cov0" title="0">{
                currentEntry.Stdout = strings.Join(stdoutLines, "\n")
                sl.entries = append(sl.entries, *currentEntry)
        }</span>

        // Maintain maxLines limit
        <span class="cov0" title="0">if len(sl.entries) &gt; sl.maxLines </span><span class="cov0" title="0">{
                sl.entries = sl.entries[len(sl.entries)-sl.maxLines:]
        }</span>
}

// ClearLogs clears all log entries for a specific script
func (lm *LogManager) ClearLogs(scriptName string) error <span class="cov0" title="0">{
        lm.mutex.Lock()
        defer lm.mutex.Unlock()

        if logger, exists := lm.loggers[scriptName]; exists </span><span class="cov0" title="0">{
                return logger.ClearEntries()
        }</span>

        <span class="cov0" title="0">return fmt.Errorf("script '%s' not found", scriptName)</span>
}

// ClearEntries clears all log entries for this script logger
func (sl *ScriptLogger) ClearEntries() error <span class="cov0" title="0">{
        sl.mutex.Lock()
        defer sl.mutex.Unlock()

        // Clear in-memory entries
        sl.entries = make([]LogEntry, 0)

        // Clear the log file
        if err := os.Truncate(sl.logPath, 0); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to clear log file: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package service

import (
        "context"
        "encoding/json"
        "fmt"
        "runtime"
        "sync"
        "syscall"
        "time"
)

type SystemMetrics struct {
        CPUPercent      float64   `json:"cpu_percent"`
        MemoryPercent   float64   `json:"memory_percent"`
        DiskPercent     float64   `json:"disk_percent"`
        ActiveScripts   int       `json:"active_scripts"`
        TotalExecutions int       `json:"total_executions"`
        Timestamp       time.Time `json:"timestamp"`
}

func (sm *SystemMetrics) ToJSON() []byte <span class="cov8" title="1">{
        data, _ := json.Marshal(sm)
        return data
}</span>

type SystemMonitor struct {
        mu              sync.RWMutex
        activeScripts   int
        totalExecutions int
        startTime       time.Time
}

func NewSystemMonitor() *SystemMonitor <span class="cov8" title="1">{
        return &amp;SystemMonitor{
                startTime: time.Now(),
        }
}</span>

func (sm *SystemMonitor) SetActiveScripts(count int) <span class="cov8" title="1">{
        sm.mu.Lock()
        defer sm.mu.Unlock()
        sm.activeScripts = count
}</span>

func (sm *SystemMonitor) SetTotalExecutions(count int) <span class="cov8" title="1">{
        sm.mu.Lock()
        defer sm.mu.Unlock()
        sm.totalExecutions = count
}</span>

func (sm *SystemMonitor) GetSystemMetrics() (*SystemMetrics, error) <span class="cov8" title="1">{
        sm.mu.RLock()
        activeScripts := sm.activeScripts
        totalExecutions := sm.totalExecutions
        sm.mu.RUnlock()

        var memStats runtime.MemStats
        runtime.ReadMemStats(&amp;memStats)

        // Calculate memory usage percentage
        // Using allocated memory vs system memory (simplified)
        memoryPercent := float64(memStats.Alloc) / float64(memStats.Sys) * 100
        if memoryPercent &gt; 100 </span><span class="cov0" title="0">{
                memoryPercent = 100
        }</span>

        // Get disk usage
        <span class="cov8" title="1">diskPercent := sm.getDiskUsage()

        // Get CPU usage (simplified - always return a reasonable value for tests)
        cpuPercent := sm.getCPUUsage()

        return &amp;SystemMetrics{
                CPUPercent:      cpuPercent,
                MemoryPercent:   memoryPercent,
                DiskPercent:     diskPercent,
                ActiveScripts:   activeScripts,
                TotalExecutions: totalExecutions,
                Timestamp:       time.Now(),
        }, nil</span>
}

func (sm *SystemMonitor) getDiskUsage() float64 <span class="cov8" title="1">{
        var stat syscall.Statfs_t
        err := syscall.Statfs("/", &amp;stat)
        if err != nil </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        <span class="cov8" title="1">total := stat.Blocks * uint64(stat.Bsize)
        free := stat.Bavail * uint64(stat.Bsize)
        used := total - free

        if total == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        <span class="cov8" title="1">return float64(used) / float64(total) * 100</span>
}

func (sm *SystemMonitor) getCPUUsage() float64 <span class="cov8" title="1">{
        // Simplified CPU usage - in a real implementation, this would
        // involve reading /proc/stat and calculating CPU usage over time
        // For testing purposes, return a reasonable value
        return 25.0
}</span>

// GetUptime returns a human-readable uptime string
func (sm *SystemMonitor) GetUptime() string <span class="cov0" title="0">{
        sm.mu.RLock()
        startTime := sm.startTime
        sm.mu.RUnlock()

        uptime := time.Since(startTime)

        // Format uptime as human-readable string
        days := int(uptime.Hours()) / 24
        hours := int(uptime.Hours()) % 24
        minutes := int(uptime.Minutes()) % 60

        if days &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dd %dh %dm", days, hours, minutes)
        }</span> else<span class="cov0" title="0"> if hours &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dh %dm", hours, minutes)
        }</span> else<span class="cov0" title="0"> {
                return fmt.Sprintf("%dm", minutes)
        }</span>
}

// EventPublisher is a function type for publishing events
type EventPublisher func(msgType string, data map[string]interface{}) error

// StartPeriodicBroadcasting starts periodic system metrics broadcasting
func (sm *SystemMonitor) StartPeriodicBroadcasting(ctx context.Context, interval time.Duration, publisher EventPublisher) <span class="cov8" title="1">{
        ticker := time.NewTicker(interval)
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov8" title="1">
                        metrics, err := sm.GetSystemMetrics()
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Convert metrics to map for publishing
                        <span class="cov8" title="1">data := map[string]interface{}{
                                "cpu_percent":      metrics.CPUPercent,
                                "memory_percent":   metrics.MemoryPercent,
                                "disk_percent":     metrics.DiskPercent,
                                "active_scripts":   metrics.ActiveScripts,
                                "total_executions": metrics.TotalExecutions,
                                "timestamp":        metrics.Timestamp,
                        }

                        publisher("system_metrics", data)</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package service

import (
        "fmt"
        "io/fs"
        "os"
        "path/filepath"
        "strings"
        "sync"
        "time"
)

// ScriptFile represents a script file with metadata
type ScriptFile struct {
        Name     string    `json:"name"`
        Filename string    `json:"filename"`
        Content  string    `json:"content"`
        Path     string    `json:"path"`
        Size     int64     `json:"size"`
        Modified time.Time `json:"modified"`
}

// ScriptFileManager manages script files in the dedicated scripts directory
type ScriptFileManager struct {
        scriptsDir string
        mutex      sync.RWMutex
}

// NewScriptFileManager creates a new ScriptFileManager with the specified base directory
func NewScriptFileManager(baseDir string) *ScriptFileManager <span class="cov8" title="1">{
        scriptsDir := filepath.Join(baseDir, "scripts")

        // Ensure scripts directory exists
        if err := os.MkdirAll(scriptsDir, 0755); err != nil </span><span class="cov0" title="0">{
                // Log warning but don't fail - tests might still want to proceed
                fmt.Printf("Warning: Failed to create scripts directory: %v\n", err)
        }</span>

        <span class="cov8" title="1">return &amp;ScriptFileManager{
                scriptsDir: scriptsDir,
        }</span>
}

// CreateScript creates a new script file with the given content
func (sfm *ScriptFileManager) CreateScript(filename, content string) error <span class="cov8" title="1">{
        sfm.mutex.Lock()
        defer sfm.mutex.Unlock()

        // Validate file extension
        if !strings.HasSuffix(filename, ".sh") </span><span class="cov8" title="1">{
                return fmt.Errorf("script filename must end with .sh extension")
        }</span>

        // Validate filename format
        <span class="cov8" title="1">if !isValidFilename(filename) </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid filename format")
        }</span>

        <span class="cov8" title="1">filePath := filepath.Join(sfm.scriptsDir, filename)

        // Check if file already exists
        if _, err := os.Stat(filePath); err == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("script file already exists: %s", filename)
        }</span>

        // Create file with executable permissions
        <span class="cov8" title="1">if err := os.WriteFile(filePath, []byte(content), 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create script file: %v", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetScript retrieves a script file with its content and metadata
func (sfm *ScriptFileManager) GetScript(filename string) (*ScriptFile, error) <span class="cov8" title="1">{
        sfm.mutex.RLock()
        defer sfm.mutex.RUnlock()

        filePath := filepath.Join(sfm.scriptsDir, filename)

        // Read file info
        fileInfo, err := os.Stat(filePath)
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("script file not found: %s", filename)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get script file info: %v", err)</span>
        }

        // Read file content
        <span class="cov8" title="1">content, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read script file: %v", err)
        }</span>

        <span class="cov8" title="1">return &amp;ScriptFile{
                Filename: filename,
                Content:  string(content),
                Path:     filePath,
                Size:     fileInfo.Size(),
                Modified: fileInfo.ModTime(),
        }, nil</span>
}

// UpdateScript updates the content of an existing script file
func (sfm *ScriptFileManager) UpdateScript(filename, content string) error <span class="cov8" title="1">{
        sfm.mutex.Lock()
        defer sfm.mutex.Unlock()

        filePath := filepath.Join(sfm.scriptsDir, filename)

        // Check if file exists
        if _, err := os.Stat(filePath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return fmt.Errorf("script file not found: %s", filename)
        }</span>

        // Update file content with executable permissions
        <span class="cov8" title="1">if err := os.WriteFile(filePath, []byte(content), 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update script file: %v", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ListScripts returns a list of all script files in the scripts directory
func (sfm *ScriptFileManager) ListScripts() ([]*ScriptFile, error) <span class="cov8" title="1">{
        sfm.mutex.RLock()
        defer sfm.mutex.RUnlock()

        var scripts []*ScriptFile

        err := filepath.WalkDir(sfm.scriptsDir, func(path string, d fs.DirEntry, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Skip directories and non-.sh files
                <span class="cov8" title="1">if d.IsDir() || !strings.HasSuffix(d.Name(), ".sh") </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov8" title="1">fileInfo, err := d.Info()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">scripts = append(scripts, &amp;ScriptFile{
                        Filename: d.Name(),
                        Path:     path,
                        Size:     fileInfo.Size(),
                        Modified: fileInfo.ModTime(),
                        // Don't load content for list view - performance optimization
                })

                return nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list scripts: %v", err)
        }</span>

        <span class="cov8" title="1">return scripts, nil</span>
}

// DeleteScript removes a script file from the scripts directory
func (sfm *ScriptFileManager) DeleteScript(filename string) error <span class="cov8" title="1">{
        sfm.mutex.Lock()
        defer sfm.mutex.Unlock()

        filePath := filepath.Join(sfm.scriptsDir, filename)

        if err := os.Remove(filePath); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to delete script file: %v", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetScriptPath returns the full path for a script filename
func (sfm *ScriptFileManager) GetScriptPath(filename string) string <span class="cov8" title="1">{
        return filepath.Join(sfm.scriptsDir, filename)
}</span>

// isValidFilename validates that a filename contains only safe characters
func isValidFilename(filename string) bool <span class="cov8" title="1">{
        // Must not be empty and must be reasonable length
        if len(filename) == 0 || len(filename) &gt; 255 </span><span class="cov8" title="1">{
                return false
        }</span>

        // Define allowed characters: letters, numbers, dots, underscores, hyphens
        <span class="cov8" title="1">validChars := "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789._-"

        for _, char := range filename </span><span class="cov8" title="1">{
                if !strings.ContainsRune(validChars, char) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package service

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"
)

// ScriptTemplate represents the input data for script generation
type ScriptTemplate struct {
        Type        string           `json:"type"`                   // "pure" or "claude-code"
        Name        string           `json:"name"`                   // Script name
        ProjectPath string           `json:"project_path,omitempty"` // For claude-code scripts
        Content     string           `json:"content,omitempty"`      // For pure scripts
        Prompts     []string         `json:"prompts,omitempty"`      // For claude-code scripts
        Config      ScriptConfigData `json:"config"`                 // Script configuration
}

// ScriptConfigData represents script configuration settings
type ScriptConfigData struct {
        Interval    string `json:"interval"`
        Timeout     int    `json:"timeout"`
        MaxLogLines int    `json:"max_log_lines"`
}

// GeneratedScript represents the output of script generation
type GeneratedScript struct {
        Name    string           `json:"name"`
        Path    string           `json:"path"`
        Content string           `json:"content"`
        Config  ScriptConfigData `json:"config"`
}

// ScriptGenerator handles script generation from templates
type ScriptGenerator struct {
        outputDir string
}

// NewScriptGenerator creates a new script generator instance
func NewScriptGenerator() *ScriptGenerator <span class="cov8" title="1">{
        // Get current working directory as default output directory
        dir, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                dir, _ = os.Getwd()
        }</span> else<span class="cov8" title="1"> {
                dir = filepath.Dir(dir)
        }</span>

        <span class="cov8" title="1">return &amp;ScriptGenerator{
                outputDir: dir,
        }</span>
}

// GenerateScript generates a script from a template
func (sg *ScriptGenerator) GenerateScript(template *ScriptTemplate) (*GeneratedScript, error) <span class="cov8" title="1">{
        // Validate template first
        if err := sg.ValidateTemplate(template); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("template validation failed: %v", err)
        }</span>

        <span class="cov8" title="1">var content string
        var err error

        switch template.Type </span>{
        case "pure":<span class="cov8" title="1">
                content, err = sg.generatePureScript(template)</span>
        case "claude-code":<span class="cov8" title="1">
                content, err = sg.generateClaudeCodeScript(template)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported script type: %s", template.Type)</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("script generation failed: %v", err)
        }</span>

        // Generate script file path
        <span class="cov8" title="1">scriptPath := filepath.Join(sg.outputDir, fmt.Sprintf("%s.sh", template.Name))

        result := &amp;GeneratedScript{
                Name:    template.Name,
                Path:    scriptPath,
                Content: content,
                Config:  template.Config,
        }

        return result, nil</span>
}

// ValidateTemplate validates a script template
func (sg *ScriptGenerator) ValidateTemplate(template *ScriptTemplate) error <span class="cov8" title="1">{
        if template == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("template cannot be nil")
        }</span>

        <span class="cov8" title="1">if template.Name == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("script name is required")
        }</span>

        <span class="cov8" title="1">if template.Type == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("script type is required")
        }</span>

        <span class="cov8" title="1">switch template.Type </span>{
        case "pure":<span class="cov8" title="1">
                if template.Content == "" </span><span class="cov8" title="1">{
                        return fmt.Errorf("content is required for pure scripts")
                }</span>
        case "claude-code":<span class="cov8" title="1">
                if template.ProjectPath == "" </span><span class="cov8" title="1">{
                        return fmt.Errorf("project path is required for Claude Code scripts")
                }</span>
                <span class="cov8" title="1">if len(template.Prompts) == 0 </span><span class="cov8" title="1">{
                        return fmt.Errorf("at least one prompt is required for Claude Code scripts")
                }</span>
                <span class="cov8" title="1">if len(template.Prompts) &gt; 5 </span><span class="cov8" title="1">{
                        return fmt.Errorf("maximum of 5 prompts allowed for Claude Code scripts")
                }</span>
                // Validate prompts are not empty
                <span class="cov8" title="1">for i, prompt := range template.Prompts </span><span class="cov8" title="1">{
                        if strings.TrimSpace(prompt) == "" </span><span class="cov0" title="0">{
                                return fmt.Errorf("prompt %d cannot be empty", i+1)
                        }</span>
                }
        default:<span class="cov8" title="1">
                return fmt.Errorf("unsupported script type: %s (must be 'pure' or 'claude-code')", template.Type)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// generatePureScript generates a pure shell script
func (sg *ScriptGenerator) generatePureScript(template *ScriptTemplate) (string, error) <span class="cov8" title="1">{
        script := `#!/bin/bash

# Auto-generated Script: ` + template.Name + `
# Type: Pure Shell Script

` + template.Content + `
`
        return script, nil
}</span>

// generateClaudeCodeScript generates a Claude Code automation script
func (sg *ScriptGenerator) generateClaudeCodeScript(template *ScriptTemplate) (string, error) <span class="cov8" title="1">{
        script := `#!/bin/bash

# Auto-generated Claude Code Script
# Script Name: ` + template.Name + `
# Project Path: ` + template.ProjectPath + `
export SKIP_CLAUDE_HOOKS=1

echo "$(date): Starting ` + template.Name + `..."
cd ` + template.ProjectPath + `
`

        // Add each prompt as a phase
        for i, prompt := range template.Prompts </span><span class="cov8" title="1">{
                phaseNum := i + 1
                script += fmt.Sprintf(`
# Phase %d: %s
echo "$(date): Phase %d - Executing..."
/home/logan/.claude/local/claude --dangerously-skip-permissions -p "%s" --output-format stream-json --verbose
PHASE%d_EXIT=$?
echo "$(date): Phase %d completed with exit code: $PHASE%d_EXIT"
`, phaseNum, prompt, phaseNum, prompt, phaseNum, phaseNum, phaseNum)
        }</span>

        <span class="cov8" title="1">script += `
echo "$(date): ` + template.Name + ` completed successfully"
`

        return script, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Package service provides core functionality for the run-script-service daemon.
package service

import (
        "context"
        "fmt"
        "sync"
)

// ConfigChange represents a configuration change
type ConfigChange struct {
        Field           string
        OldValue        interface{}
        NewValue        interface{}
        RequiresRestart bool
}

// ScriptManager manages multiple script runners
type ScriptManager struct {
        scripts    map[string]*ScriptRunner
        config     *ServiceConfig
        configPath string
        mutex      sync.RWMutex
}

// NewScriptManager creates a new script manager with the given configuration
func NewScriptManager(config *ServiceConfig) *ScriptManager <span class="cov8" title="1">{
        return &amp;ScriptManager{
                scripts: make(map[string]*ScriptRunner),
                config:  config,
        }
}</span>

// NewScriptManagerWithPath creates a new script manager with configuration and config path
func NewScriptManagerWithPath(config *ServiceConfig, configPath string) *ScriptManager <span class="cov0" title="0">{
        return &amp;ScriptManager{
                scripts:    make(map[string]*ScriptRunner),
                config:     config,
                configPath: configPath,
        }
}</span>

// StartScript starts a script by name
func (sm *ScriptManager) StartScript(ctx context.Context, name string) error <span class="cov8" title="1">{
        sm.mutex.Lock()
        defer sm.mutex.Unlock()

        // Check if script is already running
        if _, exists := sm.scripts[name]; exists </span><span class="cov0" title="0">{
                return fmt.Errorf("script %s is already running", name)
        }</span>

        // Find the script config
        <span class="cov8" title="1">var scriptConfig *ScriptConfig
        for i, sc := range sm.config.Scripts </span><span class="cov8" title="1">{
                if sc.Name == name </span><span class="cov8" title="1">{
                        scriptConfig = &amp;sm.config.Scripts[i]
                        break</span>
                }
        }

        <span class="cov8" title="1">if scriptConfig == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("script %s not found in configuration", name)
        }</span>

        // Create and start the script runner
        <span class="cov8" title="1">logPath := fmt.Sprintf("%s.log", name) // Simple log path for now
        runner := NewScriptRunner(*scriptConfig, logPath)
        sm.scripts[name] = runner

        // Start the runner in a goroutine
        go func() </span><span class="cov8" title="1">{
                runner.Start(ctx)
                // Clean up when runner stops
                sm.mutex.Lock()
                delete(sm.scripts, name)
                sm.mutex.Unlock()
        }</span>()

        <span class="cov8" title="1">return nil</span>
}

// StopScript stops a script by name
func (sm *ScriptManager) StopScript(name string) error <span class="cov8" title="1">{
        sm.mutex.Lock()
        defer sm.mutex.Unlock()

        runner, exists := sm.scripts[name]
        if !exists </span><span class="cov8" title="1">{
                return fmt.Errorf("script %s is not running", name)
        }</span>

        <span class="cov8" title="1">runner.Stop()
        delete(sm.scripts, name)
        return nil</span>
}

// StartAllEnabled starts all enabled scripts
func (sm *ScriptManager) StartAllEnabled(ctx context.Context) error <span class="cov8" title="1">{
        for _, scriptConfig := range sm.config.Scripts </span><span class="cov8" title="1">{
                if scriptConfig.Enabled </span><span class="cov8" title="1">{
                        if err := sm.StartScript(ctx, scriptConfig.Name); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to start script %s: %v", scriptConfig.Name, err)
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// StopAll stops all running scripts
func (sm *ScriptManager) StopAll() <span class="cov8" title="1">{
        sm.mutex.Lock()
        defer sm.mutex.Unlock()

        for name, runner := range sm.scripts </span><span class="cov8" title="1">{
                runner.Stop()
                delete(sm.scripts, name)
        }</span>
}

// GetScripts returns all configured scripts
func (sm *ScriptManager) GetScripts() ([]ScriptConfig, error) <span class="cov0" title="0">{
        sm.mutex.RLock()
        defer sm.mutex.RUnlock()

        // Return a copy to prevent external modification
        scripts := make([]ScriptConfig, len(sm.config.Scripts))
        copy(scripts, sm.config.Scripts)

        return scripts, nil
}</span>

// GetRunningScripts returns a list of currently running script names
func (sm *ScriptManager) GetRunningScripts() []string <span class="cov0" title="0">{
        sm.mutex.RLock()
        defer sm.mutex.RUnlock()

        var running []string
        for name := range sm.scripts </span><span class="cov0" title="0">{
                running = append(running, name)
        }</span>
        <span class="cov0" title="0">return running</span>
}

// IsScriptRunning checks if a specific script is running
func (sm *ScriptManager) IsScriptRunning(name string) bool <span class="cov8" title="1">{
        sm.mutex.RLock()
        defer sm.mutex.RUnlock()

        _, exists := sm.scripts[name]
        return exists
}</span>

// GetConfig returns the script manager's configuration
func (sm *ScriptManager) GetConfig() *ServiceConfig <span class="cov0" title="0">{
        return sm.config
}</span>

// SaveConfig saves the current configuration to file
func (sm *ScriptManager) SaveConfig() error <span class="cov0" title="0">{
        if sm.configPath == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("config path not set - cannot save configuration")
        }</span>
        <span class="cov0" title="0">return SaveServiceConfig(sm.configPath, sm.config)</span>
}

// AddScript adds a new script configuration
func (sm *ScriptManager) AddScript(scriptConfig ScriptConfig) error <span class="cov0" title="0">{
        sm.mutex.Lock()
        defer sm.mutex.Unlock()

        // Check if script with same name already exists
        for _, existing := range sm.config.Scripts </span><span class="cov0" title="0">{
                if existing.Name == scriptConfig.Name </span><span class="cov0" title="0">{
                        return fmt.Errorf("script with name %s already exists", scriptConfig.Name)
                }</span>
        }

        // Add the script to configuration
        <span class="cov0" title="0">sm.config.Scripts = append(sm.config.Scripts, scriptConfig)
        return nil</span>
}

// RunScriptOnce executes a script once by name
func (sm *ScriptManager) RunScriptOnce(ctx context.Context, name string) error <span class="cov0" title="0">{
        sm.mutex.RLock()
        defer sm.mutex.RUnlock()

        // Find the script config
        var scriptConfig *ScriptConfig
        for i, sc := range sm.config.Scripts </span><span class="cov0" title="0">{
                if sc.Name == name </span><span class="cov0" title="0">{
                        scriptConfig = &amp;sm.config.Scripts[i]
                        break</span>
                }
        }

        <span class="cov0" title="0">if scriptConfig == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("script %s not found in configuration", name)
        }</span>

        // Create a temporary script runner for one-time execution
        <span class="cov0" title="0">logPath := fmt.Sprintf("%s.log", name)
        runner := NewScriptRunner(*scriptConfig, logPath)

        return runner.RunOnce(ctx)</span>
}

// EnableScript enables a script by name
func (sm *ScriptManager) EnableScript(name string) error <span class="cov0" title="0">{
        sm.mutex.Lock()
        defer sm.mutex.Unlock()

        // Find the script config
        for i, sc := range sm.config.Scripts </span><span class="cov0" title="0">{
                if sc.Name == name </span><span class="cov0" title="0">{
                        sm.config.Scripts[i].Enabled = true
                        return nil
                }</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("script %s not found in configuration", name)</span>
}

// DisableScript disables a script by name
func (sm *ScriptManager) DisableScript(name string) error <span class="cov0" title="0">{
        sm.mutex.Lock()
        defer sm.mutex.Unlock()

        // Find the script config
        for i, sc := range sm.config.Scripts </span><span class="cov0" title="0">{
                if sc.Name == name </span><span class="cov0" title="0">{
                        sm.config.Scripts[i].Enabled = false
                        return nil
                }</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("script %s not found in configuration", name)</span>
}

// UpdateScript updates an existing script configuration
func (sm *ScriptManager) UpdateScript(name string, updatedConfig ScriptConfig) error <span class="cov8" title="1">{
        sm.mutex.Lock()
        defer sm.mutex.Unlock()

        // Find the script config and update it
        for i, sc := range sm.config.Scripts </span><span class="cov8" title="1">{
                if sc.Name == name </span><span class="cov8" title="1">{
                        // Ensure the name matches the parameter
                        updatedConfig.Name = name
                        sm.config.Scripts[i] = updatedConfig
                        return nil
                }</span>
        }

        <span class="cov8" title="1">return fmt.Errorf("script %s not found in configuration", name)</span>
}

// RemoveScript removes a script from configuration and stops it if running
func (sm *ScriptManager) RemoveScript(name string) error <span class="cov8" title="1">{
        sm.mutex.Lock()
        defer sm.mutex.Unlock()

        // Stop the script if it's running
        if runner, exists := sm.scripts[name]; exists </span><span class="cov8" title="1">{
                runner.Stop()
                delete(sm.scripts, name)
        }</span>

        // Find and remove the script from configuration
        <span class="cov8" title="1">found := false
        newScripts := make([]ScriptConfig, 0, len(sm.config.Scripts))
        for _, sc := range sm.config.Scripts </span><span class="cov8" title="1">{
                if sc.Name != name </span><span class="cov8" title="1">{
                        newScripts = append(newScripts, sc)
                }</span> else<span class="cov8" title="1"> {
                        found = true
                }</span>
        }

        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                return fmt.Errorf("script %s not found in configuration", name)
        }</span>

        <span class="cov8" title="1">sm.config.Scripts = newScripts
        return nil</span>
}

// detectChanges detects differences between old and new script configurations
func (sm *ScriptManager) detectChanges(old, new ScriptConfig) []ConfigChange <span class="cov8" title="1">{
        var changes []ConfigChange

        if old.Interval != new.Interval </span><span class="cov8" title="1">{
                changes = append(changes, ConfigChange{
                        Field:           "interval",
                        OldValue:        old.Interval,
                        NewValue:        new.Interval,
                        RequiresRestart: true,
                })
        }</span>

        <span class="cov8" title="1">if old.Enabled != new.Enabled </span><span class="cov8" title="1">{
                changes = append(changes, ConfigChange{
                        Field:           "enabled",
                        OldValue:        old.Enabled,
                        NewValue:        new.Enabled,
                        RequiresRestart: true,
                })
        }</span>

        <span class="cov8" title="1">if old.Path != new.Path </span><span class="cov8" title="1">{
                changes = append(changes, ConfigChange{
                        Field:           "path",
                        OldValue:        old.Path,
                        NewValue:        new.Path,
                        RequiresRestart: true,
                })
        }</span>

        <span class="cov8" title="1">if old.MaxLogLines != new.MaxLogLines </span><span class="cov8" title="1">{
                changes = append(changes, ConfigChange{
                        Field:           "max_log_lines",
                        OldValue:        old.MaxLogLines,
                        NewValue:        new.MaxLogLines,
                        RequiresRestart: false,
                })
        }</span>

        <span class="cov8" title="1">if old.Timeout != new.Timeout </span><span class="cov8" title="1">{
                changes = append(changes, ConfigChange{
                        Field:           "timeout",
                        OldValue:        old.Timeout,
                        NewValue:        new.Timeout,
                        RequiresRestart: false,
                })
        }</span>

        <span class="cov8" title="1">return changes</span>
}

// UpdateScriptWithImmediateApplication updates a script and applies changes immediately to running scripts
func (sm *ScriptManager) UpdateScriptWithImmediateApplication(name string, updatedConfig ScriptConfig) error <span class="cov8" title="1">{
        sm.mutex.Lock()
        defer sm.mutex.Unlock()

        // Find the current configuration
        var oldConfig *ScriptConfig
        for i, sc := range sm.config.Scripts </span><span class="cov8" title="1">{
                if sc.Name == name </span><span class="cov8" title="1">{
                        oldConfig = &amp;sc
                        // Update configuration first
                        updatedConfig.Name = name
                        sm.config.Scripts[i] = updatedConfig
                        break</span>
                }
        }

        <span class="cov8" title="1">if oldConfig == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("script %s not found in configuration", name)
        }</span>

        // Detect changes
        <span class="cov8" title="1">changes := sm.detectChanges(*oldConfig, updatedConfig)

        // Apply changes immediately if script is running
        if runner, exists := sm.scripts[name]; exists </span><span class="cov0" title="0">{
                return sm.applyConfigChanges(name, runner, *oldConfig, updatedConfig, changes)
        }</span>

        // Script not running, configuration update is sufficient
        <span class="cov8" title="1">return nil</span>
}

// applyConfigChanges applies configuration changes to a running script
func (sm *ScriptManager) applyConfigChanges(name string, runner *ScriptRunner, oldConfig, newConfig ScriptConfig, changes []ConfigChange) error <span class="cov0" title="0">{
        // For now, implement basic logic - this will be enhanced in subsequent steps
        for _, change := range changes </span><span class="cov0" title="0">{
                switch change.Field </span>{
                case "enabled":<span class="cov0" title="0">
                        if newConfig.Enabled &amp;&amp; !oldConfig.Enabled </span><span class="cov0" title="0">{
                                // Script was disabled, now enabled - but it's already running, so no action needed
                                return nil
                        }</span> else<span class="cov0" title="0"> if !newConfig.Enabled &amp;&amp; oldConfig.Enabled </span><span class="cov0" title="0">{
                                // Script was enabled, now disabled - stop it
                                runner.Stop()
                                delete(sm.scripts, name)
                                return nil
                        }</span>
                case "interval", "path":<span class="cov0" title="0">
                        // Changes that require restart - for now, just note that restart is needed
                        // In a full implementation, this would trigger graceful restart
                        return fmt.Errorf("configuration change (%s) requires restart - not yet implemented", change.Field)</span>
                case "timeout", "max_log_lines":<span class="cov0" title="0">
                        // These changes can be applied without restart
                        // For now, just log that they would be applied
                        continue</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// UpdateScriptWithFeedback updates a script and returns detailed feedback about the changes
func (sm *ScriptManager) UpdateScriptWithFeedback(name string, updatedConfig ScriptConfig) UpdateResponse <span class="cov0" title="0">{
        sm.mutex.Lock()
        defer sm.mutex.Unlock()

        // Find the current configuration
        var oldConfig *ScriptConfig
        for i, sc := range sm.config.Scripts </span><span class="cov0" title="0">{
                if sc.Name == name </span><span class="cov0" title="0">{
                        oldConfig = &amp;sc
                        // Update configuration first
                        updatedConfig.Name = name
                        sm.config.Scripts[i] = updatedConfig
                        break</span>
                }
        }

        <span class="cov0" title="0">if oldConfig == nil </span><span class="cov0" title="0">{
                return UpdateResponse{
                        Success:   false,
                        Message:   fmt.Sprintf("Script %s not found in configuration", name),
                        Applied:   false,
                        Scheduled: false,
                        Changes:   []ConfigChangeInfo{},
                }
        }</span>

        // Detect changes
        <span class="cov0" title="0">changes := sm.detectChanges(*oldConfig, updatedConfig)

        // Convert ConfigChange to ConfigChangeInfo
        changeInfos := make([]ConfigChangeInfo, len(changes))
        allApplied := true
        anyScheduled := false

        for i, change := range changes </span><span class="cov0" title="0">{
                applied := false
                reason := ""

                // Determine if change can be applied immediately
                if runner, exists := sm.scripts[name]; exists </span><span class="cov0" title="0">{
                        if runner.IsExecuting() </span><span class="cov0" title="0">{
                                // Script is executing, schedule for later
                                applied = false
                                anyScheduled = true
                                reason = "Script is currently executing, change will be applied after completion"
                                runner.SetRestartPending(updatedConfig)
                        }</span> else<span class="cov0" title="0"> {
                                // Script is idle, apply immediately based on change type
                                switch change.Field </span>{
                                case "timeout", "max_log_lines":<span class="cov0" title="0">
                                        // These can be applied without restart
                                        applied = true
                                        reason = "Applied immediately"</span>
                                case "enabled":<span class="cov0" title="0">
                                        if updatedConfig.Enabled &amp;&amp; !oldConfig.Enabled </span><span class="cov0" title="0">{
                                                // Re-enabling - already running, no action needed
                                                applied = true
                                                reason = "Script already running"
                                        }</span> else<span class="cov0" title="0"> if !updatedConfig.Enabled &amp;&amp; oldConfig.Enabled </span><span class="cov0" title="0">{
                                                // Disabling - stop the script
                                                runner.Stop()
                                                delete(sm.scripts, name)
                                                applied = true
                                                reason = "Script stopped successfully"
                                        }</span>
                                case "interval", "path":<span class="cov0" title="0">
                                        // These require restart
                                        applied = false
                                        anyScheduled = true
                                        reason = "Requires graceful restart, scheduled for next execution cycle"
                                        runner.SetRestartPending(updatedConfig)</span>
                                }
                        }
                } else<span class="cov0" title="0"> {
                        // Script not running, all changes are effectively "applied"
                        applied = true
                        reason = "Script not currently running, configuration updated"
                }</span>

                <span class="cov0" title="0">if !applied </span><span class="cov0" title="0">{
                        allApplied = false
                }</span>

                <span class="cov0" title="0">changeInfos[i] = ConfigChangeInfo{
                        Field:    change.Field,
                        OldValue: change.OldValue,
                        NewValue: change.NewValue,
                        Applied:  applied,
                        Reason:   reason,
                }</span>
        }

        // Determine overall status
        <span class="cov0" title="0">message := fmt.Sprintf("Script %s updated successfully", name)
        if anyScheduled </span><span class="cov0" title="0">{
                message += " (some changes scheduled for next execution cycle)"
        }</span>

        <span class="cov0" title="0">return UpdateResponse{
                Success:   true,
                Message:   message,
                Applied:   allApplied &amp;&amp; !anyScheduled,
                Scheduled: anyScheduled,
                Changes:   changeInfos,
        }</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// Package service provides core functionality for the run-script-service daemon.
package service

import (
        "context"
        "fmt"
        "sync"
        "time"
)

// ScriptExecutor wraps the existing Executor to support context and arguments
type ScriptExecutor struct {
        executor *Executor
}

// NewScriptExecutor creates a new script executor
func NewScriptExecutor(scriptPath, logPath string, maxLines int) *ScriptExecutor <span class="cov8" title="1">{
        return &amp;ScriptExecutor{
                executor: NewExecutor(scriptPath, logPath, maxLines),
        }
}</span>

// NewScriptExecutorWithoutLogging creates a script executor that doesn't log to files
func NewScriptExecutorWithoutLogging(scriptPath string) *ScriptExecutor <span class="cov8" title="1">{
        return &amp;ScriptExecutor{
                executor: NewExecutor(scriptPath, "", 0), // No logging
        }
}</span>

// Execute executes the script with context support and optional arguments
func (se *ScriptExecutor) Execute(ctx context.Context, args ...string) error <span class="cov0" title="0">{
        result, err := se.ExecuteWithResult(ctx, args...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if result.ExitCode != 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("script exited with code %d", result.ExitCode)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ExecuteWithResult executes the script and returns detailed execution result
func (se *ScriptExecutor) ExecuteWithResult(ctx context.Context, args ...string) (*ExecutionResult, error) <span class="cov8" title="1">{
        // Check if context is already canceled
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, ctx.Err()</span>
        default:<span class="cov8" title="1"></span>
        }

        // Create a channel to signal completion
        <span class="cov8" title="1">resultChan := make(chan *ExecutionResult, 1)

        // Execute in a goroutine to allow for cancellation
        go func() </span><span class="cov8" title="1">{
                result := se.executor.ExecuteScriptWithContext(ctx, args...)
                resultChan &lt;- result
        }</span>()

        // Wait for either completion or cancellation
        <span class="cov8" title="1">select </span>{
        case &lt;-ctx.Done():<span class="cov8" title="1">
                return nil, ctx.Err()</span>
        case result := &lt;-resultChan:<span class="cov8" title="1">
                return result, nil</span>
        }
}

// ScriptRunner manages the execution of a single script
type ScriptRunner struct {
        config           ScriptConfig
        ticker           *time.Ticker
        cancel           context.CancelFunc
        executor         *ScriptExecutor
        logManager       *LogManager
        eventBroadcaster *EventBroadcaster
        running          bool
        executing        bool
        executionMutex   sync.RWMutex
        restartPending   *ScriptConfig
        restartCallback  func(ScriptConfig) error
        mutex            sync.RWMutex
}

// NewScriptRunner creates a new script runner with the given configuration
func NewScriptRunner(config ScriptConfig, logPath string) *ScriptRunner <span class="cov8" title="1">{
        return &amp;ScriptRunner{
                config:           config,
                executor:         NewScriptExecutor(config.Path, logPath, config.MaxLogLines),
                logManager:       nil,
                eventBroadcaster: nil,
                running:          false,
        }
}</span>

// NewScriptRunnerWithLogManager creates a new script runner with LogManager integration
func NewScriptRunnerWithLogManager(config ScriptConfig, logManager *LogManager) *ScriptRunner <span class="cov8" title="1">{
        return &amp;ScriptRunner{
                config:           config,
                executor:         NewScriptExecutorWithoutLogging(config.Path), // No file logging since we use LogManager
                logManager:       logManager,
                eventBroadcaster: nil,
                running:          false,
        }
}</span>

// NewScriptRunnerWithEventBroadcaster creates a new script runner with event broadcasting
func NewScriptRunnerWithEventBroadcaster(config ScriptConfig, logPath string, broadcaster *EventBroadcaster) *ScriptRunner <span class="cov8" title="1">{
        return &amp;ScriptRunner{
                config:           config,
                executor:         NewScriptExecutor(config.Path, logPath, config.MaxLogLines),
                logManager:       nil,
                eventBroadcaster: broadcaster,
                running:          false,
        }
}</span>

// Start begins running the script at the configured interval
func (sr *ScriptRunner) Start(ctx context.Context) <span class="cov8" title="1">{
        sr.mutex.Lock()
        if sr.running </span><span class="cov0" title="0">{
                sr.mutex.Unlock()
                return
        }</span>

        // Create cancellable context
        <span class="cov8" title="1">runCtx, cancel := context.WithCancel(ctx)
        sr.cancel = cancel
        sr.running = true

        // Create ticker for interval execution
        sr.ticker = time.NewTicker(time.Duration(sr.config.Interval) * time.Second)
        sr.mutex.Unlock()

        defer func() </span><span class="cov8" title="1">{
                sr.mutex.Lock()
                sr.running = false
                sr.ticker.Stop()
                sr.mutex.Unlock()
        }</span>()

        // Run script immediately on start
        <span class="cov8" title="1">if err := sr.RunOnce(runCtx); err != nil </span><span class="cov8" title="1">{
                // Log error but continue running - this is expected behavior
                _ = err
        }</span>

        // Then run at intervals
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-runCtx.Done():<span class="cov8" title="1">
                        return</span>
                case &lt;-sr.ticker.C:<span class="cov0" title="0">
                        if err := sr.RunOnce(runCtx); err != nil </span><span class="cov0" title="0">{
                                // Log error but continue running - this is expected behavior
                                _ = err
                        }</span>
                }
        }
}

// Stop stops the script runner
func (sr *ScriptRunner) Stop() <span class="cov8" title="1">{
        sr.mutex.Lock()
        defer sr.mutex.Unlock()

        if sr.running &amp;&amp; sr.cancel != nil </span><span class="cov8" title="1">{
                sr.cancel()
        }</span>
}

// RunOnce executes the script once with optional arguments
func (sr *ScriptRunner) RunOnce(ctx context.Context, args ...string) error <span class="cov8" title="1">{
        startTime := time.Now()

        // Set executing state
        sr.setExecuting(true)
        defer sr.setExecuting(false)

        // Broadcast starting event
        if sr.eventBroadcaster != nil </span><span class="cov8" title="1">{
                startEvent := NewScriptStatusEvent(sr.config.Name, "starting", 0, 0)
                sr.eventBroadcaster.Broadcast(startEvent)
        }</span>

        // Create timeout context if timeout is specified
        <span class="cov8" title="1">if sr.config.Timeout &gt; 0 </span><span class="cov8" title="1">{
                timeoutCtx, cancel := context.WithTimeout(ctx, time.Duration(sr.config.Timeout)*time.Second)
                defer cancel()
                ctx = timeoutCtx
        }</span>

        // Execute the script
        <span class="cov8" title="1">result, err := sr.executor.ExecuteWithResult(ctx, args...)
        duration := time.Since(startTime).Milliseconds()

        // If LogManager is available, use it for structured logging
        if sr.logManager != nil </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        // Broadcast failed event if there was an execution error
                        if sr.eventBroadcaster != nil </span><span class="cov0" title="0">{
                                failedEvent := NewScriptStatusEvent(sr.config.Name, "failed", -1, duration)
                                sr.eventBroadcaster.Broadcast(failedEvent)
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }

                // Create log entry
                <span class="cov8" title="1">logEntry := &amp;LogEntry{
                        Timestamp:  result.Timestamp,
                        ScriptName: sr.config.Name,
                        ExitCode:   result.ExitCode,
                        Stdout:     result.Stdout,
                        Stderr:     result.Stderr,
                        Duration:   duration,
                }

                // Add to log manager
                logger := sr.logManager.GetLogger(sr.config.Name)
                if addErr := logger.AddEntry(logEntry); addErr != nil </span><span class="cov0" title="0">{
                        // Log error but don't fail the execution
                        fmt.Printf("Failed to add log entry: %v\n", addErr)
                }</span>

                // Broadcast completion or failure event
                <span class="cov8" title="1">if sr.eventBroadcaster != nil </span><span class="cov0" title="0">{
                        if result.ExitCode == 0 </span><span class="cov0" title="0">{
                                completedEvent := NewScriptStatusEvent(sr.config.Name, "completed", result.ExitCode, duration)
                                sr.eventBroadcaster.Broadcast(completedEvent)
                        }</span> else<span class="cov0" title="0"> {
                                failedEvent := NewScriptStatusEvent(sr.config.Name, "failed", result.ExitCode, duration)
                                sr.eventBroadcaster.Broadcast(failedEvent)
                        }</span>
                }

                <span class="cov8" title="1">if result.ExitCode != 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("script exited with code %d", result.ExitCode)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        // Handle case with event broadcaster but no log manager
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                // Broadcast failed event if there was an execution error
                if sr.eventBroadcaster != nil </span><span class="cov0" title="0">{
                        failedEvent := NewScriptStatusEvent(sr.config.Name, "failed", -1, duration)
                        sr.eventBroadcaster.Broadcast(failedEvent)
                }</span>
                <span class="cov8" title="1">return err</span>
        }

        // Broadcast completion or failure event
        <span class="cov8" title="1">if sr.eventBroadcaster != nil </span><span class="cov8" title="1">{
                if result.ExitCode == 0 </span><span class="cov8" title="1">{
                        completedEvent := NewScriptStatusEvent(sr.config.Name, "completed", result.ExitCode, duration)
                        sr.eventBroadcaster.Broadcast(completedEvent)
                }</span> else<span class="cov8" title="1"> {
                        failedEvent := NewScriptStatusEvent(sr.config.Name, "failed", result.ExitCode, duration)
                        sr.eventBroadcaster.Broadcast(failedEvent)
                }</span>
        }

        // Check for pending restart after execution
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if sr.restartPending != nil &amp;&amp; sr.restartCallback != nil </span><span class="cov0" title="0">{
                        go sr.restartCallback(*sr.restartPending)
                        sr.restartPending = nil
                }</span>
        }()

        // Fallback to old executor method behavior
        <span class="cov8" title="1">if result.ExitCode != 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("script exited with code %d", result.ExitCode)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// IsRunning returns whether the script runner is currently running
func (sr *ScriptRunner) IsRunning() bool <span class="cov8" title="1">{
        sr.mutex.RLock()
        defer sr.mutex.RUnlock()
        return sr.running
}</span>

// GetConfig returns the script configuration
func (sr *ScriptRunner) GetConfig() ScriptConfig <span class="cov0" title="0">{
        return sr.config
}</span>

// IsExecuting returns whether the script is currently executing
func (sr *ScriptRunner) IsExecuting() bool <span class="cov8" title="1">{
        sr.executionMutex.RLock()
        defer sr.executionMutex.RUnlock()
        return sr.executing
}</span>

// setExecuting sets the execution state (internal method)
func (sr *ScriptRunner) setExecuting(executing bool) <span class="cov8" title="1">{
        sr.executionMutex.Lock()
        sr.executing = executing
        sr.executionMutex.Unlock()
}</span>

// SetRestartPending sets a pending restart configuration
func (sr *ScriptRunner) SetRestartPending(config ScriptConfig) <span class="cov8" title="1">{
        sr.executionMutex.Lock()
        sr.restartPending = &amp;config
        sr.executionMutex.Unlock()
}</span>

// HasRestartPending returns whether there is a restart pending
func (sr *ScriptRunner) HasRestartPending() bool <span class="cov8" title="1">{
        sr.executionMutex.RLock()
        defer sr.executionMutex.RUnlock()
        return sr.restartPending != nil
}</span>

// GetRestartPendingConfig returns the pending restart configuration
func (sr *ScriptRunner) GetRestartPendingConfig() *ScriptConfig <span class="cov8" title="1">{
        sr.executionMutex.RLock()
        defer sr.executionMutex.RUnlock()
        return sr.restartPending
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">// Package service provides core functionality for the run-script-service daemon.
package service

import (
        "context"
        "fmt"
        "time"
)

// Service manages the execution of scripts at regular intervals
type Service struct {
        config     Config
        scriptPath string
        logPath    string
        configPath string
        maxLines   int
        running    bool
        ctx        context.Context
        cancel     context.CancelFunc
        executor   *Executor
}

// NewService creates a new service instance
func NewService(scriptPath, logPath, configPath string, maxLines int) *Service <span class="cov8" title="1">{
        s := &amp;Service{
                config:     Config{Interval: 3600}, // Default 1 hour
                scriptPath: scriptPath,
                logPath:    logPath,
                configPath: configPath,
                maxLines:   maxLines,
                running:    false,
        }

        s.ctx, s.cancel = context.WithCancel(context.Background())
        s.executor = NewExecutor(scriptPath, logPath, maxLines)

        // Load existing config if available
        if err := LoadConfig(configPath, &amp;s.config); err != nil </span><span class="cov0" title="0">{
                // Log error but continue with default config - this is expected behavior
                _ = err
        }</span>

        <span class="cov8" title="1">return s</span>
}

// SetInterval sets the execution interval and saves the configuration
func (s *Service) SetInterval(interval int) error <span class="cov8" title="1">{
        s.config.Interval = interval
        if err := SaveConfig(s.configPath, &amp;s.config); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">fmt.Printf("Interval set to %d seconds\n", interval)
        return nil</span>
}

// Start begins the service execution loop
func (s *Service) Start(ctx context.Context) <span class="cov8" title="1">{
        s.running = true
        fmt.Printf("Service started with %d second interval\n", s.config.Interval)

        ticker := time.NewTicker(time.Duration(s.config.Interval) * time.Second)
        defer ticker.Stop()

        // Execute immediately on start
        s.executeScript()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        fmt.Println("Service stopping...")
                        return</span>
                case &lt;-s.ctx.Done():<span class="cov8" title="1">
                        fmt.Println("Service stopping...")
                        return</span>
                case &lt;-ticker.C:<span class="cov8" title="1">
                        if s.running </span><span class="cov8" title="1">{
                                s.executeScript()
                        }</span>
                }
        }
}

// Stop stops the service
func (s *Service) Stop() <span class="cov8" title="1">{
        s.running = false
        s.cancel()
}</span>

// ShowConfig displays the current configuration
func (s *Service) ShowConfig() <span class="cov8" title="1">{
        fmt.Printf("Current configuration:\n")
        fmt.Printf("  Interval: %d seconds (%s)\n", s.config.Interval, formatDuration(s.config.Interval))
        fmt.Printf("  Script: %s\n", s.scriptPath)
        fmt.Printf("  Log: %s\n", s.logPath)
        fmt.Printf("  Config: %s\n", s.configPath)
}</span>

// executeScript executes the script and logs the result
func (s *Service) executeScript() <span class="cov8" title="1">{
        result := s.executor.ExecuteScript()
        fmt.Printf("Script executed at %s, exit code: %d\n",
                result.Timestamp.Format("2006-01-02 15:04:05"), result.ExitCode)
}</span>

// formatDuration formats seconds into a human-readable duration string
func formatDuration(seconds int) string <span class="cov8" title="1">{
        if seconds &lt; 60 </span><span class="cov8" title="1">{
                return fmt.Sprintf("%ds", seconds)
        }</span> else<span class="cov8" title="1"> if seconds &lt; 3600 </span><span class="cov8" title="1">{
                return fmt.Sprintf("%dm", seconds/60)
        }</span> else<span class="cov8" title="1"> {
                return fmt.Sprintf("%dh", seconds/3600)
        }</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Package service provides core functionality for the run-script-service daemon.
package service

import (
        "bufio"
        "context"
        "io"
        "os"
        "strings"
        "sync"
        "time"
)

// StreamingExecutor defines the interface for executing scripts with streaming output
type StreamingExecutor interface {
        ExecuteWithStreaming(ctx context.Context, args ...string) *ExecutionResult
        SetLogHandler(handler LogHandler)
}

// LogHandler defines the interface for handling streaming log events
type LogHandler interface {
        HandleLogLine(timestamp time.Time, stream string, line string)
        HandleExecutionStart(timestamp time.Time)
        HandleExecutionEnd(timestamp time.Time, exitCode int)
}

// StreamingLogWriter handles real-time log writing with buffering
type StreamingLogWriter struct {
        logPath       string
        file          *os.File
        mutex         sync.Mutex
        buffer        *bufio.Writer
        flushInterval time.Duration
        bufferSize    int
        closed        bool
        stopChan      chan struct{}
        flushTicker   *time.Ticker
}

// NewStreamingLogWriter creates a new streaming log writer
func NewStreamingLogWriter(logPath string, bufferSize int, flushInterval time.Duration) *StreamingLogWriter <span class="cov8" title="1">{
        writer := &amp;StreamingLogWriter{
                logPath:       logPath,
                bufferSize:    bufferSize,
                flushInterval: flushInterval,
                stopChan:      make(chan struct{}),
        }

        // Initialize the writer
        if err := writer.init(); err != nil </span><span class="cov0" title="0">{
                // Return a writer that will fail on WriteStreamLine
                return writer
        }</span>

        <span class="cov8" title="1">return writer</span>
}

// init initializes the log writer
func (w *StreamingLogWriter) init() error <span class="cov8" title="1">{
        w.mutex.Lock()
        defer w.mutex.Unlock()

        if w.closed </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">file, err := os.OpenFile(w.logPath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0600)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">w.file = file
        w.buffer = bufio.NewWriterSize(file, w.bufferSize)

        // Start flush ticker
        w.flushTicker = time.NewTicker(w.flushInterval)
        go w.flushLoop()

        return nil</span>
}

// flushLoop periodically flushes the buffer
func (w *StreamingLogWriter) flushLoop() <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-w.flushTicker.C:<span class="cov0" title="0">
                        w.flush()</span>
                case &lt;-w.stopChan:<span class="cov8" title="1">
                        return</span>
                }
        }
}

// WriteStreamLine writes a single log line with timestamp and stream type
func (w *StreamingLogWriter) WriteStreamLine(timestamp time.Time, streamType string, line string) error <span class="cov8" title="1">{
        w.mutex.Lock()
        defer w.mutex.Unlock()

        if w.closed || w.buffer == nil </span><span class="cov0" title="0">{
                return nil // Fail silently for closed writer
        }</span>

        <span class="cov8" title="1">logEntry := timestamp.Format("2006-01-02 15:04:05") + " [" + streamType + "] " + line + "\n"
        _, err := w.buffer.WriteString(logEntry)
        return err</span>
}

// flush flushes the buffer to disk
func (w *StreamingLogWriter) flush() <span class="cov0" title="0">{
        w.mutex.Lock()
        defer w.mutex.Unlock()

        if w.buffer != nil &amp;&amp; !w.closed </span><span class="cov0" title="0">{
                _ = w.buffer.Flush()
        }</span>
}

// Close closes the streaming log writer
func (w *StreamingLogWriter) Close() error <span class="cov8" title="1">{
        w.mutex.Lock()
        defer w.mutex.Unlock()

        if w.closed </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">w.closed = true
        close(w.stopChan)

        if w.flushTicker != nil </span><span class="cov8" title="1">{
                w.flushTicker.Stop()
        }</span>

        <span class="cov8" title="1">if w.buffer != nil </span><span class="cov8" title="1">{
                _ = w.buffer.Flush()
        }</span>

        <span class="cov8" title="1">if w.file != nil </span><span class="cov8" title="1">{
                return w.file.Close()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// streamOutput processes output from a reader line by line and sends to log handler
func (e *Executor) streamOutput(reader io.Reader, streamType string, handler LogHandler) <span class="cov8" title="1">{
        scanner := bufio.NewScanner(reader)
        for scanner.Scan() </span><span class="cov8" title="1">{
                line := scanner.Text()
                timestamp := time.Now()
                handler.HandleLogLine(timestamp, streamType, line)
        }</span>
}

// StreamingLogHandler integrates streaming output with the log manager
type StreamingLogHandler struct {
        scriptName  string
        logManager  *LogManager
        startTime   time.Time
        stdoutLines []string
        stderrLines []string
        mutex       sync.Mutex
}

// NewStreamingLogHandler creates a new streaming log handler
func NewStreamingLogHandler(scriptName string, logManager *LogManager) *StreamingLogHandler <span class="cov8" title="1">{
        return &amp;StreamingLogHandler{
                scriptName:  scriptName,
                logManager:  logManager,
                stdoutLines: make([]string, 0),
                stderrLines: make([]string, 0),
        }
}</span>

// HandleLogLine processes individual log lines during streaming
func (h *StreamingLogHandler) HandleLogLine(timestamp time.Time, stream string, line string) <span class="cov8" title="1">{
        h.mutex.Lock()
        defer h.mutex.Unlock()

        switch stream </span>{
        case "STDOUT":<span class="cov8" title="1">
                h.stdoutLines = append(h.stdoutLines, line)</span>
        case "STDERR":<span class="cov8" title="1">
                h.stderrLines = append(h.stderrLines, line)</span>
        }
}

// HandleExecutionStart records the start time of execution
func (h *StreamingLogHandler) HandleExecutionStart(timestamp time.Time) <span class="cov8" title="1">{
        h.mutex.Lock()
        defer h.mutex.Unlock()

        h.startTime = timestamp
        h.stdoutLines = make([]string, 0)
        h.stderrLines = make([]string, 0)
}</span>

// HandleExecutionEnd finalizes the log entry and adds it to the log manager
func (h *StreamingLogHandler) HandleExecutionEnd(timestamp time.Time, exitCode int) <span class="cov8" title="1">{
        h.mutex.Lock()
        defer h.mutex.Unlock()

        // Create final log entry with accumulated output
        entry := &amp;LogEntry{
                Timestamp:  h.startTime,
                ScriptName: h.scriptName,
                ExitCode:   exitCode,
                Stdout:     strings.Join(h.stdoutLines, "\n"),
                Stderr:     strings.Join(h.stderrLines, "\n"),
                Duration:   timestamp.Sub(h.startTime).Nanoseconds() / 1e6, // Convert to milliseconds
        }

        // Add to log manager
        logger := h.logManager.GetLogger(h.scriptName)
        _ = logger.AddEntry(entry) // Ignore error for now - could be logged separately
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package web

import (
        "run-script-service/service"
)

// EventBridge connects service events to WebSocket broadcasting
type EventBridge struct {
        wsHub            *WebSocketHub
        eventBroadcaster *service.EventBroadcaster
        events           chan *service.ScriptStatusEvent
        unsubscribe      func()
}

// NewEventBridge creates a bridge between service events and WebSocket hub
func NewEventBridge(wsHub *WebSocketHub, eventBroadcaster *service.EventBroadcaster) *EventBridge <span class="cov8" title="1">{
        events := make(chan *service.ScriptStatusEvent, 100)
        unsubscribe := eventBroadcaster.Subscribe(events)

        bridge := &amp;EventBridge{
                wsHub:            wsHub,
                eventBroadcaster: eventBroadcaster,
                events:           events,
                unsubscribe:      unsubscribe,
        }

        // Start processing events
        go bridge.processEvents()

        return bridge
}</span>

// processEvents processes script status events and broadcasts them via WebSocket
func (eb *EventBridge) processEvents() <span class="cov8" title="1">{
        for event := range eb.events </span><span class="cov8" title="1">{
                // Convert service event to WebSocket message format
                data := map[string]interface{}{
                        "script_name": event.ScriptName,
                        "status":      event.Status,
                        "exit_code":   event.ExitCode,
                        "duration":    event.Duration,
                        "timestamp":   event.Timestamp.Format("2006-01-02T15:04:05Z07:00"),
                }

                // Broadcast via WebSocket
                if err := eb.wsHub.BroadcastMessage("script_status", data); err != nil </span>{<span class="cov0" title="0">
                        // Log error but continue processing
                        // In a production system, you might want proper logging here
                }</span>
        }
}

// Close stops the event bridge
func (eb *EventBridge) Close() <span class="cov8" title="1">{
        if eb.unsubscribe != nil </span><span class="cov8" title="1">{
                eb.unsubscribe()
        }</span>
        <span class="cov8" title="1">close(eb.events)</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package web

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
)

// VuePackageJSON represents the structure of package.json for Vue.js project
type VuePackageJSON struct {
        Name            string            `json:"name"`
        Version         string            `json:"version"`
        Private         bool              `json:"private"`
        Scripts         map[string]string `json:"scripts"`
        Dependencies    map[string]string `json:"dependencies"`
        DevDependencies map[string]string `json:"devDependencies"`
}

// VueFrontendStructure defines the Vue.js frontend project structure
type VueFrontendStructure struct {
        BaseDir string
}

// NewVueFrontendStructure creates a new Vue frontend structure helper
func NewVueFrontendStructure(baseDir string) *VueFrontendStructure <span class="cov8" title="1">{
        return &amp;VueFrontendStructure{
                BaseDir: baseDir,
        }
}</span>

// setupVueFrontendStructure creates the Vue.js frontend directory structure
func setupVueFrontendStructure(frontendDir string) error <span class="cov8" title="1">{
        structure := NewVueFrontendStructure(frontendDir)
        return structure.Create()
}</span>

// Create builds the complete Vue.js frontend structure
func (vfs *VueFrontendStructure) Create() error <span class="cov8" title="1">{
        // Create directory structure
        if err := vfs.createDirectories(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create configuration files
        <span class="cov8" title="1">if err := vfs.createConfigurationFiles(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create source files
        <span class="cov8" title="1">if err := vfs.createSourceFiles(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// createDirectories creates the Vue.js directory structure
func (vfs *VueFrontendStructure) createDirectories() error <span class="cov8" title="1">{
        // Create main frontend directory
        if err := os.MkdirAll(vfs.BaseDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create frontend directory: %w", err)
        }</span>

        // Define Vue.js standard directory structure
        <span class="cov8" title="1">dirs := []string{
                "src",
                "src/components",
                "src/views",
                "src/composables",
                "src/services",
        }

        for _, dir := range dirs </span><span class="cov8" title="1">{
                dirPath := filepath.Join(vfs.BaseDir, dir)
                if err := os.MkdirAll(dirPath, 0755); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create directory %s: %w", dirPath, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// createConfigurationFiles creates configuration files for Vue.js project
func (vfs *VueFrontendStructure) createConfigurationFiles() error <span class="cov8" title="1">{
        configFiles := []func() error{
                vfs.createPackageJSON,
                vfs.createViteConfig,
                vfs.createIndexHTML,
        }

        for _, createFile := range configFiles </span><span class="cov8" title="1">{
                if err := createFile(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// createSourceFiles creates source code files for Vue.js project
func (vfs *VueFrontendStructure) createSourceFiles() error <span class="cov8" title="1">{
        sourceFiles := []func() error{
                vfs.createMainJS,
                vfs.createAppVue,
        }

        for _, createFile := range sourceFiles </span><span class="cov8" title="1">{
                if err := createFile(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// createPackageJSON creates the package.json file with Vue.js dependencies
func (vfs *VueFrontendStructure) createPackageJSON() error <span class="cov8" title="1">{
        packageJSON := VuePackageJSON{
                Name:    "run-script-service-frontend",
                Version: "1.0.0",
                Private: true,
                Scripts: map[string]string{
                        "serve": "vite",
                        "build": "vite build",
                        "dev":   "vite",
                },
                Dependencies: map[string]string{
                        "vue":          "^3.4.0",
                        "vue-router":   "^4.2.0",
                        "@vueuse/core": "^10.7.0",
                },
                DevDependencies: map[string]string{
                        "vite":               "^5.0.0",
                        "@vitejs/plugin-vue": "^4.5.0",
                        "sass":               "^1.69.0",
                },
        }

        data, err := json.MarshalIndent(packageJSON, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal package.json: %w", err)
        }</span>

        <span class="cov8" title="1">packagePath := filepath.Join(vfs.BaseDir, "package.json")
        return os.WriteFile(packagePath, data, 0644)</span>
}

// createViteConfig creates the vite.config.js file
func (vfs *VueFrontendStructure) createViteConfig() error <span class="cov8" title="1">{
        viteConfig := `import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

export default defineConfig({
  plugins: [vue()],
  base: '/static/',
  build: {
    outDir: '../static',
    assetsInlineLimit: 8192,
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['vue', 'vue-router']
        }
      }
    }
  }
})
`
        viteConfigPath := filepath.Join(vfs.BaseDir, "vite.config.js")
        return os.WriteFile(viteConfigPath, []byte(viteConfig), 0644)
}</span>

// createIndexHTML creates the index.html file
func (vfs *VueFrontendStructure) createIndexHTML() error <span class="cov8" title="1">{
        indexHTML := `&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
  &lt;title&gt;Run Script Service&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id="app"&gt;&lt;/div&gt;
  &lt;script type="module" src="/src/main.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
`
        indexPath := filepath.Join(vfs.BaseDir, "index.html")
        return os.WriteFile(indexPath, []byte(indexHTML), 0644)
}</span>

// createMainJS creates the main.js file
func (vfs *VueFrontendStructure) createMainJS() error <span class="cov8" title="1">{
        mainJS := `import { createApp } from 'vue'
import App from './App.vue'

createApp(App).mount('#app')
`
        mainJSPath := filepath.Join(vfs.BaseDir, "src", "main.js")
        return os.WriteFile(mainJSPath, []byte(mainJS), 0644)
}</span>

// createAppVue creates the App.vue file
func (vfs *VueFrontendStructure) createAppVue() error <span class="cov8" title="1">{
        appVue := `&lt;template&gt;
  &lt;div id="app"&gt;
    &lt;h1&gt;Run Script Service&lt;/h1&gt;
    &lt;p&gt;Vue.js frontend is loading...&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: 'App'
}
&lt;/script&gt;

&lt;style&gt;
#app {
  font-family: Avenir, Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
  color: #2c3e50;
  margin-top: 60px;
}
&lt;/style&gt;
`
        appVuePath := filepath.Join(vfs.BaseDir, "src", "App.vue")
        return os.WriteFile(appVuePath, []byte(appVue), 0644)
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">// Package web provides file operation handlers for the HTTP API server
package web

import (
        "fmt"
        "net/http"
        "strings"

        "github.com/gin-gonic/gin"

        "run-script-service/service"
)

// FileOperationRequest represents a file operation request
type FileOperationRequest struct {
        Path    string `json:"path,omitempty"`
        Content string `json:"content,omitempty"`
}

// ValidationRequest represents a script validation request
type ValidationRequest struct {
        Content string `json:"content" binding:"required"`
}

// ValidationResponse represents validation results
type ValidationResponse struct {
        Valid  bool     `json:"valid"`
        Issues []string `json:"issues,omitempty"`
}

// SetFileManager sets the file manager for the web server
func (ws *WebServer) SetFileManager(fm *service.FileManager) <span class="cov8" title="1">{
        ws.fileManager = fm
        ws.setupFileRoutes()
}</span>

// setupFileRoutes configures file operation API routes with authentication
func (ws *WebServer) setupFileRoutes() <span class="cov8" title="1">{
        if ws.fileManager == nil || ws.authMiddleware == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Create protected file routes group
        <span class="cov8" title="1">api := ws.router.Group("/api")
        protected := api.Group("/")
        protected.Use(ws.authMiddleware.RequireAuth())

        // File operation endpoints (protected)
        protected.GET("/files/*path", ws.handleGetFile)
        protected.PUT("/files/*path", ws.handlePutFile)
        protected.POST("/files/validate", ws.handleValidateFile)
        protected.GET("/files-list/*path", ws.handleListFiles)</span>
}

// handleGetFile reads and returns a file's content
func (ws *WebServer) handleGetFile(c *gin.Context) <span class="cov8" title="1">{
        if ws.fileManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "File manager not initialized",
                })
                return
        }</span>

        // Extract path from URL parameter
        <span class="cov8" title="1">filePath := c.Param("path")
        if filePath == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   "File path is required",
                })
                return
        }</span>

        // Remove leading slash from path parameter
        <span class="cov8" title="1">if filePath[0] == '/' </span><span class="cov8" title="1">{
                filePath = filePath[1:]
        }</span>

        <span class="cov8" title="1">fileContent, err := ws.fileManager.ReadFile(filePath)
        if err != nil </span><span class="cov8" title="1">{
                statusCode := http.StatusInternalServerError
                if err.Error() == "access denied: path not allowed" </span><span class="cov8" title="1">{
                        statusCode = http.StatusForbidden
                }</span> else<span class="cov8" title="1"> if strings.Contains(err.Error(), "no such file or directory") </span><span class="cov8" title="1">{
                        statusCode = http.StatusNotFound
                }</span>

                <span class="cov8" title="1">c.JSON(statusCode, APIResponse{
                        Success: false,
                        Error:   err.Error(),
                })
                return</span>
        }

        <span class="cov8" title="1">c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data:    fileContent,
        })</span>
}

// handlePutFile writes content to a file
func (ws *WebServer) handlePutFile(c *gin.Context) <span class="cov8" title="1">{
        if ws.fileManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "File manager not initialized",
                })
                return
        }</span>

        // Extract path from URL parameter
        <span class="cov8" title="1">filePath := c.Param("path")
        if filePath == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   "File path is required",
                })
                return
        }</span>

        // Remove leading slash from path parameter
        <span class="cov8" title="1">if filePath[0] == '/' </span><span class="cov8" title="1">{
                filePath = filePath[1:]
        }</span>

        <span class="cov8" title="1">var request FileOperationRequest
        if err := c.ShouldBindJSON(&amp;request); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   fmt.Sprintf("Invalid request body: %v", err),
                })
                return
        }</span>

        // Use content from request body
        <span class="cov8" title="1">content := request.Content

        err := ws.fileManager.WriteFile(filePath, content)
        if err != nil </span><span class="cov8" title="1">{
                statusCode := http.StatusInternalServerError
                if err.Error() == "access denied: path not allowed" </span><span class="cov8" title="1">{
                        statusCode = http.StatusForbidden
                }</span>

                <span class="cov8" title="1">c.JSON(statusCode, APIResponse{
                        Success: false,
                        Error:   err.Error(),
                })
                return</span>
        }

        <span class="cov8" title="1">c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data: map[string]interface{}{
                        "message": fmt.Sprintf("File '%s' written successfully", filePath),
                        "path":    filePath,
                },
        })</span>
}

// handleValidateFile validates script syntax
func (ws *WebServer) handleValidateFile(c *gin.Context) <span class="cov8" title="1">{
        if ws.fileManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "File manager not initialized",
                })
                return
        }</span>

        <span class="cov8" title="1">var request ValidationRequest
        if err := c.ShouldBindJSON(&amp;request); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   fmt.Sprintf("Invalid request body: %v", err),
                })
                return
        }</span>

        <span class="cov8" title="1">issues := ws.fileManager.ValidateScriptSyntax(request.Content)

        response := ValidationResponse{
                Valid:  len(issues) == 0,
                Issues: issues,
        }

        c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data:    response,
        })</span>
}

// handleListFiles lists files in a directory
func (ws *WebServer) handleListFiles(c *gin.Context) <span class="cov8" title="1">{
        if ws.fileManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "File manager not initialized",
                })
                return
        }</span>

        // Extract path from URL parameter
        <span class="cov8" title="1">dirPath := c.Param("path")
        if dirPath == "" </span><span class="cov0" title="0">{
                dirPath = "." // Default to current directory
        }</span>

        // Remove leading slash from path parameter
        <span class="cov8" title="1">if dirPath[0] == '/' </span><span class="cov8" title="1">{
                dirPath = dirPath[1:]
        }</span>

        <span class="cov8" title="1">files, err := ws.fileManager.ListFiles(dirPath)
        if err != nil </span><span class="cov8" title="1">{
                statusCode := http.StatusInternalServerError
                if err.Error() == "access denied: path not allowed" </span><span class="cov8" title="1">{
                        statusCode = http.StatusForbidden
                }</span> else<span class="cov0" title="0"> if strings.Contains(err.Error(), "no such file or directory") </span><span class="cov0" title="0">{
                        statusCode = http.StatusNotFound
                }</span>

                <span class="cov8" title="1">c.JSON(statusCode, APIResponse{
                        Success: false,
                        Error:   err.Error(),
                })
                return</span>
        }

        // Convert file info to JSON-serializable format
        <span class="cov8" title="1">fileList := make([]map[string]interface{}, len(files))
        for i, file := range files </span><span class="cov8" title="1">{
                fileList[i] = map[string]interface{}{
                        "name":     file.Name(),
                        "size":     file.Size(),
                        "mode":     file.Mode().String(),
                        "is_dir":   file.IsDir(),
                        "mod_time": file.ModTime().Unix(),
                }
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data:    fileList,
        })</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Package web provides script file management handlers for the HTTP API server
package web

import (
        "fmt"
        "net/http"

        "github.com/gin-gonic/gin"

        "run-script-service/service"
)

// CreateScriptFileRequest represents a request to create a new script file
type CreateScriptFileRequest struct {
        Name     string `json:"name" binding:"required"`
        Filename string `json:"filename" binding:"required"`
        Content  string `json:"content" binding:"required"`
        Interval int    `json:"interval" binding:"required"`
        Enabled  bool   `json:"enabled"`
        Timeout  int    `json:"timeout"`
}

// UpdateScriptFileRequest represents a request to update a script file
type UpdateScriptFileRequest struct {
        Content string `json:"content" binding:"required"`
}

// setupScriptFileRoutes configures script file management API routes with authentication
func (ws *WebServer) setupScriptFileRoutes() <span class="cov8" title="1">{
        if ws.scriptFileManager == nil </span><span class="cov8" title="1">{
                return
        }</span>

        // Create script file routes group
        <span class="cov8" title="1">api := ws.router.Group("/api")

        // If auth middleware is available, use protected routes
        if ws.authMiddleware != nil </span><span class="cov0" title="0">{
                protected := api.Group("/")
                protected.Use(ws.authMiddleware.RequireAuth())

                // Script file management endpoints (protected)
                protected.GET("/script-files", ws.handleGetScriptFiles)
                protected.GET("/script-files/:filename", ws.handleGetScriptFile)
                protected.POST("/script-files", ws.handleCreateScriptFile)
                protected.PUT("/script-files/:filename", ws.handleUpdateScriptFile)
                protected.DELETE("/script-files/:filename", ws.handleDeleteScriptFile)
        }</span> else<span class="cov8" title="1"> {
                // For testing - unprotected routes
                api.GET("/script-files", ws.handleGetScriptFiles)
                api.GET("/script-files/:filename", ws.handleGetScriptFile)
                api.POST("/script-files", ws.handleCreateScriptFile)
                api.PUT("/script-files/:filename", ws.handleUpdateScriptFile)
                api.DELETE("/script-files/:filename", ws.handleDeleteScriptFile)
        }</span>
}

// handleGetScriptFiles lists all script files
func (ws *WebServer) handleGetScriptFiles(c *gin.Context) <span class="cov8" title="1">{
        if ws.scriptFileManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "Script file manager not initialized",
                })
                return
        }</span>

        <span class="cov8" title="1">scripts, err := ws.scriptFileManager.ListScripts()
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   fmt.Sprintf("Failed to list scripts: %v", err),
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data:    scripts,
        })</span>
}

// handleGetScriptFile retrieves a single script file with its content
func (ws *WebServer) handleGetScriptFile(c *gin.Context) <span class="cov8" title="1">{
        filename := c.Param("filename")

        if ws.scriptFileManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "Script file manager not initialized",
                })
                return
        }</span>

        <span class="cov8" title="1">script, err := ws.scriptFileManager.GetScript(filename)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusNotFound, APIResponse{
                        Success: false,
                        Error:   err.Error(),
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data:    script,
        })</span>
}

// handleCreateScriptFile creates a new script file and configuration
func (ws *WebServer) handleCreateScriptFile(c *gin.Context) <span class="cov8" title="1">{
        var request CreateScriptFileRequest

        if err := c.ShouldBindJSON(&amp;request); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   fmt.Sprintf("Invalid request: %v", err),
                })
                return
        }</span>

        <span class="cov8" title="1">if ws.scriptFileManager == nil || ws.scriptManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "Script managers not initialized",
                })
                return
        }</span>

        // Create the script file
        <span class="cov8" title="1">if err := ws.scriptFileManager.CreateScript(request.Filename, request.Content); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   err.Error(),
                })
                return
        }</span>

        // Create script configuration
        <span class="cov8" title="1">scriptConfig := service.ScriptConfig{
                Name:        request.Name,
                Filename:    request.Filename,
                Path:        ws.scriptFileManager.GetScriptPath(request.Filename),
                Interval:    request.Interval,
                Enabled:     request.Enabled,
                MaxLogLines: 100, // Default value
                Timeout:     request.Timeout,
        }

        // Add to script manager
        if err := ws.scriptManager.AddScript(scriptConfig); err != nil </span><span class="cov0" title="0">{
                // If adding config failed, cleanup the created file
                ws.scriptFileManager.DeleteScript(request.Filename)

                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   fmt.Sprintf("Failed to add script configuration: %v", err),
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusCreated, APIResponse{
                Success: true,
                Data:    map[string]string{"message": "Script created successfully"},
        })</span>
}

// handleUpdateScriptFile updates the content of an existing script file
func (ws *WebServer) handleUpdateScriptFile(c *gin.Context) <span class="cov8" title="1">{
        filename := c.Param("filename")

        var request UpdateScriptFileRequest
        if err := c.ShouldBindJSON(&amp;request); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   fmt.Sprintf("Invalid request: %v", err),
                })
                return
        }</span>

        <span class="cov8" title="1">if ws.scriptFileManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "Script file manager not initialized",
                })
                return
        }</span>

        <span class="cov8" title="1">if err := ws.scriptFileManager.UpdateScript(filename, request.Content); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   err.Error(),
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data:    map[string]string{"message": "Script updated successfully"},
        })</span>
}

// handleDeleteScriptFile deletes a script file and removes it from configuration
func (ws *WebServer) handleDeleteScriptFile(c *gin.Context) <span class="cov8" title="1">{
        filename := c.Param("filename")

        if ws.scriptFileManager == nil || ws.scriptManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "Script managers not initialized",
                })
                return
        }</span>

        // Find and remove from script manager first (by filename)
        <span class="cov8" title="1">scripts, err := ws.scriptManager.GetScripts()
        if err == nil </span><span class="cov8" title="1">{
                for _, script := range scripts </span><span class="cov8" title="1">{
                        if script.Filename == filename </span><span class="cov8" title="1">{
                                ws.scriptManager.RemoveScript(script.Name)
                                break</span>
                        }
                }
        }

        // Delete the file
        <span class="cov8" title="1">if err := ws.scriptFileManager.DeleteScript(filename); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   err.Error(),
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data:    map[string]string{"message": "Script deleted successfully"},
        })</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// Package web provides HTTP API server functionality
package web

import (
        "context"
        "embed"
        "fmt"
        "io"
        "io/fs"
        "log"
        "net/http"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "time"

        "github.com/gin-contrib/cors"
        "github.com/gin-gonic/gin"

        "run-script-service/auth"
        "run-script-service/service"
)

//go:embed frontend/dist/*
var frontendFS embed.FS

// WebServer represents the HTTP API server
type WebServer struct {
        router            *gin.Engine
        service           *service.Service
        scriptManager     *service.ScriptManager
        scriptFileManager *service.ScriptFileManager
        fileManager       *service.FileManager
        wsHub             *WebSocketHub
        systemMonitor     *service.SystemMonitor
        authHandler       *auth.AuthHandler
        authMiddleware    *auth.AuthMiddleware
        debugLogger       *service.DebugLogger
        port              int
}

// APIResponse represents the standard API response format
type APIResponse struct {
        Success bool        `json:"success"`
        Data    interface{} `json:"data,omitempty"`
        Error   string      `json:"error,omitempty"`
}

// LogEntry represents a structured log entry for the frontend
type LogEntry struct {
        Timestamp string `json:"timestamp"`
        Message   string `json:"message"`
        Level     string `json:"level"` // "info", "warning", "error"
        Script    string `json:"script,omitempty"`
}

// enhancedRecoveryMiddleware provides enhanced error handling with structured JSON responses
func enhancedRecoveryMiddleware() gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                defer func() </span><span class="cov8" title="1">{
                        if err := recover(); err != nil </span><span class="cov8" title="1">{
                                // Log the panic with request context for debugging
                                log.Printf("Panic recovered: %v - Request: %s %s, User-Agent: %s, X-Request-ID: %s",
                                        err,
                                        c.Request.Method,
                                        c.Request.URL.Path,
                                        c.GetHeader("User-Agent"),
                                        c.GetHeader("X-Request-ID"))

                                // Return structured JSON error response
                                c.JSON(http.StatusInternalServerError, APIResponse{
                                        Success: false,
                                        Error:   "Internal server error",
                                })
                                c.Abort()
                        }</span>
                }()
                <span class="cov8" title="1">c.Next()</span>
        }
}

// NewWebServer creates a new web server instance
func NewWebServer(svc *service.Service, port int, secretKey string) *WebServer <span class="cov8" title="1">{
        // Set Gin to release mode for production
        gin.SetMode(gin.ReleaseMode)

        router := gin.New()

        // Add middleware
        router.Use(gin.Logger())
        router.Use(enhancedRecoveryMiddleware())
        router.Use(cors.Default())

        // Create WebSocket hub
        wsHub := NewWebSocketHub()
        go wsHub.Run()

        // Initialize authentication
        authHandler := auth.NewAuthHandler(secretKey)
        authMiddleware := auth.NewAuthMiddleware(authHandler.GetSessionManager())

        server := &amp;WebServer{
                router:         router,
                service:        svc,
                wsHub:          wsHub,
                authHandler:    authHandler,
                authMiddleware: authMiddleware,
                debugLogger:    service.NewDebugLogger(),
                port:           port,
        }

        // Setup routes
        server.setupRoutes()

        return server
}</span>

// SetScriptManager sets the script manager for the web server
func (ws *WebServer) SetScriptManager(sm *service.ScriptManager) <span class="cov8" title="1">{
        ws.scriptManager = sm
}</span>

// SetScriptFileManager sets the script file manager for the web server
func (ws *WebServer) SetScriptFileManager(sfm *service.ScriptFileManager) <span class="cov0" title="0">{
        ws.scriptFileManager = sfm
}</span>

// GetWebSocketHub returns the WebSocket hub for broadcasting messages
func (ws *WebServer) GetWebSocketHub() *WebSocketHub <span class="cov0" title="0">{
        return ws.wsHub
}</span>

// SetSystemMonitor sets the system monitor for the web server
func (ws *WebServer) SetSystemMonitor(monitor *service.SystemMonitor) <span class="cov8" title="1">{
        ws.systemMonitor = monitor
}</span>

// StartSystemMetricsBroadcasting starts periodic system metrics broadcasting via WebSocket
func (ws *WebServer) StartSystemMetricsBroadcasting(ctx context.Context, interval time.Duration) error <span class="cov8" title="1">{
        if ws.systemMonitor == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("system monitor not configured")
        }</span>

        // Create event publisher that broadcasts via WebSocket
        <span class="cov8" title="1">publisher := func(msgType string, data map[string]interface{}) error </span><span class="cov0" title="0">{
                if ws.wsHub != nil </span><span class="cov0" title="0">{
                        return ws.wsHub.BroadcastMessage(msgType, data)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        // Start periodic broadcasting in a goroutine
        <span class="cov8" title="1">go ws.systemMonitor.StartPeriodicBroadcasting(ctx, interval, publisher)

        return nil</span>
}

// BroadcastConfigUpdate broadcasts configuration update events to all connected WebSocket clients
func (ws *WebServer) BroadcastConfigUpdate(event service.ConfigUpdateEvent) <span class="cov8" title="1">{
        if ws.wsHub == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">data := map[string]interface{}{
                "script_name": event.ScriptName,
                "status":      event.Status,
                "changes":     event.Changes,
                "applied":     event.Applied,
                "scheduled":   event.Scheduled,
                "message":     event.Message,
                "timestamp":   event.Timestamp,
        }

        if err := ws.wsHub.BroadcastMessage("config_update", data); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to broadcast config update: %v", err)
        }</span>
}

// setupRoutes configures all API routes
func (ws *WebServer) setupRoutes() <span class="cov8" title="1">{
        // Create a sub filesystem for the dist directory
        distFS, err := fs.Sub(frontendFS, "frontend/dist")
        if err != nil </span><span class="cov0" title="0">{
                ws.debugLogger.Debugf("embed fs.Sub failed: %v, using fallback", err)
                // Fallback to file system if embed fails (development mode)
                ws.router.Static("/static", "./web/frontend/dist")
                ws.router.GET("/", func(c *gin.Context) </span><span class="cov0" title="0">{
                        c.File("./web/frontend/dist/index.html")
                }</span>)
        } else<span class="cov8" title="1"> {
                ws.debugLogger.Debugf("Using embedded filesystem")
                // Use embedded filesystem for static files (public)
                ws.router.StaticFS("/static", http.FS(distFS))

                // Login route (unprotected)
                ws.router.GET("/login", func(c *gin.Context) </span><span class="cov0" title="0">{
                        indexFile, err := distFS.Open("index.html")
                        if err != nil </span><span class="cov0" title="0">{
                                ws.debugLogger.Debugf("Failed to open embedded index.html: %v", err)
                                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to load frontend"})
                                return
                        }</span>
                        <span class="cov0" title="0">defer indexFile.Close()

                        c.Header("Content-Type", "text/html")
                        http.ServeContent(c.Writer, c.Request, "index.html", time.Now(), indexFile.(io.ReadSeeker))</span>
                })

                // Root route serves index.html from embedded FS (protected)
                <span class="cov8" title="1">ws.router.GET("/", ws.authMiddleware.RequireAuth(), func(c *gin.Context) </span><span class="cov0" title="0">{
                        indexFile, err := distFS.Open("index.html")
                        if err != nil </span><span class="cov0" title="0">{
                                ws.debugLogger.Debugf("Failed to open embedded index.html: %v", err)
                                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to load frontend"})
                                return
                        }</span>
                        <span class="cov0" title="0">defer indexFile.Close()

                        c.Header("Content-Type", "text/html")
                        http.ServeContent(c.Writer, c.Request, "index.html", time.Now(), indexFile.(io.ReadSeeker))</span>
                })

                // Serve index.html for SPA routes (NoRoute handler) - protected
                <span class="cov8" title="1">ws.router.NoRoute(func(c *gin.Context) </span><span class="cov8" title="1">{
                        path := c.Request.URL.Path

                        // If it's an API route, let it 404
                        if strings.HasPrefix(path, "/api/") || strings.HasPrefix(path, "/ws") </span><span class="cov8" title="1">{
                                c.JSON(http.StatusNotFound, gin.H{"error": "Not found"})
                                return
                        }</span>

                        // Check authentication for SPA routes
                        <span class="cov8" title="1">if !ws.authMiddleware.IsAuthenticated(c) </span><span class="cov8" title="1">{
                                c.Redirect(http.StatusFound, "/login")
                                return
                        }</span>

                        // For all other routes, serve index.html (Vue.js SPA)
                        <span class="cov0" title="0">indexFile, err := distFS.Open("index.html")
                        if err != nil </span><span class="cov0" title="0">{
                                ws.debugLogger.Debugf("Failed to open embedded index.html in NoRoute: %v", err)
                                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to load frontend"})
                                return
                        }</span>
                        <span class="cov0" title="0">defer indexFile.Close()

                        c.Header("Content-Type", "text/html")
                        http.ServeContent(c.Writer, c.Request, "index.html", time.Now(), indexFile.(io.ReadSeeker))</span>
                })
        }

        // WebSocket endpoint (protected)
        <span class="cov8" title="1">ws.router.GET("/ws", ws.authMiddleware.RequireAuth(), func(c *gin.Context) </span><span class="cov8" title="1">{
                HandleWebSocket(ws.wsHub, c)
        }</span>)

        <span class="cov8" title="1">api := ws.router.Group("/api")

        // Authentication routes (unprotected)
        auth := api.Group("/auth")
        auth.POST("/login", ws.authHandler.Login)
        auth.POST("/logout", ws.authHandler.Logout)
        auth.GET("/status", ws.authHandler.AuthStatus)

        // Protected routes (require authentication)
        protected := api.Group("/")
        protected.Use(ws.authMiddleware.RequireAuth())

        // System status endpoint
        protected.GET("/status", ws.handleStatus)

        // Script management endpoints
        protected.GET("/scripts", ws.handleGetScripts)
        protected.POST("/scripts", ws.handlePostScript)
        protected.POST("/scripts/template", ws.handlePostScriptTemplate)
        protected.GET("/scripts/:name", ws.handleGetScript)
        protected.PUT("/scripts/:name", ws.handleUpdateScript)
        protected.DELETE("/scripts/:name", ws.handleDeleteScript)
        protected.POST("/scripts/:name/run", ws.handleRunScript)
        protected.POST("/scripts/:name/enable", ws.handleEnableScript)
        protected.POST("/scripts/:name/disable", ws.handleDisableScript)

        // Log management endpoints
        protected.GET("/logs", ws.handleGetLogs)
        protected.GET("/logs/:script", ws.handleGetScriptLogs)
        protected.GET("/logs/raw/:script", ws.handleGetRawLogs) // New simple endpoint
        protected.DELETE("/logs/:script", ws.handleClearScriptLogs)

        // Configuration endpoints
        protected.GET("/config", ws.handleGetConfig)
        protected.PUT("/config", ws.handleUpdateConfig)

        // Git project discovery endpoints
        protected.GET("/git-projects", ws.handleGetGitProjects)

        // Script file management routes (if available)
        ws.setupScriptFileRoutes()</span>
}

// handleStatus returns system status information
func (ws *WebServer) handleStatus(c *gin.Context) <span class="cov8" title="1">{
        uptime := "Unknown"
        runningScripts := 0
        totalScripts := 0

        // Get script counts if script manager is available
        if ws.scriptManager != nil </span><span class="cov0" title="0">{
                config := ws.scriptManager.GetConfig()
                totalScripts = len(config.Scripts)

                // Count running/enabled scripts
                for _, script := range config.Scripts </span><span class="cov0" title="0">{
                        if script.Enabled &amp;&amp; ws.scriptManager.IsScriptRunning(script.Name) </span><span class="cov0" title="0">{
                                runningScripts++
                        }</span>
                }
        }

        // Calculate uptime if system monitor is available
        <span class="cov8" title="1">if ws.systemMonitor != nil </span><span class="cov0" title="0">{
                uptimeStr := ws.systemMonitor.GetUptime()
                if uptimeStr != "" </span><span class="cov0" title="0">{
                        uptime = uptimeStr
                }</span>
        }

        <span class="cov8" title="1">statusData := map[string]interface{}{
                "status":         "running",
                "uptime":         uptime,
                "runningScripts": runningScripts,
                "totalScripts":   totalScripts,
        }

        c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data:    statusData,
        })</span>
}

// handleGetScripts returns all scripts
func (ws *WebServer) handleGetScripts(c *gin.Context) <span class="cov8" title="1">{
        if ws.scriptManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "Script manager not initialized",
                })
                return
        }</span>

        // Get script configs from the manager
        <span class="cov8" title="1">var scripts []map[string]interface{}
        for _, scriptConfig := range ws.scriptManager.GetConfig().Scripts </span><span class="cov8" title="1">{
                running := ws.scriptManager.IsScriptRunning(scriptConfig.Name)

                scripts = append(scripts, map[string]interface{}{
                        "name":          scriptConfig.Name,
                        "path":          scriptConfig.Path,
                        "interval":      scriptConfig.Interval,
                        "enabled":       scriptConfig.Enabled,
                        "max_log_lines": scriptConfig.MaxLogLines,
                        "timeout":       scriptConfig.Timeout,
                        "running":       running,
                })
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data:    scripts,
        })</span>
}

// handlePostScript creates a new script
func (ws *WebServer) handlePostScript(c *gin.Context) <span class="cov8" title="1">{
        if ws.scriptManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "Script manager not initialized",
                })
                return
        }</span>

        <span class="cov8" title="1">var scriptConfig service.ScriptConfig
        if err := c.ShouldBindJSON(&amp;scriptConfig); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   fmt.Sprintf("Invalid request body: %v", err),
                })
                return
        }</span>

        // Validate required fields
        <span class="cov8" title="1">if scriptConfig.Name == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   "Script name is required",
                })
                return
        }</span>

        <span class="cov8" title="1">if scriptConfig.Path == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   "Script path is required",
                })
                return
        }</span>

        // Set defaults for optional fields
        <span class="cov8" title="1">if scriptConfig.Interval &lt;= 0 </span><span class="cov0" title="0">{
                scriptConfig.Interval = 60 // Default to 1 minute
        }</span>
        <span class="cov8" title="1">if scriptConfig.MaxLogLines &lt;= 0 </span><span class="cov0" title="0">{
                scriptConfig.MaxLogLines = 100 // Default to 100 lines
        }</span>

        // Add the script
        <span class="cov8" title="1">if err := ws.scriptManager.AddScript(scriptConfig); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusConflict, APIResponse{
                        Success: false,
                        Error:   err.Error(),
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusCreated, APIResponse{
                Success: true,
                Data: map[string]interface{}{
                        "name":          scriptConfig.Name,
                        "path":          scriptConfig.Path,
                        "interval":      scriptConfig.Interval,
                        "enabled":       scriptConfig.Enabled,
                        "max_log_lines": scriptConfig.MaxLogLines,
                        "timeout":       scriptConfig.Timeout,
                },
        })</span>
}

// handlePostScriptTemplate creates a new script from a template
func (ws *WebServer) handlePostScriptTemplate(c *gin.Context) <span class="cov8" title="1">{
        if ws.scriptManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "Script manager not initialized",
                })
                return
        }</span>

        <span class="cov8" title="1">var template service.ScriptTemplate
        if err := c.ShouldBindJSON(&amp;template); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   fmt.Sprintf("Invalid request body: %v", err),
                })
                return
        }</span>

        // Create script generator
        <span class="cov8" title="1">scriptGenerator := service.NewScriptGenerator()

        // Generate script from template
        generatedScript, err := scriptGenerator.GenerateScript(&amp;template)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   fmt.Sprintf("Script generation failed: %v", err),
                })
                return
        }</span>

        // Convert generated script to ScriptConfig for script manager
        <span class="cov8" title="1">scriptConfig := service.ScriptConfig{
                Name:        generatedScript.Name,
                Path:        generatedScript.Path,
                Interval:    convertIntervalToSeconds(generatedScript.Config.Interval),
                Enabled:     true,
                MaxLogLines: generatedScript.Config.MaxLogLines,
                Timeout:     generatedScript.Config.Timeout,
        }

        // Set defaults for optional fields
        if scriptConfig.Interval &lt;= 0 </span><span class="cov0" title="0">{
                scriptConfig.Interval = 3600 // Default to 1 hour
        }</span>
        <span class="cov8" title="1">if scriptConfig.MaxLogLines &lt;= 0 </span><span class="cov0" title="0">{
                scriptConfig.MaxLogLines = 100
        }</span>

        // Write the generated script to file
        <span class="cov8" title="1">if err := writeScriptToFile(generatedScript.Path, generatedScript.Content); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   fmt.Sprintf("Failed to write script file: %v", err),
                })
                return
        }</span>

        // Add the script to the manager
        <span class="cov8" title="1">if err := ws.scriptManager.AddScript(scriptConfig); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusConflict, APIResponse{
                        Success: false,
                        Error:   err.Error(),
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data: map[string]interface{}{
                        "name":         generatedScript.Name,
                        "path":         generatedScript.Path,
                        "type":         template.Type,
                        "project_path": template.ProjectPath,
                        "config":       generatedScript.Config,
                },
        })</span>
}

// Helper function to convert interval string to seconds
func convertIntervalToSeconds(interval string) int <span class="cov8" title="1">{
        // Simple conversion for common intervals
        switch interval </span>{
        case "5m":<span class="cov0" title="0">
                return 300</span>
        case "30m":<span class="cov8" title="1">
                return 1800</span>
        case "1h":<span class="cov8" title="1">
                return 3600</span>
        case "6h":<span class="cov0" title="0">
                return 21600</span>
        case "24h":<span class="cov0" title="0">
                return 86400</span>
        default:<span class="cov0" title="0">
                return 3600</span> // Default to 1 hour
        }
}

// Helper function to write script content to file
func writeScriptToFile(path, content string) error <span class="cov8" title="1">{
        file, err := os.OpenFile(path, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0755)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        _, err = file.WriteString(content)
        return err</span>
}

// handleRunScript executes a script once
func (ws *WebServer) handleRunScript(c *gin.Context) <span class="cov8" title="1">{
        if ws.scriptManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "Script manager not initialized",
                })
                return
        }</span>

        <span class="cov8" title="1">scriptName := c.Param("name")
        if scriptName == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   "Script name is required",
                })
                return
        }</span>

        // Run the script with a timeout context
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(c.Request.Context(), 30*time.Second)
        defer cancel()

        if err := ws.scriptManager.RunScriptOnce(ctx, scriptName); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusNotFound, APIResponse{
                        Success: false,
                        Error:   err.Error(),
                })
                return
        }</span>

        // Note: Logs are now handled via raw file access in /logs/raw/:script endpoint

        <span class="cov0" title="0">c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data: map[string]interface{}{
                        "message": fmt.Sprintf("Script %s executed successfully", scriptName),
                        "script":  scriptName,
                },
        })</span>
}

// handleGetScript returns information about a specific script
func (ws *WebServer) handleGetScript(c *gin.Context) <span class="cov8" title="1">{
        if ws.scriptManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "Script manager not initialized",
                })
                return
        }</span>

        <span class="cov8" title="1">scriptName := c.Param("name")
        if scriptName == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   "Script name is required",
                })
                return
        }</span>

        // Find the script in configuration
        <span class="cov8" title="1">config := ws.scriptManager.GetConfig()
        for _, scriptConfig := range config.Scripts </span><span class="cov8" title="1">{
                if scriptConfig.Name == scriptName </span><span class="cov8" title="1">{
                        running := ws.scriptManager.IsScriptRunning(scriptConfig.Name)

                        scriptData := map[string]interface{}{
                                "name":          scriptConfig.Name,
                                "path":          scriptConfig.Path,
                                "interval":      scriptConfig.Interval,
                                "enabled":       scriptConfig.Enabled,
                                "max_log_lines": scriptConfig.MaxLogLines,
                                "timeout":       scriptConfig.Timeout,
                                "running":       running,
                        }

                        c.JSON(http.StatusOK, APIResponse{
                                Success: true,
                                Data:    scriptData,
                        })
                        return
                }</span>
        }

        <span class="cov8" title="1">c.JSON(http.StatusNotFound, APIResponse{
                Success: false,
                Error:   fmt.Sprintf("Script '%s' not found", scriptName),
        })</span>
}

// handleUpdateScript updates a script configuration
func (ws *WebServer) handleUpdateScript(c *gin.Context) <span class="cov8" title="1">{
        if ws.scriptManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "Script manager not initialized",
                })
                return
        }</span>

        <span class="cov8" title="1">scriptName := c.Param("name")
        if scriptName == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   "Script name is required",
                })
                return
        }</span>

        <span class="cov8" title="1">var updateData service.ScriptConfig
        if err := c.ShouldBindJSON(&amp;updateData); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   fmt.Sprintf("Invalid request body: %v", err),
                })
                return
        }</span>

        // Set defaults for optional fields
        <span class="cov8" title="1">if updateData.Interval &lt;= 0 </span><span class="cov0" title="0">{
                updateData.Interval = 60 // Default to 1 minute
        }</span>
        <span class="cov8" title="1">if updateData.MaxLogLines &lt;= 0 </span><span class="cov0" title="0">{
                updateData.MaxLogLines = 100 // Default to 100 lines
        }</span>

        // Update the script with detailed feedback
        <span class="cov8" title="1">updateResult := ws.scriptManager.UpdateScriptWithFeedback(scriptName, updateData)

        if !updateResult.Success </span><span class="cov8" title="1">{
                // Broadcast failure event
                ws.BroadcastConfigUpdate(service.ConfigUpdateEvent{
                        Type:       "config_update",
                        ScriptName: scriptName,
                        Status:     "failed",
                        Changes:    []service.ConfigChangeInfo{},
                        Applied:    false,
                        Scheduled:  false,
                        Message:    updateResult.Message,
                        Timestamp:  time.Now().Format(time.RFC3339),
                })

                c.JSON(http.StatusNotFound, APIResponse{
                        Success: false,
                        Error:   updateResult.Message,
                })
                return
        }</span>

        // Broadcast successful update event
        <span class="cov8" title="1">status := "applied"
        if updateResult.Scheduled </span><span class="cov0" title="0">{
                status = "scheduled"
        }</span>

        <span class="cov8" title="1">ws.BroadcastConfigUpdate(service.ConfigUpdateEvent{
                Type:       "config_update",
                ScriptName: scriptName,
                Status:     status,
                Changes:    updateResult.Changes,
                Applied:    updateResult.Applied,
                Scheduled:  updateResult.Scheduled,
                Message:    updateResult.Message,
                Timestamp:  time.Now().Format(time.RFC3339),
        })

        c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data: map[string]interface{}{
                        "message":       updateResult.Message,
                        "script":        scriptName,
                        "applied":       updateResult.Applied,
                        "scheduled":     updateResult.Scheduled,
                        "changes":       updateResult.Changes,
                        "name":          updateData.Name,
                        "path":          updateData.Path,
                        "interval":      updateData.Interval,
                        "enabled":       updateData.Enabled,
                        "max_log_lines": updateData.MaxLogLines,
                        "timeout":       updateData.Timeout,
                },
        })</span>
}

// handleDeleteScript removes a script
func (ws *WebServer) handleDeleteScript(c *gin.Context) <span class="cov8" title="1">{
        if ws.scriptManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "Script manager not initialized",
                })
                return
        }</span>

        <span class="cov8" title="1">scriptName := c.Param("name")
        if scriptName == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   "Script name is required",
                })
                return
        }</span>

        // Remove the script
        <span class="cov8" title="1">if err := ws.scriptManager.RemoveScript(scriptName); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusNotFound, APIResponse{
                        Success: false,
                        Error:   err.Error(),
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data: map[string]interface{}{
                        "message": fmt.Sprintf("Script %s deleted successfully", scriptName),
                        "script":  scriptName,
                },
        })</span>
}

// handleScriptToggle handles both enable and disable script operations
func (ws *WebServer) handleScriptToggle(c *gin.Context, enable bool) <span class="cov8" title="1">{
        if ws.scriptManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "Script manager not initialized",
                })
                return
        }</span>

        <span class="cov8" title="1">scriptName := c.Param("name")
        if scriptName == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   "Script name is required",
                })
                return
        }</span>

        <span class="cov8" title="1">var err error
        var action string
        if enable </span><span class="cov8" title="1">{
                err = ws.scriptManager.EnableScript(scriptName)
                action = "enabled"
        }</span> else<span class="cov8" title="1"> {
                err = ws.scriptManager.DisableScript(scriptName)
                action = "disabled"
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, APIResponse{
                        Success: false,
                        Error:   err.Error(),
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data: map[string]interface{}{
                        "message": fmt.Sprintf("Script %s %s successfully", scriptName, action),
                        "script":  scriptName,
                        "enabled": enable,
                },
        })</span>
}

// handleEnableScript enables a script
func (ws *WebServer) handleEnableScript(c *gin.Context) <span class="cov8" title="1">{
        ws.handleScriptToggle(c, true)
}</span>

// handleDisableScript disables a script
func (ws *WebServer) handleDisableScript(c *gin.Context) <span class="cov8" title="1">{
        ws.handleScriptToggle(c, false)
}</span>

// handleGetLogs returns structured log entries as expected by frontend
func (ws *WebServer) handleGetLogs(c *gin.Context) <span class="cov8" title="1">{
        scriptName := c.Query("script")
        limit := c.DefaultQuery("limit", "50")

        // Parse limit
        maxEntries := 50
        if parsedLimit, err := strconv.Atoi(limit); err == nil &amp;&amp; parsedLimit &gt; 0 </span><span class="cov8" title="1">{
                maxEntries = parsedLimit
        }</span>

        // If no script specified, return aggregated logs from all scripts
        <span class="cov8" title="1">if scriptName == "" </span><span class="cov8" title="1">{
                allLogs := ws.getAggregatedLogs(maxEntries)
                c.JSON(http.StatusOK, APIResponse{
                        Success: true,
                        Data:    allLogs,
                })
                return
        }</span>

        // Get logs for specific script
        <span class="cov0" title="0">scriptLogs := ws.getScriptLogs(scriptName, maxEntries)
        c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data:    scriptLogs,
        })</span>
}

// handleGetScriptLogs returns raw log content for a specific script
func (ws *WebServer) handleGetScriptLogs(c *gin.Context) <span class="cov8" title="1">{
        scriptName := c.Param("script")
        if scriptName == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   "Script name is required",
                })
                return
        }</span>

        // Get log file path
        <span class="cov8" title="1">dir, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                dir, _ = os.Getwd()
        }</span> else<span class="cov8" title="1"> {
                dir = filepath.Dir(dir)
        }</span>

        <span class="cov8" title="1">logFile := filepath.Join(dir, fmt.Sprintf("%s.log", scriptName))

        // Check if log file exists
        if _, err := os.Stat(logFile); os.IsNotExist(err) </span><span class="cov8" title="1">{
                c.JSON(http.StatusOK, APIResponse{
                        Success: true,
                        Data: map[string]interface{}{
                                "content": "",
                                "script":  scriptName,
                                "message": "No log file found",
                        },
                })
                return
        }</span>

        // Read raw log file content
        <span class="cov0" title="0">content, err := os.ReadFile(logFile)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   fmt.Sprintf("Failed to read log file: %v", err),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data: map[string]interface{}{
                        "content": string(content),
                        "script":  scriptName,
                },
        })</span>
}

// handleClearScriptLogs clears logs for a specific script (simplified)
func (ws *WebServer) handleClearScriptLogs(c *gin.Context) <span class="cov0" title="0">{
        scriptName := c.Param("script")
        if scriptName == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   "Script name is required",
                })
                return
        }</span>

        // Get log file path
        <span class="cov0" title="0">dir, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                dir, _ = os.Getwd()
        }</span> else<span class="cov0" title="0"> {
                dir = filepath.Dir(dir)
        }</span>

        <span class="cov0" title="0">logFile := filepath.Join(dir, fmt.Sprintf("%s.log", scriptName))

        // Clear the log file by truncating it
        if err := os.Truncate(logFile, 0); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   fmt.Sprintf("Failed to clear log file: %v", err),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data: map[string]interface{}{
                        "message": fmt.Sprintf("Logs cleared for script %s", scriptName),
                        "script":  scriptName,
                },
        })</span>
}

// handleGetRawLogs returns raw log file content (simple approach)
func (ws *WebServer) handleGetRawLogs(c *gin.Context) <span class="cov0" title="0">{
        scriptName := c.Param("script")
        if scriptName == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   "Script name is required",
                })
                return
        }</span>

        // Get log file path
        <span class="cov0" title="0">dir, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                dir, _ = os.Getwd()
        }</span> else<span class="cov0" title="0"> {
                dir = filepath.Dir(dir)
        }</span>

        <span class="cov0" title="0">logFile := filepath.Join(dir, fmt.Sprintf("%s.log", scriptName))

        // Check if log file exists
        if _, err := os.Stat(logFile); os.IsNotExist(err) </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, APIResponse{
                        Success: true,
                        Data: map[string]interface{}{
                                "script":  scriptName,
                                "content": "",
                                "message": "No log file found",
                        },
                })
                return
        }</span>

        // Read log file content
        <span class="cov0" title="0">content, err := os.ReadFile(logFile)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   fmt.Sprintf("Failed to read log file: %v", err),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data: map[string]interface{}{
                        "script":  scriptName,
                        "content": string(content),
                },
        })</span>
}

// ConfigResponse represents the configuration format expected by the frontend
type ConfigResponse struct {
        WebPort      int    `json:"webPort"`
        Interval     string `json:"interval"`
        LogRetention int    `json:"logRetention"`
        AutoRefresh  bool   `json:"autoRefresh"`
}

// handleGetConfig returns system configuration
func (ws *WebServer) handleGetConfig(c *gin.Context) <span class="cov0" title="0">{
        if ws.scriptManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "Script manager not initialized",
                })
                return
        }</span>

        <span class="cov0" title="0">config := ws.scriptManager.GetConfig()

        // Convert to frontend-expected format
        response := ConfigResponse{
                WebPort:      config.WebPort,
                Interval:     "1h", // default interval as string
                LogRetention: 100,  // default log retention
                AutoRefresh:  true, // default auto-refresh setting
        }

        c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data:    response,
        })</span>
}

// handleUpdateConfig updates system configuration
func (ws *WebServer) handleUpdateConfig(c *gin.Context) <span class="cov8" title="1">{
        if ws.scriptManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "Script manager not initialized",
                })
                return
        }</span>

        <span class="cov8" title="1">var updateData map[string]interface{}
        if err := c.ShouldBindJSON(&amp;updateData); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   fmt.Sprintf("Invalid request body: %v", err),
                })
                return
        }</span>

        // Get current configuration
        <span class="cov8" title="1">config := ws.scriptManager.GetConfig()

        // Update web port if provided (handle both camelCase and snake_case)
        if webPort, ok := updateData["webPort"]; ok </span><span class="cov0" title="0">{
                if port, isFloat := webPort.(float64); isFloat </span><span class="cov0" title="0">{
                        if port &gt;= 1 &amp;&amp; port &lt;= 65535 </span><span class="cov0" title="0">{
                                config.WebPort = int(port)
                        }</span> else<span class="cov0" title="0"> {
                                c.JSON(http.StatusBadRequest, APIResponse{
                                        Success: false,
                                        Error:   "Web port must be between 1 and 65535",
                                })
                                return
                        }</span>
                } else<span class="cov0" title="0"> {
                        c.JSON(http.StatusBadRequest, APIResponse{
                                Success: false,
                                Error:   "Web port must be a number",
                        })
                        return
                }</span>
        } else<span class="cov8" title="1"> if webPort, ok := updateData["web_port"]; ok </span><span class="cov8" title="1">{
                if port, isFloat := webPort.(float64); isFloat </span><span class="cov8" title="1">{
                        if port &gt;= 1 &amp;&amp; port &lt;= 65535 </span><span class="cov8" title="1">{
                                config.WebPort = int(port)
                        }</span> else<span class="cov0" title="0"> {
                                c.JSON(http.StatusBadRequest, APIResponse{
                                        Success: false,
                                        Error:   "Web port must be between 1 and 65535",
                                })
                                return
                        }</span>
                } else<span class="cov0" title="0"> {
                        c.JSON(http.StatusBadRequest, APIResponse{
                                Success: false,
                                Error:   "Web port must be a number",
                        })
                        return
                }</span>
        }

        // Save updated configuration
        <span class="cov8" title="1">if err := ws.scriptManager.SaveConfig(); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   fmt.Sprintf("Failed to save configuration: %v", err),
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data: map[string]interface{}{
                        "message": "Configuration updated successfully",
                        "config":  config,
                },
        })</span>
}

// Start starts the web server
func (ws *WebServer) Start() error <span class="cov0" title="0">{
        addr := fmt.Sprintf(":%d", ws.port)
        return ws.router.Run(addr)
}</span>

// getAggregatedLogs returns logs from all scripts in LogEntry format
func (ws *WebServer) getAggregatedLogs(maxEntries int) []LogEntry <span class="cov8" title="1">{
        // Initialize with non-nil slice to ensure JSON serializes as [] not null
        allLogs := make([]LogEntry, 0)

        if ws.scriptManager == nil </span><span class="cov8" title="1">{
                return allLogs
        }</span>

        // Get all configured scripts
        <span class="cov0" title="0">config := ws.scriptManager.GetConfig()
        for _, script := range config.Scripts </span><span class="cov0" title="0">{
                scriptLogs := ws.getScriptLogs(script.Name, maxEntries)
                allLogs = append(allLogs, scriptLogs...)
        }</span>

        // If we have more logs than requested, truncate to most recent
        <span class="cov0" title="0">if len(allLogs) &gt; maxEntries </span><span class="cov0" title="0">{
                allLogs = allLogs[len(allLogs)-maxEntries:]
        }</span>

        <span class="cov0" title="0">return allLogs</span>
}

// getScriptLogs returns logs for a specific script in LogEntry format
func (ws *WebServer) getScriptLogs(scriptName string, maxEntries int) []LogEntry <span class="cov0" title="0">{
        // Initialize with non-nil slice to ensure JSON serializes as [] not null
        logs := make([]LogEntry, 0)

        // Get log file path
        dir, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                dir, _ = os.Getwd()
        }</span> else<span class="cov0" title="0"> {
                dir = filepath.Dir(dir)
        }</span>

        <span class="cov0" title="0">logFile := filepath.Join(dir, fmt.Sprintf("%s.log", scriptName))

        // Check if log file exists
        if _, err := os.Stat(logFile); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return logs // Return empty array
        }</span>

        // Read log file content
        <span class="cov0" title="0">content, err := os.ReadFile(logFile)
        if err != nil </span><span class="cov0" title="0">{
                return logs // Return empty array on error
        }</span>

        // Parse log content into LogEntry objects
        <span class="cov0" title="0">lines := strings.Split(string(content), "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Simple log parsing - assume format: timestamp level message
                // For now, create basic LogEntry objects from raw log lines
                <span class="cov0" title="0">logEntry := LogEntry{
                        Timestamp: time.Now().Format(time.RFC3339), // Default timestamp
                        Message:   line,
                        Level:     "info", // Default level
                        Script:    scriptName,
                }

                // Try to extract timestamp and level from line if possible
                if len(line) &gt; 19 &amp;&amp; line[10] == 'T' </span><span class="cov0" title="0">{ // ISO timestamp format
                        if timestampEnd := strings.Index(line[20:], " "); timestampEnd &gt; 0 </span><span class="cov0" title="0">{
                                logEntry.Timestamp = line[:20+timestampEnd]
                                remaining := strings.TrimSpace(line[20+timestampEnd:])

                                // Check for level indicators
                                if strings.Contains(strings.ToLower(remaining), "error") </span><span class="cov0" title="0">{
                                        logEntry.Level = "error"
                                }</span> else<span class="cov0" title="0"> if strings.Contains(strings.ToLower(remaining), "warn") </span><span class="cov0" title="0">{
                                        logEntry.Level = "warning"
                                }</span>

                                <span class="cov0" title="0">logEntry.Message = remaining</span>
                        }
                }

                <span class="cov0" title="0">logs = append(logs, logEntry)</span>
        }

        // Limit to maxEntries (most recent)
        <span class="cov0" title="0">if len(logs) &gt; maxEntries </span><span class="cov0" title="0">{
                logs = logs[len(logs)-maxEntries:]
        }</span>

        <span class="cov0" title="0">return logs</span>
}

// handleGetGitProjects discovers and returns Git projects in a specified directory
func (ws *WebServer) handleGetGitProjects(c *gin.Context) <span class="cov8" title="1">{
        // Get directory parameter from query
        dir := c.DefaultQuery("dir", os.Getenv("HOME"))
        if dir == "" </span><span class="cov0" title="0">{
                dir = os.Getenv("HOME") // Fallback to home directory
        }</span>

        // Create Git discovery service
        <span class="cov8" title="1">gitService := service.NewGitDiscoveryService()
        projects, err := gitService.DiscoverGitProjects(dir)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   fmt.Sprintf("Failed to discover Git projects: %v", err),
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data: map[string]interface{}{
                        "projects": projects,
                },
        })</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package web

import (
        "fmt"
        "os"
        "path/filepath"
)

// VueBuildManager handles the Vue.js frontend build process
type VueBuildManager struct {
        ProjectRoot string
        FrontendDir string
        StaticDir   string
}

// NewVueBuildManager creates a new Vue build manager
func NewVueBuildManager(projectRoot string) *VueBuildManager <span class="cov8" title="1">{
        return &amp;VueBuildManager{
                ProjectRoot: projectRoot,
                FrontendDir: filepath.Join(projectRoot, "web", "frontend"),
                StaticDir:   filepath.Join(projectRoot, "web", "frontend", "dist"),
        }
}</span>

// InitializeFrontendProject sets up the complete Vue.js frontend project structure
func (vbm *VueBuildManager) InitializeFrontendProject() error <span class="cov0" title="0">{
        // Create main frontend directory
        if err := os.MkdirAll(vbm.FrontendDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create frontend directory: %w", err)
        }</span>

        // Initialize TypeScript Vue project (new approach)
        <span class="cov0" title="0">if err := vbm.initializeTypeScriptProject(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize TypeScript project: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// initializeTypeScriptProject sets up a complete TypeScript + Vue.js project
func (vbm *VueBuildManager) initializeTypeScriptProject() error <span class="cov0" title="0">{
        // For now, we assume the TypeScript frontend files are already in place
        // This method validates that all required TypeScript files exist

        // Check if TypeScript files exist (they should have been created by external process)
        requiredFiles := []string{
                "package.json",
                "tsconfig.json",
                "vite.config.ts",
                "vitest.config.ts",
                "index.html",
                "src/main.ts",
                "src/App.vue",
                "src/router/index.ts",
                "src/types/api.ts",
                "src/services/api.ts",
                "src/composables/useScripts.ts",
                "src/composables/useLogs.ts",
                "src/composables/useSystemMetrics.ts",
                "src/composables/useWebSocket.ts",
                "src/views/Dashboard.vue",
                "src/style.css",
                "tests/setup.ts",
                "tests/unit/services/api.test.ts",
                "tests/unit/composables/useScripts.test.ts",
                "tests/unit/components/Dashboard.test.ts",
        }

        missingFiles := []string{}
        for _, file := range requiredFiles </span><span class="cov0" title="0">{
                filePath := filepath.Join(vbm.FrontendDir, file)
                if _, err := os.Stat(filePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        missingFiles = append(missingFiles, file)
                }</span>
        }

        <span class="cov0" title="0">if len(missingFiles) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("missing required TypeScript files: %v", missingFiles)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetFrontendDir returns the frontend directory path
func (vbm *VueBuildManager) GetFrontendDir() string <span class="cov8" title="1">{
        return vbm.FrontendDir
}</span>

// GetStaticDir returns the static directory path
func (vbm *VueBuildManager) GetStaticDir() string <span class="cov8" title="1">{
        return vbm.StaticDir
}</span>

// CheckFrontendExists checks if the frontend directory structure exists
func (vbm *VueBuildManager) CheckFrontendExists() bool <span class="cov0" title="0">{
        requiredPaths := []string{
                filepath.Join(vbm.FrontendDir, "package.json"),
                filepath.Join(vbm.FrontendDir, "src", "main.ts"),
                filepath.Join(vbm.FrontendDir, "src", "App.vue"),
                filepath.Join(vbm.FrontendDir, "tsconfig.json"),
                filepath.Join(vbm.FrontendDir, "vite.config.ts"),
        }

        for _, path := range requiredPaths </span><span class="cov0" title="0">{
                if _, err := os.Stat(path); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package web

import (
        "encoding/json"
        "log"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/gorilla/websocket"
)

// WebSocketMessage represents a message sent through WebSocket
type WebSocketMessage struct {
        Type      string                 `json:"type"`
        Timestamp time.Time              `json:"timestamp"`
        Data      map[string]interface{} `json:"data"`
}

var upgrader = websocket.Upgrader{
        CheckOrigin: func(r *http.Request) bool <span class="cov0" title="0">{
                return true // Allow connections from any origin
        }</span>,
}

// WebSocketClient represents a connected WebSocket client
type WebSocketClient struct {
        hub  *WebSocketHub
        conn *websocket.Conn
        send chan []byte
}

// WebSocketHub manages WebSocket connections and message broadcasting
type WebSocketHub struct {
        // Registered clients
        clients map[*WebSocketClient]bool

        // Inbound messages from the clients
        broadcast chan []byte

        // Register requests from the clients
        register chan *WebSocketClient

        // Unregister requests from clients
        unregister chan *WebSocketClient

        // Maximum number of concurrent connections
        maxConnections int
}

const (
        // MaxWebSocketConnections defines the maximum number of concurrent WebSocket connections
        MaxWebSocketConnections = 100
)

// NewWebSocketHub creates a new WebSocket hub
func NewWebSocketHub() *WebSocketHub <span class="cov8" title="1">{
        return &amp;WebSocketHub{
                broadcast:      make(chan []byte, 256),
                register:       make(chan *WebSocketClient),
                unregister:     make(chan *WebSocketClient),
                clients:        make(map[*WebSocketClient]bool),
                maxConnections: MaxWebSocketConnections,
        }
}</span>

// Run starts the WebSocket hub
func (h *WebSocketHub) Run() <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                case client := &lt;-h.register:<span class="cov0" title="0">
                        // Check connection limit
                        if len(h.clients) &gt;= h.maxConnections </span><span class="cov0" title="0">{
                                log.Printf("WebSocket connection limit reached (%d), rejecting new connection", h.maxConnections)
                                close(client.send)
                                client.conn.Close()
                        }</span> else<span class="cov0" title="0"> {
                                h.clients[client] = true
                                log.Printf("WebSocket client connected, total: %d", len(h.clients))
                        }</span>

                case client := &lt;-h.unregister:<span class="cov0" title="0">
                        if _, ok := h.clients[client]; ok </span><span class="cov0" title="0">{
                                delete(h.clients, client)
                                close(client.send)
                                log.Printf("WebSocket client disconnected, total: %d", len(h.clients))
                        }</span>

                case message := &lt;-h.broadcast:<span class="cov8" title="1">
                        for client := range h.clients </span><span class="cov0" title="0">{
                                select </span>{
                                case client.send &lt;- message:<span class="cov0" title="0"></span>
                                default:<span class="cov0" title="0">
                                        // Client can't receive message, disconnect it
                                        close(client.send)
                                        delete(h.clients, client)
                                        client.conn.Close()</span>
                                }
                        }
                }
        }
}

// BroadcastMessage sends a message to all connected clients
func (h *WebSocketHub) BroadcastMessage(msgType string, data map[string]interface{}) error <span class="cov8" title="1">{
        message := WebSocketMessage{
                Type:      msgType,
                Timestamp: time.Now(),
                Data:      data,
        }

        messageBytes, err := json.Marshal(message)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">select </span>{
        case h.broadcast &lt;- messageBytes:<span class="cov8" title="1"></span>
        default:<span class="cov0" title="0"></span>
                // Channel is full, skip message
        }

        <span class="cov8" title="1">return nil</span>
}

// GetConnectionCount returns the number of active connections
func (h *WebSocketHub) GetConnectionCount() int <span class="cov0" title="0">{
        return len(h.clients)
}</span>

// HandleWebSocket handles WebSocket connections
func HandleWebSocket(hub *WebSocketHub, c *gin.Context) <span class="cov8" title="1">{
        conn, err := upgrader.Upgrade(c.Writer, c.Request, nil)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("WebSocket upgrade error: %v", err)
                return
        }</span>

        <span class="cov0" title="0">client := &amp;WebSocketClient{
                hub:  hub,
                conn: conn,
                send: make(chan []byte, 256),
        }

        client.hub.register &lt;- client

        // Start goroutines for reading and writing
        go client.writePump()
        go client.readPump()</span>
}

// readPump handles reading messages from the WebSocket connection
func (c *WebSocketClient) readPump() <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                c.hub.unregister &lt;- c
                c.conn.Close()
        }</span>()

        <span class="cov0" title="0">c.conn.SetReadLimit(512)
        c.conn.SetReadDeadline(time.Now().Add(60 * time.Second))
        c.conn.SetPongHandler(func(string) error </span><span class="cov0" title="0">{
                c.conn.SetReadDeadline(time.Now().Add(60 * time.Second))
                return nil
        }</span>)

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                _, _, err := c.conn.ReadMessage()
                if err != nil </span><span class="cov0" title="0">{
                        if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) </span><span class="cov0" title="0">{
                                log.Printf("WebSocket error: %v", err)
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
        }
}

// writePump handles writing messages to the WebSocket connection
func (c *WebSocketClient) writePump() <span class="cov0" title="0">{
        ticker := time.NewTicker(54 * time.Second)
        defer func() </span><span class="cov0" title="0">{
                ticker.Stop()
                c.conn.Close()
        }</span>()

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case message, ok := &lt;-c.send:<span class="cov0" title="0">
                        c.conn.SetWriteDeadline(time.Now().Add(10 * time.Second))
                        if !ok </span><span class="cov0" title="0">{
                                c.conn.WriteMessage(websocket.CloseMessage, []byte{})
                                return
                        }</span>

                        <span class="cov0" title="0">w, err := c.conn.NextWriter(websocket.TextMessage)
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">w.Write(message)

                        // Add queued messages to the current message
                        n := len(c.send)
                        for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                                w.Write([]byte{'\n'})
                                w.Write(&lt;-c.send)
                        }</span>

                        <span class="cov0" title="0">if err := w.Close(); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>

                case &lt;-ticker.C:<span class="cov0" title="0">
                        c.conn.SetWriteDeadline(time.Now().Add(10 * time.Second))
                        if err := c.conn.WriteMessage(websocket.PingMessage, nil); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
