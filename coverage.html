
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>run-script-service: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">

				<option value="file0">run-script-service/main.go (39.5%)</option>

				<option value="file1">run-script-service/mocks/filesystem.go (26.7%)</option>

				<option value="file2">run-script-service/service/config.go (51.3%)</option>

				<option value="file3">run-script-service/service/event.go (100.0%)</option>

				<option value="file4">run-script-service/service/executor.go (77.3%)</option>

				<option value="file5">run-script-service/service/file_manager.go (85.1%)</option>

				<option value="file6">run-script-service/service/log_manager.go (33.0%)</option>

				<option value="file7">run-script-service/service/monitor.go (70.4%)</option>

				<option value="file8">run-script-service/service/script_manager.go (58.2%)</option>

				<option value="file9">run-script-service/service/script_runner.go (72.8%)</option>

				<option value="file10">run-script-service/service/service.go (89.5%)</option>

				<option value="file11">run-script-service/web/event_bridge.go (100.0%)</option>

				<option value="file12">run-script-service/web/frontend_setup.go (82.6%)</option>

				<option value="file13">run-script-service/web/handlers_files.go (77.8%)</option>

				<option value="file14">run-script-service/web/server.go (52.6%)</option>

				<option value="file15">run-script-service/web/vue_build_manager.go (13.6%)</option>

				<option value="file16">run-script-service/web/websocket.go (16.9%)</option>

				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>

				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>

			</div>
		</div>
		<div id="content">

		<pre class="file" id="file0" style="display: none">// Package main provides the run-script-service daemon executable.
package main

import (
        "context"
        "fmt"
        "os"
        "os/exec"
        "os/signal"
        "path/filepath"
        "strconv"
        "strings"
        "syscall"
        "time"

        "run-script-service/service"
        "run-script-service/web"
)

// CommandResult represents the result of command processing
type CommandResult struct {
        shouldRunService bool
        webMode          bool
}

// handleCommand processes command line arguments and returns appropriate action
func handleCommand(args []string, scriptPath, logPath, configPath string, maxLines int) (CommandResult, error) <span class="cov8" title="1">{
        svc := service.NewService(scriptPath, logPath, configPath, maxLines)

        if len(args) &lt; 2 </span><span class="cov8" title="1">{
                return CommandResult{shouldRunService: true, webMode: true}, nil
        }</span>

        <span class="cov8" title="1">command := args[1]

        switch command </span>{
        case "run":<span class="cov8" title="1">
                // Always enable web mode by default
                result := CommandResult{shouldRunService: true, webMode: true}
                return result, nil</span>
        case "set-interval":<span class="cov8" title="1">
                if len(args) != 3 </span><span class="cov8" title="1">{
                        return CommandResult{shouldRunService: false},
                                fmt.Errorf("usage: ./run-script-service set-interval &lt;interval&gt;\nexamples: 30s, 5m, 1h, 3600")
                }</span>
                <span class="cov8" title="1">interval, err := parseInterval(args[2])
                if err != nil </span><span class="cov8" title="1">{
                        return CommandResult{shouldRunService: false},
                                fmt.Errorf("invalid interval: %v", err)
                }</span>
                <span class="cov8" title="1">if err := svc.SetInterval(interval); err != nil </span><span class="cov0" title="0">{
                        return CommandResult{shouldRunService: false},
                                fmt.Errorf("error setting interval: %v", err)
                }</span>
                <span class="cov8" title="1">return CommandResult{shouldRunService: false}, nil</span>
        case "show-config":<span class="cov8" title="1">
                svc.ShowConfig()
                return CommandResult{shouldRunService: false}, nil</span>
        case "add-script":<span class="cov8" title="1">
                return handleAddScript(args[2:], configPath)</span>
        case "list-scripts":<span class="cov8" title="1">
                return handleListScripts(configPath)</span>
        case "enable-script":<span class="cov8" title="1">
                if len(args) != 3 </span><span class="cov0" title="0">{
                        return CommandResult{shouldRunService: false},
                                fmt.Errorf("usage: ./run-script-service enable-script &lt;script-name&gt;")
                }</span>
                <span class="cov8" title="1">return handleEnableScript(args[2], configPath)</span>
        case "disable-script":<span class="cov8" title="1">
                if len(args) != 3 </span><span class="cov0" title="0">{
                        return CommandResult{shouldRunService: false},
                                fmt.Errorf("usage: ./run-script-service disable-script &lt;script-name&gt;")
                }</span>
                <span class="cov8" title="1">return handleDisableScript(args[2], configPath)</span>
        case "remove-script":<span class="cov8" title="1">
                if len(args) != 3 </span><span class="cov0" title="0">{
                        return CommandResult{shouldRunService: false},
                                fmt.Errorf("usage: ./run-script-service remove-script &lt;script-name&gt;")
                }</span>
                <span class="cov8" title="1">return handleRemoveScript(args[2], configPath)</span>
        case "run-script":<span class="cov8" title="1">
                if len(args) != 3 </span><span class="cov0" title="0">{
                        return CommandResult{shouldRunService: false},
                                fmt.Errorf("usage: ./run-script-service run-script &lt;script-name&gt;")
                }</span>
                <span class="cov8" title="1">return handleRunScript(args[2], configPath)</span>
        case "logs":<span class="cov8" title="1">
                return handleLogs(args[2:], configPath)</span>
        case "clear-logs":<span class="cov8" title="1">
                return handleClearLogs(args[2:], configPath)</span>
        case "set-web-port":<span class="cov8" title="1">
                if len(args) != 3 </span><span class="cov0" title="0">{
                        return CommandResult{shouldRunService: false},
                                fmt.Errorf("usage: ./run-script-service set-web-port &lt;port&gt;")
                }</span>
                <span class="cov8" title="1">return handleSetWebPort(args[2], configPath)</span>
        case "daemon":<span class="cov0" title="0">
                if len(args) &lt; 3 </span><span class="cov0" title="0">{
                        return CommandResult{shouldRunService: false},
                                fmt.Errorf("usage: ./run-script-service daemon &lt;start|stop|status|restart|logs&gt;")
                }</span>
                <span class="cov0" title="0">return handleDaemonCommand(args[2], configPath)</span>
        default:<span class="cov8" title="1">
                availableCommands := "run, set-interval, show-config, add-script, " +
                        "list-scripts, enable-script, disable-script, remove-script, run-script, logs, clear-logs, set-web-port, daemon"
                return CommandResult{shouldRunService: false},
                        fmt.Errorf("unknown command: %s\navailable commands: %s", command, availableCommands)</span>
        }
}

func main() <span class="cov0" title="0">{
        // Get paths relative to executable
        dir, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                dir, _ = os.Getwd()
        }</span> else<span class="cov0" title="0"> {
                dir = filepath.Dir(dir)
        }</span>

        <span class="cov0" title="0">scriptPath := filepath.Join(dir, "run.sh")
        logPath := filepath.Join(dir, "run.log")
        configPath := filepath.Join(dir, "service_config.json")
        maxLines := 100

        result, err := handleCommand(os.Args, scriptPath, logPath, configPath, maxLines)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("%v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if result.shouldRunService </span><span class="cov0" title="0">{
                if result.webMode </span><span class="cov0" title="0">{
                        runMultiScriptServiceWithWeb(configPath)
                }</span> else<span class="cov0" title="0"> {
                        runMultiScriptService(configPath)
                }</span>
        }
}

func runService(svc *service.Service) <span class="cov0" title="0">{
        // Set up signal handling
        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGTERM, syscall.SIGINT)

        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        // Start service in a goroutine
        done := make(chan bool)
        go func() </span><span class="cov0" title="0">{
                svc.Start(ctx)
                done &lt;- true
        }</span>()

        // Wait for signal or service completion
        <span class="cov0" title="0">select </span>{
        case &lt;-sigChan:<span class="cov0" title="0">
                fmt.Println("Received shutdown signal")
                svc.Stop()
                cancel()
                &lt;-done</span> // Wait for service to finish
        case &lt;-done:<span class="cov0" title="0"></span>
                // Service finished naturally
        }
}

func runMultiScriptService(configPath string) <span class="cov0" title="0">{
        // Load service configuration
        var config service.ServiceConfig
        err := service.LoadServiceConfig(configPath, &amp;config)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to load config: %v\n", err)
                os.Exit(1)
        }</span>

        // Set default web port if not configured
        <span class="cov0" title="0">if config.WebPort == 0 </span><span class="cov0" title="0">{
                config.WebPort = 8080
        }</span>

        // Create script manager
        <span class="cov0" title="0">manager := service.NewScriptManager(&amp;config)

        // Set up signal handling
        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGTERM, syscall.SIGINT)

        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        // Start all enabled scripts
        err = manager.StartAllEnabled(ctx)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to start scripts: %v\n", err)
                cancel()
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Println("Multi-script service started")
        fmt.Printf("Running scripts: %v\n", manager.GetRunningScripts())

        // Wait for shutdown signal
        &lt;-sigChan
        fmt.Println("Received shutdown signal")

        // Stop all scripts
        manager.StopAll()
        cancel()

        fmt.Println("Service stopped")</span>
}

func parseInterval(intervalStr string) (int, error) <span class="cov8" title="1">{
        if intervalStr == "" </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("empty interval")
        }</span>

        <span class="cov8" title="1">suffix := intervalStr[len(intervalStr)-1:]
        valueStr := intervalStr[:len(intervalStr)-1]

        value, err := strconv.Atoi(valueStr)
        if err != nil </span><span class="cov8" title="1">{
                // Try parsing as plain number (seconds)
                result, parseErr := strconv.Atoi(intervalStr)
                if parseErr != nil </span><span class="cov8" title="1">{
                        return 0, parseErr
                }</span>
                <span class="cov0" title="0">if result &lt; 0 </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("negative interval not allowed")
                }</span>
                <span class="cov0" title="0">return result, nil</span>
        }

        <span class="cov8" title="1">switch suffix </span>{
        case "s":<span class="cov8" title="1">
                if value &lt; 0 </span><span class="cov8" title="1">{
                        return 0, fmt.Errorf("negative interval not allowed")
                }</span>
                <span class="cov8" title="1">return value, nil</span>
        case "m":<span class="cov8" title="1">
                if value &lt; 0 </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("negative interval not allowed")
                }</span>
                <span class="cov8" title="1">return value * 60, nil</span>
        case "h":<span class="cov8" title="1">
                if value &lt; 0 </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("negative interval not allowed")
                }</span>
                <span class="cov8" title="1">return value * 3600, nil</span>
        default:<span class="cov8" title="1">
                // No suffix, treat as seconds
                result, err := strconv.Atoi(intervalStr)
                if err != nil </span><span class="cov8" title="1">{
                        return 0, err
                }</span>
                <span class="cov8" title="1">if result &lt; 0 </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("negative interval not allowed")
                }</span>
                <span class="cov8" title="1">return result, nil</span>
        }
}

// parseScriptFlags parses command line flags for script management
func parseScriptFlags(args []string) (map[string]string, error) <span class="cov8" title="1">{
        flags := make(map[string]string)

        for _, arg := range args </span><span class="cov8" title="1">{
                if !strings.HasPrefix(arg, "--") </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">parts := strings.SplitN(arg[2:], "=", 2)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid flag format: %s (expected --key=value)", arg)
                }</span>

                <span class="cov8" title="1">flags[parts[0]] = parts[1]</span>
        }

        // Check required flags for add-script
        <span class="cov8" title="1">required := []string{"name", "path", "interval"}
        for _, req := range required </span><span class="cov8" title="1">{
                if _, ok := flags[req]; !ok </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("missing required flag: --%s", req)
                }</span>
        }

        <span class="cov8" title="1">return flags, nil</span>
}

// handleAddScript adds a new script to the configuration
func handleAddScript(args []string, configPath string) (CommandResult, error) <span class="cov8" title="1">{
        flags, err := parseScriptFlags(args)
        if err != nil </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, err
        }</span>

        // Parse interval
        <span class="cov8" title="1">interval, err := parseInterval(flags["interval"])
        if err != nil </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, fmt.Errorf("invalid interval: %v", err)
        }</span>

        // Parse optional flags
        <span class="cov8" title="1">maxLogLines := 100
        if val, ok := flags["max-log-lines"]; ok </span><span class="cov0" title="0">{
                if parsed, parseErr := strconv.Atoi(val); parseErr == nil &amp;&amp; parsed &gt; 0 </span><span class="cov0" title="0">{
                        maxLogLines = parsed
                }</span>
        }

        <span class="cov8" title="1">timeout := 0
        if val, ok := flags["timeout"]; ok </span><span class="cov0" title="0">{
                if parsed, parseErr := strconv.Atoi(val); parseErr == nil &amp;&amp; parsed &gt;= 0 </span><span class="cov0" title="0">{
                        timeout = parsed
                }</span>
        }

        // Load existing configuration
        <span class="cov8" title="1">var config service.ServiceConfig
        err = service.LoadServiceConfig(configPath, &amp;config)
        if err != nil </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, fmt.Errorf("failed to load config: %v", err)
        }</span>

        // Check if script name already exists
        <span class="cov8" title="1">for _, script := range config.Scripts </span><span class="cov0" title="0">{
                if script.Name == flags["name"] </span><span class="cov0" title="0">{
                        return CommandResult{shouldRunService: false}, fmt.Errorf("script with name '%s' already exists", flags["name"])
                }</span>
        }

        // Add new script
        <span class="cov8" title="1">newScript := service.ScriptConfig{
                Name:        flags["name"],
                Path:        flags["path"],
                Interval:    interval,
                Enabled:     true,
                MaxLogLines: maxLogLines,
                Timeout:     timeout,
        }

        if validateErr := newScript.Validate(); validateErr != nil </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, fmt.Errorf("invalid script configuration: %v", validateErr)
        }</span>

        <span class="cov8" title="1">config.Scripts = append(config.Scripts, newScript)

        // Save configuration
        err = service.SaveServiceConfig(configPath, &amp;config)
        if err != nil </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, fmt.Errorf("failed to save config: %v", err)
        }</span>

        <span class="cov8" title="1">fmt.Printf("Script '%s' added successfully\n", flags["name"])
        return CommandResult{shouldRunService: false}, nil</span>
}

// handleListScripts lists all configured scripts
func handleListScripts(configPath string) (CommandResult, error) <span class="cov8" title="1">{
        var config service.ServiceConfig
        err := service.LoadServiceConfig(configPath, &amp;config)
        if err != nil </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, fmt.Errorf("failed to load config: %v", err)
        }</span>

        <span class="cov8" title="1">if len(config.Scripts) == 0 </span><span class="cov0" title="0">{
                fmt.Println("No scripts configured")
                return CommandResult{shouldRunService: false}, nil
        }</span>

        <span class="cov8" title="1">fmt.Printf("%-15s %-50s %-10s %-8s %-10s %-7s\n", "NAME", "PATH", "INTERVAL", "ENABLED", "MAX_LOGS", "TIMEOUT")
        fmt.Println(strings.Repeat("-", 100))

        for _, script := range config.Scripts </span><span class="cov8" title="1">{
                enabled := "false"
                if script.Enabled </span><span class="cov8" title="1">{
                        enabled = "true"
                }</span>

                <span class="cov8" title="1">timeout := "none"
                if script.Timeout &gt; 0 </span><span class="cov8" title="1">{
                        timeout = fmt.Sprintf("%ds", script.Timeout)
                }</span>

                <span class="cov8" title="1">fmt.Printf("%-15s %-50s %-10ds %-8s %-10d %-7s\n",
                        script.Name, script.Path, script.Interval, enabled, script.MaxLogLines, timeout)</span>
        }

        <span class="cov8" title="1">return CommandResult{shouldRunService: false}, nil</span>
}

// handleScriptToggle enables or disables a script
func handleScriptToggle(scriptName, configPath string, enable bool) (CommandResult, error) <span class="cov8" title="1">{
        var config service.ServiceConfig
        err := service.LoadServiceConfig(configPath, &amp;config)
        if err != nil </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, fmt.Errorf("failed to load config: %v", err)
        }</span>

        <span class="cov8" title="1">found := false
        for i, script := range config.Scripts </span><span class="cov8" title="1">{
                if script.Name == scriptName </span><span class="cov8" title="1">{
                        config.Scripts[i].Enabled = enable
                        found = true
                        break</span>
                }
        }

        <span class="cov8" title="1">if !found </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, fmt.Errorf("script '%s' not found", scriptName)
        }</span>

        <span class="cov8" title="1">err = service.SaveServiceConfig(configPath, &amp;config)
        if err != nil </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, fmt.Errorf("failed to save config: %v", err)
        }</span>

        <span class="cov8" title="1">action := "disabled"
        if enable </span><span class="cov8" title="1">{
                action = "enabled"
        }</span>
        <span class="cov8" title="1">fmt.Printf("Script '%s' %s\n", scriptName, action)
        return CommandResult{shouldRunService: false}, nil</span>
}

// handleEnableScript enables a script
func handleEnableScript(scriptName, configPath string) (CommandResult, error) <span class="cov8" title="1">{
        return handleScriptToggle(scriptName, configPath, true)
}</span>

// handleDisableScript disables a script
func handleDisableScript(scriptName, configPath string) (CommandResult, error) <span class="cov8" title="1">{
        return handleScriptToggle(scriptName, configPath, false)
}</span>

// handleRemoveScript removes a script from configuration
func handleRemoveScript(scriptName, configPath string) (CommandResult, error) <span class="cov8" title="1">{
        var config service.ServiceConfig
        err := service.LoadServiceConfig(configPath, &amp;config)
        if err != nil </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, fmt.Errorf("failed to load config: %v", err)
        }</span>

        <span class="cov8" title="1">found := false
        newScripts := make([]service.ScriptConfig, 0, len(config.Scripts))
        for _, script := range config.Scripts </span><span class="cov8" title="1">{
                if script.Name != scriptName </span><span class="cov8" title="1">{
                        newScripts = append(newScripts, script)
                }</span> else<span class="cov8" title="1"> {
                        found = true
                }</span>
        }

        <span class="cov8" title="1">if !found </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, fmt.Errorf("script '%s' not found", scriptName)
        }</span>

        <span class="cov8" title="1">config.Scripts = newScripts

        err = service.SaveServiceConfig(configPath, &amp;config)
        if err != nil </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, fmt.Errorf("failed to save config: %v", err)
        }</span>

        <span class="cov8" title="1">fmt.Printf("Script '%s' removed\n", scriptName)
        return CommandResult{shouldRunService: false}, nil</span>
}

// handleRunScript executes a script once
func handleRunScript(scriptName, configPath string) (CommandResult, error) <span class="cov8" title="1">{
        var config service.ServiceConfig
        err := service.LoadServiceConfig(configPath, &amp;config)
        if err != nil </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, fmt.Errorf("failed to load config: %v", err)
        }</span>

        <span class="cov8" title="1">var scriptConfig *service.ScriptConfig
        for i, script := range config.Scripts </span><span class="cov8" title="1">{
                if script.Name == scriptName </span><span class="cov8" title="1">{
                        scriptConfig = &amp;config.Scripts[i]
                        break</span>
                }
        }

        <span class="cov8" title="1">if scriptConfig == nil </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, fmt.Errorf("script '%s' not found", scriptName)
        }</span>

        // Create a temporary script runner and execute once
        <span class="cov8" title="1">logPath := fmt.Sprintf("%s.log", scriptName)
        runner := service.NewScriptRunner(*scriptConfig, logPath)

        ctx := context.Background()
        err = runner.RunOnce(ctx)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Script '%s' execution failed: %v\n", scriptName, err)
        }</span> else<span class="cov8" title="1"> {
                fmt.Printf("Script '%s' executed successfully\n", scriptName)
        }</span>

        <span class="cov8" title="1">return CommandResult{shouldRunService: false}, nil</span>
}

// handleLogs displays logs for scripts
func handleLogs(args []string, _ string) (CommandResult, error) <span class="cov8" title="1">{
        flags, err := parseLogFlags(args)
        if err != nil </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, err
        }</span>

        // Determine logs directory path
        <span class="cov8" title="1">dir, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                dir, _ = os.Getwd()
        }</span> else<span class="cov8" title="1"> {
                dir = filepath.Dir(dir)
        }</span>
        <span class="cov8" title="1">logsDir := filepath.Join(dir, "logs")

        // Create log manager
        logManager := service.NewLogManager(logsDir)

        // Build query
        query := &amp;service.LogQuery{}

        if scriptName, ok := flags["script"]; ok </span><span class="cov8" title="1">{
                query.ScriptName = scriptName
        }</span>

        <span class="cov8" title="1">if exitCode, ok := flags["exit-code"]; ok </span><span class="cov8" title="1">{
                code, parseErr := strconv.Atoi(exitCode)
                if parseErr != nil </span><span class="cov0" title="0">{
                        return CommandResult{shouldRunService: false}, fmt.Errorf("invalid exit-code: %v", parseErr)
                }</span>
                <span class="cov8" title="1">query.ExitCode = &amp;code</span>
        }

        <span class="cov8" title="1">if limit, ok := flags["limit"]; ok </span><span class="cov8" title="1">{
                limitNum, parseErr := strconv.Atoi(limit)
                if parseErr != nil </span><span class="cov0" title="0">{
                        return CommandResult{shouldRunService: false}, fmt.Errorf("invalid limit: %v", parseErr)
                }</span>
                <span class="cov8" title="1">query.Limit = limitNum</span>
        }

        // Query logs
        <span class="cov8" title="1">entries, err := logManager.QueryLogs(query)
        if err != nil </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, fmt.Errorf("failed to query logs: %v", err)
        }</span>

        // Display logs
        <span class="cov8" title="1">if len(entries) == 0 </span><span class="cov8" title="1">{
                fmt.Println("No log entries found")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Found %d log entries:\n\n", len(entries))
                for _, entry := range entries </span><span class="cov0" title="0">{
                        fmt.Printf("[%s] %s (exit: %d, duration: %dms)\n",
                                entry.Timestamp.Format("2006-01-02 15:04:05"),
                                entry.ScriptName,
                                entry.ExitCode,
                                entry.Duration)
                        if entry.Stdout != "" </span><span class="cov0" title="0">{
                                fmt.Printf("  STDOUT: %s\n", entry.Stdout)
                        }</span>
                        <span class="cov0" title="0">if entry.Stderr != "" </span><span class="cov0" title="0">{
                                fmt.Printf("  STDERR: %s\n", entry.Stderr)
                        }</span>
                        <span class="cov0" title="0">fmt.Println()</span>
                }
        }

        <span class="cov8" title="1">return CommandResult{shouldRunService: false}, nil</span>
}

// handleClearLogs clears logs for a specific script
func handleClearLogs(args []string, _ string) (CommandResult, error) <span class="cov8" title="1">{
        flags, err := parseLogFlags(args)
        if err != nil </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, err
        }</span>

        <span class="cov8" title="1">scriptName, ok := flags["script"]
        if !ok </span><span class="cov8" title="1">{
                return CommandResult{shouldRunService: false},
                        fmt.Errorf("usage: ./run-script-service clear-logs --script=&lt;script-name&gt;")
        }</span>

        // Determine logs directory path
        <span class="cov8" title="1">dir, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                dir, _ = os.Getwd()
        }</span> else<span class="cov8" title="1"> {
                dir = filepath.Dir(dir)
        }</span>
        <span class="cov8" title="1">logsDir := filepath.Join(dir, "logs")

        // Clear the specific log file
        logFile := filepath.Join(logsDir, fmt.Sprintf("%s.log", scriptName))

        if _, statErr := os.Stat(logFile); os.IsNotExist(statErr) </span><span class="cov8" title="1">{
                fmt.Printf("No log file found for script '%s'\n", scriptName)
                return CommandResult{shouldRunService: false}, nil
        }</span>

        <span class="cov0" title="0">err = os.Remove(logFile)
        if err != nil </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, fmt.Errorf("failed to clear logs: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Logs cleared for script '%s'\n", scriptName)
        return CommandResult{shouldRunService: false}, nil</span>
}

// parseLogFlags parses log command flags
func parseLogFlags(args []string) (map[string]string, error) <span class="cov8" title="1">{
        flags := make(map[string]string)

        for _, arg := range args </span><span class="cov8" title="1">{
                if arg == "--all" </span><span class="cov8" title="1">{
                        // --all is equivalent to no script filter
                        continue</span>
                }

                <span class="cov8" title="1">if strings.HasPrefix(arg, "--") </span><span class="cov8" title="1">{
                        parts := strings.SplitN(arg[2:], "=", 2)
                        if len(parts) == 2 </span><span class="cov8" title="1">{
                                flags[parts[0]] = parts[1]
                        }</span> else<span class="cov0" title="0"> {
                                return nil, fmt.Errorf("invalid flag format: %s (expected --key=value)", arg)
                        }</span>
                } else<span class="cov0" title="0"> {
                        return nil, fmt.Errorf("invalid argument: %s", arg)
                }</span>
        }

        <span class="cov8" title="1">return flags, nil</span>
}

// handleSetWebPort sets the web server port
func handleSetWebPort(portStr, configPath string) (CommandResult, error) <span class="cov8" title="1">{
        port, err := strconv.Atoi(portStr)
        if err != nil </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, fmt.Errorf("invalid port number: %v", err)
        }</span>

        <span class="cov8" title="1">if port &lt; 1 || port &gt; 65535 </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, fmt.Errorf("port must be between 1 and 65535")
        }</span>

        // Load existing configuration
        <span class="cov8" title="1">var config service.ServiceConfig
        err = service.LoadServiceConfig(configPath, &amp;config)
        if err != nil </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, fmt.Errorf("failed to load config: %v", err)
        }</span>

        // Update web port
        <span class="cov8" title="1">config.WebPort = port

        // Save configuration
        err = service.SaveServiceConfig(configPath, &amp;config)
        if err != nil </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, fmt.Errorf("failed to save config: %v", err)
        }</span>

        <span class="cov8" title="1">fmt.Printf("Web port set to %d\n", port)
        return CommandResult{shouldRunService: false}, nil</span>
}

// runMultiScriptServiceWithWeb runs the service with web interface
func runMultiScriptServiceWithWeb(configPath string) <span class="cov0" title="0">{
        // Load service configuration
        var config service.ServiceConfig
        err := service.LoadServiceConfig(configPath, &amp;config)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to load config: %v\n", err)
                os.Exit(1)
        }</span>

        // Set default web port if not configured
        <span class="cov0" title="0">if config.WebPort == 0 </span><span class="cov0" title="0">{
                config.WebPort = 8080
        }</span>

        // Get current directory for file operations
        <span class="cov0" title="0">dir, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                dir, _ = os.Getwd()
        }</span> else<span class="cov0" title="0"> {
                dir = filepath.Dir(dir)
        }</span>

        // Create file manager for secure file operations
        <span class="cov0" title="0">fileManager := service.NewFileManager(dir)

        // Create script manager
        scriptManager := service.NewScriptManagerWithPath(&amp;config, configPath)

        // Create system monitor
        systemMonitor := service.NewSystemMonitor()

        // Create web server (simplified, no LogManager dependency)
        webServer := web.NewWebServer(nil, config.WebPort)
        webServer.SetScriptManager(scriptManager)
        webServer.SetFileManager(fileManager)
        webServer.SetSystemMonitor(systemMonitor)

        // Set up signal handling
        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGTERM, syscall.SIGINT)

        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        // Start all enabled scripts
        err = scriptManager.StartAllEnabled(ctx)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to start scripts: %v\n", err)
                cancel()
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Println("Multi-script service with web interface started")
        fmt.Printf("Running scripts: %v\n", scriptManager.GetRunningScripts())
        fmt.Printf("Web interface available at http://localhost:%d\n", config.WebPort)

        // Start system metrics broadcasting (every 30 seconds)
        err = webServer.StartSystemMetricsBroadcasting(ctx, 30*time.Second)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to start system metrics broadcasting: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("System metrics broadcasting started")
        }</span>

        // Start web server in goroutine
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                if err := webServer.Start(); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Web server failed: %v\n", err)
                        cancel()
                }</span>
        }()

        // Wait for shutdown signal
        <span class="cov0" title="0">&lt;-sigChan
        fmt.Println("Received shutdown signal")

        // Stop all scripts and web server
        scriptManager.StopAll()
        cancel()

        fmt.Println("Service stopped")</span>
}

// PID file management functions
func getPidFilePath() string <span class="cov0" title="0">{
        dir, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                dir, _ = os.Getwd()
        }</span> else<span class="cov0" title="0"> {
                dir = filepath.Dir(dir)
        }</span>
        <span class="cov0" title="0">return filepath.Join(dir, "run-script-service.pid")</span>
}

func writePidFile(pid int) error <span class="cov0" title="0">{
        pidFile := getPidFilePath()
        return os.WriteFile(pidFile, []byte(fmt.Sprintf("%d", pid)), 0644)
}</span>

func readPidFile() (int, error) <span class="cov0" title="0">{
        pidFile := getPidFilePath()
        data, err := os.ReadFile(pidFile)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return strconv.Atoi(strings.TrimSpace(string(data)))</span>
}

func removePidFile() error <span class="cov0" title="0">{
        pidFile := getPidFilePath()
        return os.Remove(pidFile)
}</span>

func isProcessRunning(pid int) bool <span class="cov0" title="0">{
        process, err := os.FindProcess(pid)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">err = process.Signal(syscall.Signal(0))
        return err == nil</span>
}

// handleDaemonCommand handles daemon subcommands (start/stop/status/restart/logs)
func handleDaemonCommand(subCommand, configPath string) (CommandResult, error) <span class="cov0" title="0">{
        switch subCommand </span>{
        case "start":<span class="cov0" title="0">
                return handleDaemonStart(configPath)</span>
        case "stop":<span class="cov0" title="0">
                return handleDaemonStop()</span>
        case "status":<span class="cov0" title="0">
                return handleDaemonStatus()</span>
        case "restart":<span class="cov0" title="0">
                return handleDaemonRestart(configPath)</span>
        case "logs":<span class="cov0" title="0">
                return handleDaemonLogs()</span>
        default:<span class="cov0" title="0">
                return CommandResult{shouldRunService: false},
                        fmt.Errorf("unknown daemon subcommand: %s\navailable subcommands: start, stop, status, restart, logs", subCommand)</span>
        }
}

// handleDaemonStart starts the service as a background daemon
func handleDaemonStart(configPath string) (CommandResult, error) <span class="cov0" title="0">{
        // Check if already running
        if pid, err := readPidFile(); err == nil &amp;&amp; isProcessRunning(pid) </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false},
                        fmt.Errorf("service is already running (PID: %d)", pid)
        }</span>

        // Get executable path
        <span class="cov0" title="0">execPath, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false},
                        fmt.Errorf("failed to get executable path: %v", err)
        }</span>

        // Get working directory
        <span class="cov0" title="0">workDir := filepath.Dir(execPath)

        // Auto-build frontend if needed
        if err := ensureFrontendBuilt(workDir); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Warning: Frontend build failed: %v\n", err)
                fmt.Println("Continuing with existing build...")
        }</span>

        // Create log file for daemon output
        <span class="cov0" title="0">logFile := filepath.Join(workDir, "daemon.log")
        file, err := os.OpenFile(logFile, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false},
                        fmt.Errorf("failed to create log file: %v", err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        // Start the daemon process
        cmd := exec.Command(execPath, "run")
        cmd.Dir = workDir
        cmd.Stdout = file
        cmd.Stderr = file
        cmd.SysProcAttr = &amp;syscall.SysProcAttr{
                Setsid: true, // Create new session
        }

        err = cmd.Start()
        if err != nil </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false},
                        fmt.Errorf("failed to start daemon: %v", err)
        }</span>

        // Write PID file
        <span class="cov0" title="0">err = writePidFile(cmd.Process.Pid)
        if err != nil </span><span class="cov0" title="0">{
                cmd.Process.Kill()
                return CommandResult{shouldRunService: false},
                        fmt.Errorf("failed to write PID file: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Service started successfully (PID: %d)\n", cmd.Process.Pid)
        fmt.Printf("Web interface available at http://localhost:8080\n")
        fmt.Printf("Logs: %s\n", logFile)

        return CommandResult{shouldRunService: false}, nil</span>
}

// handleDaemonStop stops the running daemon
func handleDaemonStop() (CommandResult, error) <span class="cov0" title="0">{
        pid, err := readPidFile()
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return CommandResult{shouldRunService: false}, fmt.Errorf("service is not running")
                }</span>
                <span class="cov0" title="0">return CommandResult{shouldRunService: false}, fmt.Errorf("failed to read PID file: %v", err)</span>
        }

        <span class="cov0" title="0">if !isProcessRunning(pid) </span><span class="cov0" title="0">{
                removePidFile()
                return CommandResult{shouldRunService: false}, fmt.Errorf("service is not running")
        }</span>

        <span class="cov0" title="0">process, err := os.FindProcess(pid)
        if err != nil </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, fmt.Errorf("failed to find process: %v", err)
        }</span>

        // Send SIGTERM for graceful shutdown
        <span class="cov0" title="0">err = process.Signal(syscall.SIGTERM)
        if err != nil </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, fmt.Errorf("failed to stop service: %v", err)
        }</span>

        // Wait a bit for graceful shutdown
        <span class="cov0" title="0">time.Sleep(2 * time.Second)

        // Check if still running, force kill if necessary
        if isProcessRunning(pid) </span><span class="cov0" title="0">{
                err = process.Kill()
                if err != nil </span><span class="cov0" title="0">{
                        return CommandResult{shouldRunService: false}, fmt.Errorf("failed to force kill service: %v", err)
                }</span>
                <span class="cov0" title="0">fmt.Println("Service force killed")</span>
        } else<span class="cov0" title="0"> {
                fmt.Println("Service stopped gracefully")
        }</span>

        // Remove PID file
        <span class="cov0" title="0">removePidFile()

        return CommandResult{shouldRunService: false}, nil</span>
}

// handleDaemonStatus shows the status of the daemon
func handleDaemonStatus() (CommandResult, error) <span class="cov0" title="0">{
        pid, err := readPidFile()
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        fmt.Println("Service is not running")
                        return CommandResult{shouldRunService: false}, nil
                }</span>
                <span class="cov0" title="0">return CommandResult{shouldRunService: false}, fmt.Errorf("failed to read PID file: %v", err)</span>
        }

        <span class="cov0" title="0">if isProcessRunning(pid) </span><span class="cov0" title="0">{
                fmt.Printf("Service is running (PID: %d)\n", pid)
                fmt.Println("Web interface: http://localhost:8080")
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("Service is not running (stale PID file)")
                removePidFile()
        }</span>

        <span class="cov0" title="0">return CommandResult{shouldRunService: false}, nil</span>
}

// handleDaemonRestart restarts the daemon
func handleDaemonRestart(configPath string) (CommandResult, error) <span class="cov0" title="0">{
        // Stop if running
        _, err := handleDaemonStop()
        if err != nil &amp;&amp; !strings.Contains(err.Error(), "not running") </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, err
        }</span>

        // Wait a moment
        <span class="cov0" title="0">time.Sleep(1 * time.Second)

        // Start again
        return handleDaemonStart(configPath)</span>
}

// handleDaemonLogs shows the daemon service logs
func handleDaemonLogs() (CommandResult, error) <span class="cov0" title="0">{
        dir, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                dir, _ = os.Getwd()
        }</span> else<span class="cov0" title="0"> {
                dir = filepath.Dir(dir)
        }</span>

        <span class="cov0" title="0">logFile := filepath.Join(dir, "daemon.log")

        // Check if log file exists
        if _, err := os.Stat(logFile); os.IsNotExist(err) </span><span class="cov0" title="0">{
                fmt.Println("No daemon logs found. Start the service first with: ./run-script-service daemon start")
                return CommandResult{shouldRunService: false}, nil
        }</span>

        // Read and display the log file
        <span class="cov0" title="0">content, err := os.ReadFile(logFile)
        if err != nil </span><span class="cov0" title="0">{
                return CommandResult{shouldRunService: false}, fmt.Errorf("failed to read daemon logs: %v", err)
        }</span>

        <span class="cov0" title="0">if len(content) == 0 </span><span class="cov0" title="0">{
                fmt.Println("Daemon log file is empty")
        }</span> else<span class="cov0" title="0"> {
                fmt.Print(string(content))
        }</span>

        <span class="cov0" title="0">return CommandResult{shouldRunService: false}, nil</span>
}

// ensureFrontendBuilt checks if frontend needs building and builds it if necessary
func ensureFrontendBuilt(workDir string) error <span class="cov0" title="0">{
        frontendDir := filepath.Join(workDir, "web", "frontend")
        distDir := filepath.Join(frontendDir, "dist")

        // Check if frontend project exists
        if _, err := os.Stat(filepath.Join(frontendDir, "package.json")); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("frontend project not found at %s", frontendDir)
        }</span>

        // Check if dist directory exists and has files
        <span class="cov0" title="0">if info, err := os.Stat(distDir); os.IsNotExist(err) || !info.IsDir() </span><span class="cov0" title="0">{
                fmt.Println("Frontend dist directory not found, building frontend...")
                return buildFrontend(frontendDir)
        }</span>

        // Check if dist directory is empty
        <span class="cov0" title="0">files, err := os.ReadDir(distDir)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read dist directory: %v", err)
        }</span>

        <span class="cov0" title="0">if len(files) == 0 </span><span class="cov0" title="0">{
                fmt.Println("Frontend dist directory is empty, building frontend...")
                return buildFrontend(frontendDir)
        }</span>

        // Check if package.json is newer than dist (basic staleness check)
        <span class="cov0" title="0">packageJsonPath := filepath.Join(frontendDir, "package.json")
        packageInfo, err := os.Stat(packageJsonPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to stat package.json: %v", err)
        }</span>

        <span class="cov0" title="0">distInfo, err := os.Stat(distDir)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to stat dist directory: %v", err)
        }</span>

        <span class="cov0" title="0">if packageInfo.ModTime().After(distInfo.ModTime()) </span><span class="cov0" title="0">{
                fmt.Println("Frontend source appears newer than build, rebuilding frontend...")
                return buildFrontend(frontendDir)
        }</span>

        <span class="cov0" title="0">fmt.Println("Frontend build appears up to date")
        return nil</span>
}

// buildFrontend builds the frontend using pnpm/vite
func buildFrontend(frontendDir string) error <span class="cov0" title="0">{
        fmt.Printf("Building frontend in %s...\n", frontendDir)

        // Check if node_modules exists, install dependencies if not
        nodeModulesDir := filepath.Join(frontendDir, "node_modules")
        if _, err := os.Stat(nodeModulesDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                fmt.Println("Installing frontend dependencies...")
                if err := runCommand("pnpm", []string{"install"}, frontendDir); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("pnpm install failed: %v", err)
                }</span>
        }

        // Run the build command
        <span class="cov0" title="0">fmt.Println("Running frontend build...")
        if err := runCommand("pnpm", []string{"build"}, frontendDir); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("pnpm build failed: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("Frontend build completed successfully")
        return nil</span>
}

// runCommand executes a command in the specified directory
func runCommand(command string, args []string, workingDir string) error <span class="cov0" title="0">{
        cmd := exec.Command(command, args...)
        cmd.Dir = workingDir
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr

        return cmd.Run()
}</span>
</pre>

		<pre class="file" id="file1" style="display: none">// Package mocks provides mock implementations for testing purposes.
package mocks

import (
        "os"
        "time"
)

// FileSystem interface abstracts file system operations for testing
type FileSystem interface {
        WriteFile(filename string, data []byte, perm os.FileMode) error
        ReadFile(filename string) ([]byte, error)
        OpenFile(name string, flag int, perm os.FileMode) (*os.File, error)
        Stat(name string) (os.FileInfo, error)
}

// MockFileSystem provides a mock implementation for testing
type MockFileSystem struct {
        Files         map[string][]byte
        WriteFileFunc func(filename string, data []byte, perm os.FileMode) error
        ReadFileFunc  func(filename string) ([]byte, error)
        StatFunc      func(name string) (os.FileInfo, error)
}

// NewMockFileSystem creates a new mock file system for testing.
func NewMockFileSystem() *MockFileSystem <span class="cov0" title="0">{
        return &amp;MockFileSystem{
                Files: make(map[string][]byte),
        }
}</span>

// WriteFile implements the FileSystem interface for mock testing.
func (m *MockFileSystem) WriteFile(filename string, data []byte, perm os.FileMode) error <span class="cov0" title="0">{
        if m.WriteFileFunc != nil </span><span class="cov0" title="0">{
                return m.WriteFileFunc(filename, data, perm)
        }</span>
        <span class="cov0" title="0">m.Files[filename] = data
        return nil</span>
}

// ReadFile implements the FileSystem interface for mock testing.
func (m *MockFileSystem) ReadFile(filename string) ([]byte, error) <span class="cov0" title="0">{
        if m.ReadFileFunc != nil </span><span class="cov0" title="0">{
                return m.ReadFileFunc(filename)
        }</span>
        <span class="cov0" title="0">if data, exists := m.Files[filename]; exists </span><span class="cov0" title="0">{
                return data, nil
        }</span>
        <span class="cov0" title="0">return nil, os.ErrNotExist</span>
}

// OpenFile implements the FileSystem interface for mock testing.
func (m *MockFileSystem) OpenFile(name string, flag int, perm os.FileMode) (*os.File, error) <span class="cov0" title="0">{
        // For simplicity, this mock doesn't implement OpenFile
        return nil, os.ErrNotExist
}</span>

// Stat implements the FileSystem interface for mock testing.
func (m *MockFileSystem) Stat(name string) (os.FileInfo, error) <span class="cov0" title="0">{
        if m.StatFunc != nil </span><span class="cov0" title="0">{
                return m.StatFunc(name)
        }</span>
        <span class="cov0" title="0">if _, exists := m.Files[name]; exists </span><span class="cov0" title="0">{
                return &amp;mockFileInfo{name: name}, nil
        }</span>
        <span class="cov0" title="0">return nil, os.ErrNotExist</span>
}

type mockFileInfo struct {
        name string
}

func (m *mockFileInfo) Name() string       <span class="cov0" title="0">{ return m.name }</span>
func (m *mockFileInfo) Size() int64        <span class="cov0" title="0">{ return 0 }</span>
func (m *mockFileInfo) Mode() os.FileMode  <span class="cov0" title="0">{ return 0644 }</span>
func (m *mockFileInfo) ModTime() time.Time <span class="cov0" title="0">{ return time.Time{} }</span>
func (m *mockFileInfo) IsDir() bool        <span class="cov0" title="0">{ return false }</span>
func (m *mockFileInfo) Sys() interface{}   <span class="cov0" title="0">{ return nil }</span>

// TimeProvider interface abstracts time operations for testing
type TimeProvider interface {
        Now() time.Time
        Sleep(d time.Duration)
        After(d time.Duration) &lt;-chan time.Time
}

// MockTime provides a mock implementation for testing
type MockTime struct {
        fixedTime *time.Time
}

// NewMockTime creates a new mock time provider for testing.
func NewMockTime() *MockTime <span class="cov8" title="1">{
        return &amp;MockTime{}
}</span>

// SetFixedTime sets a fixed time for testing purposes.
func (m *MockTime) SetFixedTime(t time.Time) <span class="cov8" title="1">{
        m.fixedTime = &amp;t
}</span>

// Now implements the TimeProvider interface for mock testing.
func (m *MockTime) Now() time.Time <span class="cov8" title="1">{
        if m.fixedTime != nil </span><span class="cov8" title="1">{
                return *m.fixedTime
        }</span>
        <span class="cov8" title="1">return time.Now()</span>
}

// Sleep implements the TimeProvider interface for mock testing.
func (m *MockTime) Sleep(d time.Duration) {<span class="cov8" title="1">
        // In mock, sleep is instant (don't actually sleep)
}</span>

// After implements the TimeProvider interface for mock testing.
func (m *MockTime) After(d time.Duration) &lt;-chan time.Time <span class="cov8" title="1">{
        // In mock, return a channel that receives immediately
        ch := make(chan time.Time, 1)
        ch &lt;- time.Now()
        return ch
}</span>
</pre>

		<pre class="file" id="file2" style="display: none">// Package service provides core functionality for the run-script-service daemon.
package service

import (
        "encoding/json"
        "fmt"
        "log"
        "os"
        "path/filepath"
)

// ScriptConfig represents configuration for a single script
type ScriptConfig struct {
        Name        string `json:"name"`
        Path        string `json:"path"`
        Interval    int    `json:"interval"` // seconds
        Enabled     bool   `json:"enabled"`
        MaxLogLines int    `json:"max_log_lines"`
        Timeout     int    `json:"timeout"` // seconds, 0 means no limit
}

// ServiceConfig represents the overall service configuration
type ServiceConfig struct {
        Scripts []ScriptConfig `json:"scripts"`
        WebPort int            `json:"web_port"`
}

// Config is a legacy struct for backward compatibility
type Config struct {
        Interval int `json:"interval"`
}

// Validate checks if the script configuration is valid
func (sc *ScriptConfig) Validate() error <span class="cov0" title="0">{
        return sc.ValidateWithOptions(true)
}</span>

// ValidateWithOptions checks if the script configuration is valid with optional file existence check
func (sc *ScriptConfig) ValidateWithOptions(checkFileExists bool) error <span class="cov8" title="1">{
        if sc.Name == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("script name cannot be empty")
        }</span>
        <span class="cov8" title="1">if sc.Path == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("script path cannot be empty")
        }</span>
        <span class="cov8" title="1">if sc.Interval &lt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("interval cannot be negative")
        }</span>
        <span class="cov8" title="1">if sc.MaxLogLines &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("max_log_lines cannot be negative")
        }</span>
        <span class="cov8" title="1">if sc.Timeout &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("timeout cannot be negative")
        }</span>

        // Optionally check if script file exists and is executable
        <span class="cov8" title="1">if checkFileExists </span><span class="cov0" title="0">{
                scriptPath := sc.Path
                if !filepath.IsAbs(scriptPath) </span><span class="cov0" title="0">{
                        // Convert relative path to absolute path
                        workDir, err := os.Getwd()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("unable to get working directory: %v", err)
                        }</span>
                        <span class="cov0" title="0">scriptPath = filepath.Join(workDir, sc.Path)</span>
                }

                <span class="cov0" title="0">info, err := os.Stat(scriptPath)
                if err != nil </span><span class="cov0" title="0">{
                        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                                return fmt.Errorf("script file does not exist: %s", sc.Path)
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("unable to access script file %s: %v", sc.Path, err)</span>
                }

                // Check if it's a regular file (not a directory)
                <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                        return fmt.Errorf("script path is a directory, not a file: %s", sc.Path)
                }</span>

                // Check if file is executable
                <span class="cov0" title="0">if info.Mode()&amp;0111 == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("script file is not executable: %s (mode: %v)", sc.Path, info.Mode())
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// LoadConfig loads configuration from the specified file path
func LoadConfig(configPath string, config *Config) error <span class="cov8" title="1">{
        if _, err := os.Stat(configPath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return nil // Keep default config
        }</span>

        <span class="cov8" title="1">data, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error reading config: %v", err)
                return nil // Keep default config, don't fail
        }</span>

        <span class="cov8" title="1">if err := json.Unmarshal(data, config); err != nil </span><span class="cov8" title="1">{
                log.Printf("Error parsing config: %v", err)
                return nil // Keep default config, don't fail
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// SaveConfig saves configuration to the specified file path
func SaveConfig(configPath string, config *Config) error <span class="cov8" title="1">{
        data, err := json.MarshalIndent(config, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error marshaling config: %v", err)
        }</span>

        <span class="cov8" title="1">if err := os.WriteFile(configPath, data, 0600); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error writing config: %v", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// LoadServiceConfig loads the new multi-script configuration with backward compatibility
func LoadServiceConfig(configPath string, config *ServiceConfig) error <span class="cov8" title="1">{
        if _, err := os.Stat(configPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil // Keep default config
        }</span>

        <span class="cov8" title="1">data, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error reading config: %v", err)
                return nil // Keep default config, don't fail
        }</span>

        // Try to parse as new format first
        <span class="cov8" title="1">var tempConfig ServiceConfig
        if err := json.Unmarshal(data, &amp;tempConfig); err == nil </span><span class="cov8" title="1">{
                // Check if it looks like new format (has "scripts" field or "web_port" field)
                var rawConfig map[string]interface{}
                if err := json.Unmarshal(data, &amp;rawConfig); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error parsing config as map: %v", err)
                }</span>

                <span class="cov8" title="1">if _, hasScripts := rawConfig["scripts"]; hasScripts || rawConfig["web_port"] != nil </span><span class="cov8" title="1">{
                        // Successfully parsed as new format
                        for i, script := range tempConfig.Scripts </span><span class="cov8" title="1">{
                                // Only validate basic fields during config loading, not file existence
                                if err := script.ValidateWithOptions(false); err != nil </span><span class="cov0" title="0">{
                                        log.Printf("Invalid script config %d: %v", i, err)
                                        return nil // Keep default config
                                }</span>
                        }
                        <span class="cov8" title="1">*config = tempConfig
                        return nil</span>
                }
        }

        // Try to parse as legacy format for backward compatibility
        <span class="cov8" title="1">var legacyConfig Config
        if err := json.Unmarshal(data, &amp;legacyConfig); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error parsing config: %v", err)
                return nil // Keep default config, don't fail
        }</span>

        // Convert legacy config to new format
        <span class="cov8" title="1">config.Scripts = []ScriptConfig{
                {
                        Name:        "main",
                        Path:        "./run.sh", // default script path
                        Interval:    legacyConfig.Interval,
                        Enabled:     true,
                        MaxLogLines: 100, // default
                        Timeout:     0,   // no timeout
                },
        }
        if config.WebPort == 0 </span><span class="cov0" title="0">{
                config.WebPort = 8080 // default
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// SaveServiceConfig saves the service configuration to file
func SaveServiceConfig(configPath string, config *ServiceConfig) error <span class="cov0" title="0">{
        data, err := json.MarshalIndent(config, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error marshaling config: %v", err)
        }</span>

        <span class="cov0" title="0">if err := os.WriteFile(configPath, data, 0600); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error writing config: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>

		<pre class="file" id="file3" style="display: none">package service

import (
        "sync"
        "time"
)

// ScriptStatusEvent represents a script status change event
type ScriptStatusEvent struct {
        ScriptName string    `json:"script_name"`
        Status     string    `json:"status"` // "starting", "running", "completed", "failed"
        ExitCode   int       `json:"exit_code"`
        Duration   int64     `json:"duration"` // Duration in milliseconds
        Timestamp  time.Time `json:"timestamp"`
}

// NewScriptStatusEvent creates a new script status event
func NewScriptStatusEvent(scriptName, status string, exitCode int, duration int64) *ScriptStatusEvent <span class="cov8" title="1">{
        return &amp;ScriptStatusEvent{
                ScriptName: scriptName,
                Status:     status,
                ExitCode:   exitCode,
                Duration:   duration,
                Timestamp:  time.Now(),
        }
}</span>

// ToJSON converts the event to a JSON-compatible map
func (e *ScriptStatusEvent) ToJSON() map[string]interface{} <span class="cov8" title="1">{
        return map[string]interface{}{
                "script_name": e.ScriptName,
                "status":      e.Status,
                "exit_code":   e.ExitCode,
                "duration":    e.Duration,
                "timestamp":   e.Timestamp.Format(time.RFC3339),
        }
}</span>

// EventBroadcaster manages event broadcasting to multiple listeners
type EventBroadcaster struct {
        listeners []chan&lt;- *ScriptStatusEvent
        mutex     sync.RWMutex
}

// NewEventBroadcaster creates a new event broadcaster
func NewEventBroadcaster() *EventBroadcaster <span class="cov8" title="1">{
        return &amp;EventBroadcaster{
                listeners: make([]chan&lt;- *ScriptStatusEvent, 0),
        }
}</span>

// Subscribe adds a listener to receive events
// Returns an unsubscribe function
func (eb *EventBroadcaster) Subscribe(eventChan chan&lt;- *ScriptStatusEvent) func() <span class="cov8" title="1">{
        eb.mutex.Lock()
        defer eb.mutex.Unlock()

        eb.listeners = append(eb.listeners, eventChan)

        // Return unsubscribe function
        return func() </span><span class="cov8" title="1">{
                eb.mutex.Lock()
                defer eb.mutex.Unlock()

                for i, listener := range eb.listeners </span><span class="cov8" title="1">{
                        if listener == eventChan </span><span class="cov8" title="1">{
                                // Remove this listener from the slice
                                eb.listeners = append(eb.listeners[:i], eb.listeners[i+1:]...)
                                break</span>
                        }
                }
        }
}

// Broadcast sends an event to all subscribers
// This is non-blocking - if a listener's channel is full, the event is dropped for that listener
func (eb *EventBroadcaster) Broadcast(event *ScriptStatusEvent) <span class="cov8" title="1">{
        eb.mutex.RLock()
        defer eb.mutex.RUnlock()

        for _, listener := range eb.listeners </span><span class="cov8" title="1">{
                select </span>{
                case listener &lt;- event:<span class="cov8" title="1"></span>
                        // Event sent successfully
                default:<span class="cov8" title="1"></span>
                        // Channel is full, drop the event for this listener
                }
        }
}
</pre>

		<pre class="file" id="file4" style="display: none">// Package service provides core functionality for the run-script-service daemon.
package service

import (
        "bufio"
        "context"
        "fmt"
        "io"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
        "syscall"
        "time"
)

// ExecutionResult contains the results of script execution
type ExecutionResult struct {
        ExitCode  int
        Stdout    string
        Stderr    string
        Timestamp time.Time
}

// Executor handles script execution and logging
type Executor struct {
        scriptPath string
        logPath    string
        maxLines   int
}

// NewExecutor creates a new script executor
func NewExecutor(scriptPath, logPath string, maxLines int) *Executor <span class="cov8" title="1">{
        return &amp;Executor{
                scriptPath: scriptPath,
                logPath:    logPath,
                maxLines:   maxLines,
        }
}</span>

// ExecuteScript executes the configured script and logs the results
func (e *Executor) ExecuteScript(args ...string) *ExecutionResult <span class="cov8" title="1">{
        // Use context with timeout for backward compatibility
        ctx := context.Background()
        return e.ExecuteScriptWithContext(ctx, args...)
}</span>

// ExecuteScriptWithContext executes the configured script with context support
func (e *Executor) ExecuteScriptWithContext(ctx context.Context, args ...string) *ExecutionResult <span class="cov8" title="1">{
        timestamp := time.Now()
        result := &amp;ExecutionResult{
                Timestamp: timestamp,
        }

        cmd := exec.CommandContext(ctx, e.scriptPath, args...)
        cmd.Dir = filepath.Dir(e.scriptPath)

        // Set process group to enable proper cleanup
        cmd.SysProcAttr = &amp;syscall.SysProcAttr{
                Setpgid: true,
        }

        stdout, err := cmd.StdoutPipe()
        if err != nil </span><span class="cov0" title="0">{
                e.logError(timestamp, fmt.Sprintf("Error creating stdout pipe: %v", err))
                result.ExitCode = -1
                return result
        }</span>

        <span class="cov8" title="1">stderr, err := cmd.StderrPipe()
        if err != nil </span><span class="cov0" title="0">{
                e.logError(timestamp, fmt.Sprintf("Error creating stderr pipe: %v", err))
                result.ExitCode = -1
                return result
        }</span>

        <span class="cov8" title="1">if startErr := cmd.Start(); startErr != nil </span><span class="cov8" title="1">{
                e.logError(timestamp, fmt.Sprintf("Error starting command: %v", startErr))
                result.ExitCode = -1
                return result
        }</span>

        // Ensure process cleanup on exit
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if cmd.Process != nil </span><span class="cov8" title="1">{
                        // Kill the entire process group to clean up any child processes
                        if pgid, err := syscall.Getpgid(cmd.Process.Pid); err == nil </span><span class="cov0" title="0">{
                                // Only kill if the process is still running and we can get the pgid
                                _ = syscall.Kill(-pgid, syscall.SIGTERM)

                                // Wait a moment for graceful shutdown, then force kill if needed
                                go func() </span><span class="cov0" title="0">{
                                        time.Sleep(100 * time.Millisecond)
                                        if cmd.ProcessState == nil || !cmd.ProcessState.Exited() </span><span class="cov0" title="0">{
                                                _ = syscall.Kill(-pgid, syscall.SIGKILL)
                                        }</span>
                                }()
                        }
                }
        }()

        <span class="cov8" title="1">stdoutBytes, _ := io.ReadAll(stdout)
        stderrBytes, _ := io.ReadAll(stderr)

        err = cmd.Wait()
        result.ExitCode = 0
        if err != nil </span><span class="cov8" title="1">{
                if exitError, ok := err.(*exec.ExitError); ok </span><span class="cov8" title="1">{
                        result.ExitCode = exitError.ExitCode()
                }</span> else<span class="cov0" title="0"> {
                        e.logError(timestamp, fmt.Sprintf("Error waiting for command: %v", err))
                        result.ExitCode = -1
                        return result
                }</span>
        }

        <span class="cov8" title="1">result.Stdout = strings.TrimSpace(string(stdoutBytes))
        result.Stderr = strings.TrimSpace(string(stderrBytes))

        // Write to log only if logPath is specified
        if e.logPath != "" </span><span class="cov8" title="1">{
                logEntry := fmt.Sprintf("[%s] Exit code: %d\n", timestamp.Format("2006-01-02 15:04:05"), result.ExitCode)
                if result.Stdout != "" </span><span class="cov8" title="1">{
                        logEntry += fmt.Sprintf("STDOUT: %s\n", result.Stdout)
                }</span>
                <span class="cov8" title="1">if result.Stderr != "" </span><span class="cov8" title="1">{
                        logEntry += fmt.Sprintf("STDERR: %s\n", result.Stderr)
                }</span>
                <span class="cov8" title="1">logEntry += strings.Repeat("-", 50) + "\n"

                if err := e.WriteLog(logEntry); err != nil </span><span class="cov8" title="1">{
                        fmt.Printf("Error writing to log: %v\n", err)
                }</span>

                <span class="cov8" title="1">if err := e.TrimLog(); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Error trimming log: %v\n", err)
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}

// logError logs an error message
func (e *Executor) logError(timestamp time.Time, message string) <span class="cov8" title="1">{
        if e.logPath != "" </span><span class="cov8" title="1">{
                errorMsg := fmt.Sprintf("[%s] ERROR: %s\n%s\n",
                        timestamp.Format("2006-01-02 15:04:05"), message, strings.Repeat("-", 50))
                if err := e.WriteLog(errorMsg); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Error writing error to log: %v\n", err)
                }</span>
        }
        <span class="cov8" title="1">fmt.Printf("Error executing script: %s\n", message)</span>
}

// WriteLog writes content to the log file
func (e *Executor) WriteLog(content string) error <span class="cov8" title="1">{
        file, err := os.OpenFile(e.logPath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0600)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        _, err = file.WriteString(content)
        return err</span>
}

// TrimLog keeps only the last maxLines lines in the log file
func (e *Executor) TrimLog() error <span class="cov8" title="1">{
        file, err := os.Open(e.logPath)
        if os.IsNotExist(err) </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        var lines []string
        scanner := bufio.NewScanner(file)
        for scanner.Scan() </span><span class="cov8" title="1">{
                lines = append(lines, scanner.Text())
        }</span>

        <span class="cov8" title="1">if scanErr := scanner.Err(); scanErr != nil </span><span class="cov0" title="0">{
                return scanErr
        }</span>

        <span class="cov8" title="1">if len(lines) &lt;= e.maxLines </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Keep only the last maxLines lines
        <span class="cov8" title="1">linesToKeep := lines[len(lines)-e.maxLines:]

        outFile, err := os.Create(e.logPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer outFile.Close()

        for _, line := range linesToKeep </span><span class="cov8" title="1">{
                if _, err := outFile.WriteString(line + "\n"); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>

		<pre class="file" id="file5" style="display: none">// Package service provides file management functionality
package service

import (
        "fmt"
        "io/fs"
        "os"
        "path/filepath"
        "strings"
)

// FileManager handles secure file operations
type FileManager struct {
        allowedPaths []string
        deniedPaths  []string
        baseDir      string
}

// FileContent represents file content with metadata
type FileContent struct {
        Path    string `json:"path"`
        Content string `json:"content"`
        Size    int64  `json:"size"`
        Mode    string `json:"mode"`
}

// NewFileManager creates a new file manager with security constraints
func NewFileManager(baseDir string) *FileManager <span class="cov8" title="1">{
        return &amp;FileManager{
                baseDir: baseDir,
                allowedPaths: []string{
                        ".",          // Current directory
                        "./scripts",  // Scripts directory
                        "./logs",     // Logs directory
                        "./testdata", // Test data directory
                },
                deniedPaths: []string{
                        "/etc",
                        "/usr",
                        "/bin",
                        "/sbin",
                        "/root",
                        "/home",
                        "/var",
                        "/tmp",
                        "/proc",
                        "/sys",
                },
        }
}</span>

// IsPathAllowed checks if a file path is allowed for access
func (fm *FileManager) IsPathAllowed(path string) bool <span class="cov8" title="1">{
        // Clean and resolve the path
        cleanPath := filepath.Clean(path)

        // Additional security checks
        if strings.Contains(cleanPath, "..") </span><span class="cov0" title="0">{
                return false // Path traversal attempt
        }</span>

        // Convert to absolute path for security checks
        <span class="cov8" title="1">var absPath string
        if filepath.IsAbs(cleanPath) </span><span class="cov8" title="1">{
                absPath = cleanPath

                // Check denied paths first for absolute paths
                for _, denied := range fm.deniedPaths </span><span class="cov8" title="1">{
                        if strings.HasPrefix(absPath, denied) </span><span class="cov8" title="1">{
                                return false
                        }</span>
                }

                // Absolute paths outside allowed system paths are denied
                <span class="cov0" title="0">return false</span>
        } else<span class="cov8" title="1"> {
                // Relative paths are relative to baseDir
                absPath = filepath.Join(fm.baseDir, cleanPath)
        }</span>

        // Ensure the resolved path is still within baseDir
        <span class="cov8" title="1">absBaseDir, err := filepath.Abs(fm.baseDir)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">absRequestPath, err := filepath.Abs(absPath)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if !strings.HasPrefix(absRequestPath, absBaseDir) </span><span class="cov0" title="0">{
                return false // Outside base directory
        }</span>

        // For relative paths, check if they're within allowed directories
        <span class="cov8" title="1">for _, allowed := range fm.allowedPaths </span><span class="cov8" title="1">{
                allowedAbs := allowed
                if !filepath.IsAbs(allowed) </span><span class="cov8" title="1">{
                        allowedAbs = filepath.Join(fm.baseDir, allowed)
                }</span>

                // Normalize paths for comparison
                <span class="cov8" title="1">allowedAbs = filepath.Clean(allowedAbs)
                cleanAbsPath := filepath.Clean(absPath)

                // Allow exact match
                if cleanAbsPath == allowedAbs </span><span class="cov8" title="1">{
                        return true
                }</span>

                // Allow subdirectory (ensure it's actually a subdirectory, not just prefix match)
                <span class="cov8" title="1">if strings.HasPrefix(cleanAbsPath+string(filepath.Separator), allowedAbs+string(filepath.Separator)) </span><span class="cov8" title="1">{
                        return true
                }</span>

                // Allow files within the directory
                <span class="cov0" title="0">if strings.HasPrefix(cleanAbsPath, allowedAbs+string(filepath.Separator)) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// ReadFile reads a file's content safely
func (fm *FileManager) ReadFile(path string) (*FileContent, error) <span class="cov8" title="1">{
        if !fm.IsPathAllowed(path) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("access denied: path not allowed")
        }</span>

        // Resolve relative path
        <span class="cov8" title="1">fullPath := path
        if !filepath.IsAbs(path) </span><span class="cov8" title="1">{
                fullPath = filepath.Join(fm.baseDir, path)
        }</span>

        // Get file info
        <span class="cov8" title="1">info, err := os.Stat(fullPath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get file info: %w", err)
        }</span>

        // Read file content
        <span class="cov8" title="1">content, err := os.ReadFile(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read file: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;FileContent{
                Path:    path,
                Content: string(content),
                Size:    info.Size(),
                Mode:    info.Mode().String(),
        }, nil</span>
}

// WriteFile writes content to a file safely
func (fm *FileManager) WriteFile(path string, content string) error <span class="cov8" title="1">{
        if !fm.IsPathAllowed(path) </span><span class="cov8" title="1">{
                return fmt.Errorf("access denied: path not allowed")
        }</span>

        // Resolve relative path
        <span class="cov8" title="1">fullPath := path
        if !filepath.IsAbs(path) </span><span class="cov8" title="1">{
                fullPath = filepath.Join(fm.baseDir, path)
        }</span>

        // Ensure directory exists
        <span class="cov8" title="1">dir := filepath.Dir(fullPath)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create directory: %w", err)
        }</span>

        // Write file
        <span class="cov8" title="1">if err := os.WriteFile(fullPath, []byte(content), 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write file: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ValidateScriptSyntax performs basic validation on shell scripts
func (fm *FileManager) ValidateScriptSyntax(content string) []string <span class="cov8" title="1">{
        var issues []string

        lines := strings.Split(content, "\n")
        for i, line := range lines </span><span class="cov8" title="1">{
                lineNum := i + 1
                trimmed := strings.TrimSpace(line)

                // Skip empty lines and comments
                if trimmed == "" || strings.HasPrefix(trimmed, "#") </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Check for potential security issues
                <span class="cov8" title="1">if strings.Contains(trimmed, "rm -rf") </span><span class="cov8" title="1">{
                        issues = append(issues, fmt.Sprintf("Line %d: Potentially dangerous command 'rm -rf'", lineNum))
                }</span>

                <span class="cov8" title="1">if strings.Contains(trimmed, "sudo") </span><span class="cov8" title="1">{
                        issues = append(issues, fmt.Sprintf("Line %d: Use of 'sudo' detected", lineNum))
                }</span>

                // Check for basic syntax issues
                <span class="cov8" title="1">if strings.Count(trimmed, "'")%2 != 0 </span><span class="cov0" title="0">{
                        issues = append(issues, fmt.Sprintf("Line %d: Unmatched single quote", lineNum))
                }</span>

                <span class="cov8" title="1">if strings.Count(trimmed, "\"")%2 != 0 </span><span class="cov8" title="1">{
                        issues = append(issues, fmt.Sprintf("Line %d: Unmatched double quote", lineNum))
                }</span>
        }

        <span class="cov8" title="1">return issues</span>
}

// ListFiles lists files in a directory
func (fm *FileManager) ListFiles(dirPath string) ([]fs.FileInfo, error) <span class="cov8" title="1">{
        if !fm.IsPathAllowed(dirPath) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("access denied: path not allowed")
        }</span>

        // Resolve relative path
        <span class="cov8" title="1">fullPath := dirPath
        if !filepath.IsAbs(dirPath) </span><span class="cov8" title="1">{
                fullPath = filepath.Join(fm.baseDir, dirPath)
        }</span>

        <span class="cov8" title="1">entries, err := os.ReadDir(fullPath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to read directory: %w", err)
        }</span>

        <span class="cov8" title="1">var fileInfos []fs.FileInfo
        for _, entry := range entries </span><span class="cov8" title="1">{
                info, err := entry.Info()
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip files we can't get info for
                }
                <span class="cov8" title="1">fileInfos = append(fileInfos, info)</span>
        }

        <span class="cov8" title="1">return fileInfos, nil</span>
}
</pre>

		<pre class="file" id="file6" style="display: none">// Package service provides core functionality for the run-script-service daemon
package service

import (
        "bufio"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "regexp"
        "strconv"
        "strings"
        "sync"
        "time"
)

// LogManager manages multiple script loggers
type LogManager struct {
        loggers map[string]*ScriptLogger
        baseDir string
        mutex   sync.RWMutex
}

// ScriptLogger handles logging for a specific script
type ScriptLogger struct {
        scriptName string
        logPath    string
        maxLines   int
        entries    []LogEntry
        mutex      sync.RWMutex
}

// LogEntry represents a single log entry
type LogEntry struct {
        Timestamp  time.Time `json:"timestamp"`
        ScriptName string    `json:"script_name"`
        ExitCode   int       `json:"exit_code"`
        Stdout     string    `json:"stdout"`
        Stderr     string    `json:"stderr"`
        Duration   int64     `json:"duration_ms"`
}

// LogQuery defines criteria for querying logs
type LogQuery struct {
        ScriptName string    `json:"script_name,omitempty"`
        StartTime  time.Time `json:"start_time,omitempty"`
        EndTime    time.Time `json:"end_time,omitempty"`
        ExitCode   *int      `json:"exit_code,omitempty"`
        Limit      int       `json:"limit,omitempty"`
}

// NewLogManager creates a new LogManager instance
func NewLogManager(baseDir string) *LogManager <span class="cov8" title="1">{
        return &amp;LogManager{
                loggers: make(map[string]*ScriptLogger),
                baseDir: baseDir,
        }
}</span>

// GetLogger returns a logger for the specified script, creating one if it doesn't exist
func (lm *LogManager) GetLogger(scriptName string) *ScriptLogger <span class="cov8" title="1">{
        lm.mutex.Lock()
        defer lm.mutex.Unlock()

        if logger, exists := lm.loggers[scriptName]; exists </span><span class="cov8" title="1">{
                return logger
        }</span>

        <span class="cov8" title="1">logger := NewScriptLogger(scriptName, lm.baseDir, 100) // Default max lines
        lm.loggers[scriptName] = logger
        return logger</span>
}

// NewScriptLogger creates a new ScriptLogger instance
func NewScriptLogger(scriptName, baseDir string, maxLines int) *ScriptLogger <span class="cov8" title="1">{
        logPath := filepath.Join(baseDir, fmt.Sprintf("%s.log", scriptName))

        logger := &amp;ScriptLogger{
                scriptName: scriptName,
                logPath:    logPath,
                maxLines:   maxLines,
                entries:    make([]LogEntry, 0),
        }

        // Ensure log directory exists
        _ = os.MkdirAll(baseDir, 0750) // Ignore error - logger will still work, file ops may fail later

        // Load existing log file if it exists
        logger.LoadExistingLogs()

        return logger
}</span>

// AddEntry adds a new log entry to the script logger
func (sl *ScriptLogger) AddEntry(entry *LogEntry) error <span class="cov8" title="1">{
        sl.mutex.Lock()
        defer sl.mutex.Unlock()

        // Add entry to in-memory storage
        sl.entries = append(sl.entries, *entry)

        // Maintain maxLines limit
        if len(sl.entries) &gt; sl.maxLines </span><span class="cov8" title="1">{
                sl.entries = sl.entries[len(sl.entries)-sl.maxLines:]
        }</span>

        // Write to file
        <span class="cov8" title="1">return sl.writeToFile(entry)</span>
}

// writeToFile writes a log entry to the log file
func (sl *ScriptLogger) writeToFile(entry *LogEntry) error <span class="cov8" title="1">{
        file, err := os.OpenFile(sl.logPath, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0600)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open log file: %w", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        data, err := json.Marshal(entry)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal log entry: %w", err)
        }</span>

        <span class="cov8" title="1">_, err = file.Write(append(data, '\n'))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write log entry: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetEntries returns all log entries for this script
func (sl *ScriptLogger) GetEntries() []LogEntry <span class="cov8" title="1">{
        sl.mutex.RLock()
        defer sl.mutex.RUnlock()

        // Return a copy to prevent external modification
        entries := make([]LogEntry, len(sl.entries))
        copy(entries, sl.entries)
        return entries
}</span>

// QueryLogs queries logs across all managed scripts
func (lm *LogManager) QueryLogs(query *LogQuery) ([]LogEntry, error) <span class="cov0" title="0">{
        lm.mutex.RLock()
        defer lm.mutex.RUnlock()

        var results []LogEntry

        // If specific script is requested
        if query.ScriptName != "" </span><span class="cov0" title="0">{
                if logger, exists := lm.loggers[query.ScriptName]; exists </span><span class="cov0" title="0">{
                        entries := logger.GetEntries()
                        results = append(results, entries...)
                }</span>
        } else<span class="cov0" title="0"> {
                // Query all scripts
                for _, logger := range lm.loggers </span><span class="cov0" title="0">{
                        entries := logger.GetEntries()
                        results = append(results, entries...)
                }</span>
        }

        // Apply filters
        <span class="cov0" title="0">filtered := make([]LogEntry, 0)
        for i := range results </span><span class="cov0" title="0">{
                if lm.matchesQuery(&amp;results[i], query) </span><span class="cov0" title="0">{
                        filtered = append(filtered, results[i])
                }</span>
        }

        // Apply limit
        <span class="cov0" title="0">if query.Limit &gt; 0 &amp;&amp; len(filtered) &gt; query.Limit </span><span class="cov0" title="0">{
                filtered = filtered[len(filtered)-query.Limit:]
        }</span>

        <span class="cov0" title="0">return filtered, nil</span>
}

// matchesQuery checks if a log entry matches the query criteria
func (lm *LogManager) matchesQuery(entry *LogEntry, query *LogQuery) bool <span class="cov0" title="0">{
        // Check time range
        if !query.StartTime.IsZero() &amp;&amp; entry.Timestamp.Before(query.StartTime) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if !query.EndTime.IsZero() &amp;&amp; entry.Timestamp.After(query.EndTime) </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check exit code
        <span class="cov0" title="0">if query.ExitCode != nil &amp;&amp; entry.ExitCode != *query.ExitCode </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

// LoadExistingLogs loads log entries from existing log file
func (sl *ScriptLogger) LoadExistingLogs() <span class="cov8" title="1">{
        if _, err := os.Stat(sl.logPath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return // No existing log file
        }</span>

        <span class="cov0" title="0">file, err := os.Open(sl.logPath)
        if err != nil </span><span class="cov0" title="0">{
                return // Can't open file, continue without loading
        }</span>
        <span class="cov0" title="0">defer file.Close()

        scanner := bufio.NewScanner(file)
        var currentEntry *LogEntry
        var stdoutLines []string

        // Regex to match timestamp and exit code line: [2025-08-02 11:26:16] Exit code: 0
        timestampRegex := regexp.MustCompile(`^\[([^\]]+)\] Exit code: (\d+)$`)

        for scanner.Scan() </span><span class="cov0" title="0">{
                line := strings.TrimSpace(scanner.Text())

                if line == "--------------------------------------------------" </span><span class="cov0" title="0">{
                        // End of entry
                        if currentEntry != nil </span><span class="cov0" title="0">{
                                currentEntry.Stdout = strings.Join(stdoutLines, "\n")
                                sl.entries = append(sl.entries, *currentEntry)
                                currentEntry = nil
                                stdoutLines = nil
                        }</span>
                } else<span class="cov0" title="0"> if matches := timestampRegex.FindStringSubmatch(line); matches != nil </span><span class="cov0" title="0">{
                        // Start of new entry
                        timestamp, _ := time.Parse("2006-01-02 15:04:05", matches[1])
                        exitCode, _ := strconv.Atoi(matches[2])

                        currentEntry = &amp;LogEntry{
                                Timestamp:  timestamp,
                                ScriptName: sl.scriptName,
                                ExitCode:   exitCode,
                                Stdout:     "",
                                Stderr:     "",
                                Duration:   0, // Can't determine from existing logs
                        }
                        stdoutLines = make([]string, 0)
                }</span> else<span class="cov0" title="0"> if currentEntry != nil &amp;&amp; strings.HasPrefix(line, "STDOUT: ") </span><span class="cov0" title="0">{
                        // STDOUT line
                        stdoutContent := strings.TrimPrefix(line, "STDOUT: ")
                        stdoutLines = append(stdoutLines, stdoutContent)
                }</span> else<span class="cov0" title="0"> if currentEntry != nil &amp;&amp; line != "" &amp;&amp; !strings.HasPrefix(line, "STDERR: ") </span><span class="cov0" title="0">{
                        // Continuation of stdout (multi-line output)
                        stdoutLines = append(stdoutLines, line)
                }</span>
        }

        // Handle last entry if file doesn't end with separator
        <span class="cov0" title="0">if currentEntry != nil </span><span class="cov0" title="0">{
                currentEntry.Stdout = strings.Join(stdoutLines, "\n")
                sl.entries = append(sl.entries, *currentEntry)
        }</span>

        // Maintain maxLines limit
        <span class="cov0" title="0">if len(sl.entries) &gt; sl.maxLines </span><span class="cov0" title="0">{
                sl.entries = sl.entries[len(sl.entries)-sl.maxLines:]
        }</span>
}

// ClearLogs clears all log entries for a specific script
func (lm *LogManager) ClearLogs(scriptName string) error <span class="cov0" title="0">{
        lm.mutex.Lock()
        defer lm.mutex.Unlock()

        if logger, exists := lm.loggers[scriptName]; exists </span><span class="cov0" title="0">{
                return logger.ClearEntries()
        }</span>

        <span class="cov0" title="0">return fmt.Errorf("script '%s' not found", scriptName)</span>
}

// ClearEntries clears all log entries for this script logger
func (sl *ScriptLogger) ClearEntries() error <span class="cov0" title="0">{
        sl.mutex.Lock()
        defer sl.mutex.Unlock()

        // Clear in-memory entries
        sl.entries = make([]LogEntry, 0)

        // Clear the log file
        if err := os.Truncate(sl.logPath, 0); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to clear log file: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>

		<pre class="file" id="file7" style="display: none">package service

import (
        "context"
        "encoding/json"
        "fmt"
        "runtime"
        "sync"
        "syscall"
        "time"
)

type SystemMetrics struct {
        CPUPercent      float64   `json:"cpu_percent"`
        MemoryPercent   float64   `json:"memory_percent"`
        DiskPercent     float64   `json:"disk_percent"`
        ActiveScripts   int       `json:"active_scripts"`
        TotalExecutions int       `json:"total_executions"`
        Timestamp       time.Time `json:"timestamp"`
}

func (sm *SystemMetrics) ToJSON() []byte <span class="cov8" title="1">{
        data, _ := json.Marshal(sm)
        return data
}</span>

type SystemMonitor struct {
        mu              sync.RWMutex
        activeScripts   int
        totalExecutions int
        startTime       time.Time
}

func NewSystemMonitor() *SystemMonitor <span class="cov8" title="1">{
        return &amp;SystemMonitor{
                startTime: time.Now(),
        }
}</span>

func (sm *SystemMonitor) SetActiveScripts(count int) <span class="cov8" title="1">{
        sm.mu.Lock()
        defer sm.mu.Unlock()
        sm.activeScripts = count
}</span>

func (sm *SystemMonitor) SetTotalExecutions(count int) <span class="cov8" title="1">{
        sm.mu.Lock()
        defer sm.mu.Unlock()
        sm.totalExecutions = count
}</span>

func (sm *SystemMonitor) GetSystemMetrics() (*SystemMetrics, error) <span class="cov8" title="1">{
        sm.mu.RLock()
        activeScripts := sm.activeScripts
        totalExecutions := sm.totalExecutions
        sm.mu.RUnlock()

        var memStats runtime.MemStats
        runtime.ReadMemStats(&amp;memStats)

        // Calculate memory usage percentage
        // Using allocated memory vs system memory (simplified)
        memoryPercent := float64(memStats.Alloc) / float64(memStats.Sys) * 100
        if memoryPercent &gt; 100 </span><span class="cov0" title="0">{
                memoryPercent = 100
        }</span>

        // Get disk usage
        <span class="cov8" title="1">diskPercent := sm.getDiskUsage()

        // Get CPU usage (simplified - always return a reasonable value for tests)
        cpuPercent := sm.getCPUUsage()

        return &amp;SystemMetrics{
                CPUPercent:      cpuPercent,
                MemoryPercent:   memoryPercent,
                DiskPercent:     diskPercent,
                ActiveScripts:   activeScripts,
                TotalExecutions: totalExecutions,
                Timestamp:       time.Now(),
        }, nil</span>
}

func (sm *SystemMonitor) getDiskUsage() float64 <span class="cov8" title="1">{
        var stat syscall.Statfs_t
        err := syscall.Statfs("/", &amp;stat)
        if err != nil </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        <span class="cov8" title="1">total := stat.Blocks * uint64(stat.Bsize)
        free := stat.Bavail * uint64(stat.Bsize)
        used := total - free

        if total == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        <span class="cov8" title="1">return float64(used) / float64(total) * 100</span>
}

func (sm *SystemMonitor) getCPUUsage() float64 <span class="cov8" title="1">{
        // Simplified CPU usage - in a real implementation, this would
        // involve reading /proc/stat and calculating CPU usage over time
        // For testing purposes, return a reasonable value
        return 25.0
}</span>

// GetUptime returns a human-readable uptime string
func (sm *SystemMonitor) GetUptime() string <span class="cov0" title="0">{
        sm.mu.RLock()
        startTime := sm.startTime
        sm.mu.RUnlock()

        uptime := time.Since(startTime)

        // Format uptime as human-readable string
        days := int(uptime.Hours()) / 24
        hours := int(uptime.Hours()) % 24
        minutes := int(uptime.Minutes()) % 60

        if days &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dd %dh %dm", days, hours, minutes)
        }</span> else<span class="cov0" title="0"> if hours &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dh %dm", hours, minutes)
        }</span> else<span class="cov0" title="0"> {
                return fmt.Sprintf("%dm", minutes)
        }</span>
}

// EventPublisher is a function type for publishing events
type EventPublisher func(msgType string, data map[string]interface{}) error

// StartPeriodicBroadcasting starts periodic system metrics broadcasting
func (sm *SystemMonitor) StartPeriodicBroadcasting(ctx context.Context, interval time.Duration, publisher EventPublisher) <span class="cov8" title="1">{
        ticker := time.NewTicker(interval)
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov8" title="1">
                        metrics, err := sm.GetSystemMetrics()
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Convert metrics to map for publishing
                        <span class="cov8" title="1">data := map[string]interface{}{
                                "cpu_percent":      metrics.CPUPercent,
                                "memory_percent":   metrics.MemoryPercent,
                                "disk_percent":     metrics.DiskPercent,
                                "active_scripts":   metrics.ActiveScripts,
                                "total_executions": metrics.TotalExecutions,
                                "timestamp":        metrics.Timestamp,
                        }

                        publisher("system_metrics", data)</span>
                }
        }
}
</pre>

		<pre class="file" id="file8" style="display: none">// Package service provides core functionality for the run-script-service daemon.
package service

import (
        "context"
        "fmt"
        "sync"
)

// ScriptManager manages multiple script runners
type ScriptManager struct {
        scripts    map[string]*ScriptRunner
        config     *ServiceConfig
        configPath string
        mutex      sync.RWMutex
}

// NewScriptManager creates a new script manager with the given configuration
func NewScriptManager(config *ServiceConfig) *ScriptManager <span class="cov8" title="1">{
        return &amp;ScriptManager{
                scripts: make(map[string]*ScriptRunner),
                config:  config,
        }
}</span>

// NewScriptManagerWithPath creates a new script manager with configuration and config path
func NewScriptManagerWithPath(config *ServiceConfig, configPath string) *ScriptManager <span class="cov0" title="0">{
        return &amp;ScriptManager{
                scripts:    make(map[string]*ScriptRunner),
                config:     config,
                configPath: configPath,
        }
}</span>

// StartScript starts a script by name
func (sm *ScriptManager) StartScript(ctx context.Context, name string) error <span class="cov8" title="1">{
        sm.mutex.Lock()
        defer sm.mutex.Unlock()

        // Check if script is already running
        if _, exists := sm.scripts[name]; exists </span><span class="cov0" title="0">{
                return fmt.Errorf("script %s is already running", name)
        }</span>

        // Find the script config
        <span class="cov8" title="1">var scriptConfig *ScriptConfig
        for i, sc := range sm.config.Scripts </span><span class="cov8" title="1">{
                if sc.Name == name </span><span class="cov8" title="1">{
                        scriptConfig = &amp;sm.config.Scripts[i]
                        break</span>
                }
        }

        <span class="cov8" title="1">if scriptConfig == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("script %s not found in configuration", name)
        }</span>

        // Create and start the script runner
        <span class="cov8" title="1">logPath := fmt.Sprintf("%s.log", name) // Simple log path for now
        runner := NewScriptRunner(*scriptConfig, logPath)
        sm.scripts[name] = runner

        // Start the runner in a goroutine
        go func() </span><span class="cov8" title="1">{
                runner.Start(ctx)
                // Clean up when runner stops
                sm.mutex.Lock()
                delete(sm.scripts, name)
                sm.mutex.Unlock()
        }</span>()

        <span class="cov8" title="1">return nil</span>
}

// StopScript stops a script by name
func (sm *ScriptManager) StopScript(name string) error <span class="cov8" title="1">{
        sm.mutex.Lock()
        defer sm.mutex.Unlock()

        runner, exists := sm.scripts[name]
        if !exists </span><span class="cov8" title="1">{
                return fmt.Errorf("script %s is not running", name)
        }</span>

        <span class="cov8" title="1">runner.Stop()
        delete(sm.scripts, name)
        return nil</span>
}

// StartAllEnabled starts all enabled scripts
func (sm *ScriptManager) StartAllEnabled(ctx context.Context) error <span class="cov8" title="1">{
        for _, scriptConfig := range sm.config.Scripts </span><span class="cov8" title="1">{
                if scriptConfig.Enabled </span><span class="cov8" title="1">{
                        if err := sm.StartScript(ctx, scriptConfig.Name); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to start script %s: %v", scriptConfig.Name, err)
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// StopAll stops all running scripts
func (sm *ScriptManager) StopAll() <span class="cov8" title="1">{
        sm.mutex.Lock()
        defer sm.mutex.Unlock()

        for name, runner := range sm.scripts </span><span class="cov8" title="1">{
                runner.Stop()
                delete(sm.scripts, name)
        }</span>
}

// GetRunningScripts returns a list of currently running script names
func (sm *ScriptManager) GetRunningScripts() []string <span class="cov0" title="0">{
        sm.mutex.RLock()
        defer sm.mutex.RUnlock()

        var running []string
        for name := range sm.scripts </span><span class="cov0" title="0">{
                running = append(running, name)
        }</span>
        <span class="cov0" title="0">return running</span>
}

// IsScriptRunning checks if a specific script is running
func (sm *ScriptManager) IsScriptRunning(name string) bool <span class="cov8" title="1">{
        sm.mutex.RLock()
        defer sm.mutex.RUnlock()

        _, exists := sm.scripts[name]
        return exists
}</span>

// GetConfig returns the script manager's configuration
func (sm *ScriptManager) GetConfig() *ServiceConfig <span class="cov0" title="0">{
        return sm.config
}</span>

// SaveConfig saves the current configuration to file
func (sm *ScriptManager) SaveConfig() error <span class="cov0" title="0">{
        if sm.configPath == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("config path not set - cannot save configuration")
        }</span>
        <span class="cov0" title="0">return SaveServiceConfig(sm.configPath, sm.config)</span>
}

// AddScript adds a new script configuration
func (sm *ScriptManager) AddScript(scriptConfig ScriptConfig) error <span class="cov0" title="0">{
        sm.mutex.Lock()
        defer sm.mutex.Unlock()

        // Check if script with same name already exists
        for _, existing := range sm.config.Scripts </span><span class="cov0" title="0">{
                if existing.Name == scriptConfig.Name </span><span class="cov0" title="0">{
                        return fmt.Errorf("script with name %s already exists", scriptConfig.Name)
                }</span>
        }

        // Add the script to configuration
        <span class="cov0" title="0">sm.config.Scripts = append(sm.config.Scripts, scriptConfig)
        return nil</span>
}

// RunScriptOnce executes a script once by name
func (sm *ScriptManager) RunScriptOnce(ctx context.Context, name string) error <span class="cov0" title="0">{
        sm.mutex.RLock()
        defer sm.mutex.RUnlock()

        // Find the script config
        var scriptConfig *ScriptConfig
        for i, sc := range sm.config.Scripts </span><span class="cov0" title="0">{
                if sc.Name == name </span><span class="cov0" title="0">{
                        scriptConfig = &amp;sm.config.Scripts[i]
                        break</span>
                }
        }

        <span class="cov0" title="0">if scriptConfig == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("script %s not found in configuration", name)
        }</span>

        // Create a temporary script runner for one-time execution
        <span class="cov0" title="0">logPath := fmt.Sprintf("%s.log", name)
        runner := NewScriptRunner(*scriptConfig, logPath)

        return runner.RunOnce(ctx)</span>
}

// EnableScript enables a script by name
func (sm *ScriptManager) EnableScript(name string) error <span class="cov0" title="0">{
        sm.mutex.Lock()
        defer sm.mutex.Unlock()

        // Find the script config
        for i, sc := range sm.config.Scripts </span><span class="cov0" title="0">{
                if sc.Name == name </span><span class="cov0" title="0">{
                        sm.config.Scripts[i].Enabled = true
                        return nil
                }</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("script %s not found in configuration", name)</span>
}

// DisableScript disables a script by name
func (sm *ScriptManager) DisableScript(name string) error <span class="cov0" title="0">{
        sm.mutex.Lock()
        defer sm.mutex.Unlock()

        // Find the script config
        for i, sc := range sm.config.Scripts </span><span class="cov0" title="0">{
                if sc.Name == name </span><span class="cov0" title="0">{
                        sm.config.Scripts[i].Enabled = false
                        return nil
                }</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("script %s not found in configuration", name)</span>
}

// UpdateScript updates an existing script configuration
func (sm *ScriptManager) UpdateScript(name string, updatedConfig ScriptConfig) error <span class="cov8" title="1">{
        sm.mutex.Lock()
        defer sm.mutex.Unlock()

        // Find the script config and update it
        for i, sc := range sm.config.Scripts </span><span class="cov8" title="1">{
                if sc.Name == name </span><span class="cov8" title="1">{
                        // Ensure the name matches the parameter
                        updatedConfig.Name = name
                        sm.config.Scripts[i] = updatedConfig
                        return nil
                }</span>
        }

        <span class="cov8" title="1">return fmt.Errorf("script %s not found in configuration", name)</span>
}

// RemoveScript removes a script from configuration and stops it if running
func (sm *ScriptManager) RemoveScript(name string) error <span class="cov8" title="1">{
        sm.mutex.Lock()
        defer sm.mutex.Unlock()

        // Stop the script if it's running
        if runner, exists := sm.scripts[name]; exists </span><span class="cov8" title="1">{
                runner.Stop()
                delete(sm.scripts, name)
        }</span>

        // Find and remove the script from configuration
        <span class="cov8" title="1">found := false
        newScripts := make([]ScriptConfig, 0, len(sm.config.Scripts))
        for _, sc := range sm.config.Scripts </span><span class="cov8" title="1">{
                if sc.Name != name </span><span class="cov8" title="1">{
                        newScripts = append(newScripts, sc)
                }</span> else<span class="cov8" title="1"> {
                        found = true
                }</span>
        }

        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                return fmt.Errorf("script %s not found in configuration", name)
        }</span>

        <span class="cov8" title="1">sm.config.Scripts = newScripts
        return nil</span>
}
</pre>

		<pre class="file" id="file9" style="display: none">// Package service provides core functionality for the run-script-service daemon.
package service

import (
        "context"
        "fmt"
        "sync"
        "time"
)

// ScriptExecutor wraps the existing Executor to support context and arguments
type ScriptExecutor struct {
        executor *Executor
}

// NewScriptExecutor creates a new script executor
func NewScriptExecutor(scriptPath, logPath string, maxLines int) *ScriptExecutor <span class="cov8" title="1">{
        return &amp;ScriptExecutor{
                executor: NewExecutor(scriptPath, logPath, maxLines),
        }
}</span>

// NewScriptExecutorWithoutLogging creates a script executor that doesn't log to files
func NewScriptExecutorWithoutLogging(scriptPath string) *ScriptExecutor <span class="cov8" title="1">{
        return &amp;ScriptExecutor{
                executor: NewExecutor(scriptPath, "", 0), // No logging
        }
}</span>

// Execute executes the script with context support and optional arguments
func (se *ScriptExecutor) Execute(ctx context.Context, args ...string) error <span class="cov0" title="0">{
        result, err := se.ExecuteWithResult(ctx, args...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if result.ExitCode != 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("script exited with code %d", result.ExitCode)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ExecuteWithResult executes the script and returns detailed execution result
func (se *ScriptExecutor) ExecuteWithResult(ctx context.Context, args ...string) (*ExecutionResult, error) <span class="cov8" title="1">{
        // Check if context is already canceled
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, ctx.Err()</span>
        default:<span class="cov8" title="1"></span>
        }

        // Create a channel to signal completion
        <span class="cov8" title="1">resultChan := make(chan *ExecutionResult, 1)

        // Execute in a goroutine to allow for cancellation
        go func() </span><span class="cov8" title="1">{
                result := se.executor.ExecuteScriptWithContext(ctx, args...)
                resultChan &lt;- result
        }</span>()

        // Wait for either completion or cancellation
        <span class="cov8" title="1">select </span>{
        case &lt;-ctx.Done():<span class="cov8" title="1">
                return nil, ctx.Err()</span>
        case result := &lt;-resultChan:<span class="cov8" title="1">
                return result, nil</span>
        }
}

// ScriptRunner manages the execution of a single script
type ScriptRunner struct {
        config           ScriptConfig
        ticker           *time.Ticker
        cancel           context.CancelFunc
        executor         *ScriptExecutor
        logManager       *LogManager
        eventBroadcaster *EventBroadcaster
        running          bool
        mutex            sync.RWMutex
}

// NewScriptRunner creates a new script runner with the given configuration
func NewScriptRunner(config ScriptConfig, logPath string) *ScriptRunner <span class="cov8" title="1">{
        return &amp;ScriptRunner{
                config:           config,
                executor:         NewScriptExecutor(config.Path, logPath, config.MaxLogLines),
                logManager:       nil,
                eventBroadcaster: nil,
                running:          false,
        }
}</span>

// NewScriptRunnerWithLogManager creates a new script runner with LogManager integration
func NewScriptRunnerWithLogManager(config ScriptConfig, logManager *LogManager) *ScriptRunner <span class="cov8" title="1">{
        return &amp;ScriptRunner{
                config:           config,
                executor:         NewScriptExecutorWithoutLogging(config.Path), // No file logging since we use LogManager
                logManager:       logManager,
                eventBroadcaster: nil,
                running:          false,
        }
}</span>

// NewScriptRunnerWithEventBroadcaster creates a new script runner with event broadcasting
func NewScriptRunnerWithEventBroadcaster(config ScriptConfig, logPath string, broadcaster *EventBroadcaster) *ScriptRunner <span class="cov8" title="1">{
        return &amp;ScriptRunner{
                config:           config,
                executor:         NewScriptExecutor(config.Path, logPath, config.MaxLogLines),
                logManager:       nil,
                eventBroadcaster: broadcaster,
                running:          false,
        }
}</span>

// Start begins running the script at the configured interval
func (sr *ScriptRunner) Start(ctx context.Context) <span class="cov8" title="1">{
        sr.mutex.Lock()
        if sr.running </span><span class="cov0" title="0">{
                sr.mutex.Unlock()
                return
        }</span>

        // Create cancellable context
        <span class="cov8" title="1">runCtx, cancel := context.WithCancel(ctx)
        sr.cancel = cancel
        sr.running = true

        // Create ticker for interval execution
        sr.ticker = time.NewTicker(time.Duration(sr.config.Interval) * time.Second)
        sr.mutex.Unlock()

        defer func() </span><span class="cov8" title="1">{
                sr.mutex.Lock()
                sr.running = false
                sr.ticker.Stop()
                sr.mutex.Unlock()
        }</span>()

        // Run script immediately on start
        <span class="cov8" title="1">if err := sr.RunOnce(runCtx); err != nil </span><span class="cov8" title="1">{
                // Log error but continue running - this is expected behavior
                _ = err
        }</span>

        // Then run at intervals
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-runCtx.Done():<span class="cov8" title="1">
                        return</span>
                case &lt;-sr.ticker.C:<span class="cov0" title="0">
                        if err := sr.RunOnce(runCtx); err != nil </span><span class="cov0" title="0">{
                                // Log error but continue running - this is expected behavior
                                _ = err
                        }</span>
                }
        }
}

// Stop stops the script runner
func (sr *ScriptRunner) Stop() <span class="cov8" title="1">{
        sr.mutex.Lock()
        defer sr.mutex.Unlock()

        if sr.running &amp;&amp; sr.cancel != nil </span><span class="cov8" title="1">{
                sr.cancel()
        }</span>
}

// RunOnce executes the script once with optional arguments
func (sr *ScriptRunner) RunOnce(ctx context.Context, args ...string) error <span class="cov8" title="1">{
        startTime := time.Now()

        // Broadcast starting event
        if sr.eventBroadcaster != nil </span><span class="cov8" title="1">{
                startEvent := NewScriptStatusEvent(sr.config.Name, "starting", 0, 0)
                sr.eventBroadcaster.Broadcast(startEvent)
        }</span>

        // Create timeout context if timeout is specified
        <span class="cov8" title="1">if sr.config.Timeout &gt; 0 </span><span class="cov8" title="1">{
                timeoutCtx, cancel := context.WithTimeout(ctx, time.Duration(sr.config.Timeout)*time.Second)
                defer cancel()
                ctx = timeoutCtx
        }</span>

        // Execute the script
        <span class="cov8" title="1">result, err := sr.executor.ExecuteWithResult(ctx, args...)
        duration := time.Since(startTime).Milliseconds()

        // If LogManager is available, use it for structured logging
        if sr.logManager != nil </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        // Broadcast failed event if there was an execution error
                        if sr.eventBroadcaster != nil </span><span class="cov0" title="0">{
                                failedEvent := NewScriptStatusEvent(sr.config.Name, "failed", -1, duration)
                                sr.eventBroadcaster.Broadcast(failedEvent)
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }

                // Create log entry
                <span class="cov8" title="1">logEntry := &amp;LogEntry{
                        Timestamp:  result.Timestamp,
                        ScriptName: sr.config.Name,
                        ExitCode:   result.ExitCode,
                        Stdout:     result.Stdout,
                        Stderr:     result.Stderr,
                        Duration:   duration,
                }

                // Add to log manager
                logger := sr.logManager.GetLogger(sr.config.Name)
                if addErr := logger.AddEntry(logEntry); addErr != nil </span><span class="cov0" title="0">{
                        // Log error but don't fail the execution
                        fmt.Printf("Failed to add log entry: %v\n", addErr)
                }</span>

                // Broadcast completion or failure event
                <span class="cov8" title="1">if sr.eventBroadcaster != nil </span><span class="cov0" title="0">{
                        if result.ExitCode == 0 </span><span class="cov0" title="0">{
                                completedEvent := NewScriptStatusEvent(sr.config.Name, "completed", result.ExitCode, duration)
                                sr.eventBroadcaster.Broadcast(completedEvent)
                        }</span> else<span class="cov0" title="0"> {
                                failedEvent := NewScriptStatusEvent(sr.config.Name, "failed", result.ExitCode, duration)
                                sr.eventBroadcaster.Broadcast(failedEvent)
                        }</span>
                }

                <span class="cov8" title="1">if result.ExitCode != 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("script exited with code %d", result.ExitCode)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        // Handle case with event broadcaster but no log manager
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                // Broadcast failed event if there was an execution error
                if sr.eventBroadcaster != nil </span><span class="cov0" title="0">{
                        failedEvent := NewScriptStatusEvent(sr.config.Name, "failed", -1, duration)
                        sr.eventBroadcaster.Broadcast(failedEvent)
                }</span>
                <span class="cov8" title="1">return err</span>
        }

        // Broadcast completion or failure event
        <span class="cov8" title="1">if sr.eventBroadcaster != nil </span><span class="cov8" title="1">{
                if result.ExitCode == 0 </span><span class="cov8" title="1">{
                        completedEvent := NewScriptStatusEvent(sr.config.Name, "completed", result.ExitCode, duration)
                        sr.eventBroadcaster.Broadcast(completedEvent)
                }</span> else<span class="cov8" title="1"> {
                        failedEvent := NewScriptStatusEvent(sr.config.Name, "failed", result.ExitCode, duration)
                        sr.eventBroadcaster.Broadcast(failedEvent)
                }</span>
        }

        // Fallback to old executor method behavior
        <span class="cov8" title="1">if result.ExitCode != 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("script exited with code %d", result.ExitCode)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// IsRunning returns whether the script runner is currently running
func (sr *ScriptRunner) IsRunning() bool <span class="cov8" title="1">{
        sr.mutex.RLock()
        defer sr.mutex.RUnlock()
        return sr.running
}</span>

// GetConfig returns the script configuration
func (sr *ScriptRunner) GetConfig() ScriptConfig <span class="cov0" title="0">{
        return sr.config
}</span>
</pre>

		<pre class="file" id="file10" style="display: none">// Package service provides core functionality for the run-script-service daemon.
package service

import (
        "context"
        "fmt"
        "time"
)

// Service manages the execution of scripts at regular intervals
type Service struct {
        config     Config
        scriptPath string
        logPath    string
        configPath string
        maxLines   int
        running    bool
        ctx        context.Context
        cancel     context.CancelFunc
        executor   *Executor
}

// NewService creates a new service instance
func NewService(scriptPath, logPath, configPath string, maxLines int) *Service <span class="cov8" title="1">{
        s := &amp;Service{
                config:     Config{Interval: 3600}, // Default 1 hour
                scriptPath: scriptPath,
                logPath:    logPath,
                configPath: configPath,
                maxLines:   maxLines,
                running:    false,
        }

        s.ctx, s.cancel = context.WithCancel(context.Background())
        s.executor = NewExecutor(scriptPath, logPath, maxLines)

        // Load existing config if available
        if err := LoadConfig(configPath, &amp;s.config); err != nil </span><span class="cov0" title="0">{
                // Log error but continue with default config - this is expected behavior
                _ = err
        }</span>

        <span class="cov8" title="1">return s</span>
}

// SetInterval sets the execution interval and saves the configuration
func (s *Service) SetInterval(interval int) error <span class="cov8" title="1">{
        s.config.Interval = interval
        if err := SaveConfig(s.configPath, &amp;s.config); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">fmt.Printf("Interval set to %d seconds\n", interval)
        return nil</span>
}

// Start begins the service execution loop
func (s *Service) Start(ctx context.Context) <span class="cov8" title="1">{
        s.running = true
        fmt.Printf("Service started with %d second interval\n", s.config.Interval)

        ticker := time.NewTicker(time.Duration(s.config.Interval) * time.Second)
        defer ticker.Stop()

        // Execute immediately on start
        s.executeScript()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        fmt.Println("Service stopping...")
                        return</span>
                case &lt;-s.ctx.Done():<span class="cov8" title="1">
                        fmt.Println("Service stopping...")
                        return</span>
                case &lt;-ticker.C:<span class="cov8" title="1">
                        if s.running </span><span class="cov8" title="1">{
                                s.executeScript()
                        }</span>
                }
        }
}

// Stop stops the service
func (s *Service) Stop() <span class="cov8" title="1">{
        s.running = false
        s.cancel()
}</span>

// ShowConfig displays the current configuration
func (s *Service) ShowConfig() <span class="cov8" title="1">{
        fmt.Printf("Current configuration:\n")
        fmt.Printf("  Interval: %d seconds (%s)\n", s.config.Interval, formatDuration(s.config.Interval))
        fmt.Printf("  Script: %s\n", s.scriptPath)
        fmt.Printf("  Log: %s\n", s.logPath)
        fmt.Printf("  Config: %s\n", s.configPath)
}</span>

// executeScript executes the script and logs the result
func (s *Service) executeScript() <span class="cov8" title="1">{
        result := s.executor.ExecuteScript()
        fmt.Printf("Script executed at %s, exit code: %d\n",
                result.Timestamp.Format("2006-01-02 15:04:05"), result.ExitCode)
}</span>

// formatDuration formats seconds into a human-readable duration string
func formatDuration(seconds int) string <span class="cov8" title="1">{
        if seconds &lt; 60 </span><span class="cov8" title="1">{
                return fmt.Sprintf("%ds", seconds)
        }</span> else<span class="cov8" title="1"> if seconds &lt; 3600 </span><span class="cov8" title="1">{
                return fmt.Sprintf("%dm", seconds/60)
        }</span> else<span class="cov8" title="1"> {
                return fmt.Sprintf("%dh", seconds/3600)
        }</span>
}
</pre>

		<pre class="file" id="file11" style="display: none">package web

import (
        "run-script-service/service"
)

// EventBridge connects service events to WebSocket broadcasting
type EventBridge struct {
        wsHub            *WebSocketHub
        eventBroadcaster *service.EventBroadcaster
        events           chan *service.ScriptStatusEvent
        unsubscribe      func()
}

// NewEventBridge creates a bridge between service events and WebSocket hub
func NewEventBridge(wsHub *WebSocketHub, eventBroadcaster *service.EventBroadcaster) *EventBridge <span class="cov8" title="1">{
        events := make(chan *service.ScriptStatusEvent, 100)
        unsubscribe := eventBroadcaster.Subscribe(events)

        bridge := &amp;EventBridge{
                wsHub:            wsHub,
                eventBroadcaster: eventBroadcaster,
                events:           events,
                unsubscribe:      unsubscribe,
        }

        // Start processing events
        go bridge.processEvents()

        return bridge
}</span>

// processEvents processes script status events and broadcasts them via WebSocket
func (eb *EventBridge) processEvents() <span class="cov8" title="1">{
        for event := range eb.events </span><span class="cov8" title="1">{
                // Convert service event to WebSocket message format
                data := map[string]interface{}{
                        "script_name": event.ScriptName,
                        "status":      event.Status,
                        "exit_code":   event.ExitCode,
                        "duration":    event.Duration,
                        "timestamp":   event.Timestamp.Format("2006-01-02T15:04:05Z07:00"),
                }

                // Broadcast via WebSocket
                if err := eb.wsHub.BroadcastMessage("script_status", data); err != nil </span>{<span class="cov0" title="0">
                        // Log error but continue processing
                        // In a production system, you might want proper logging here
                }</span>
        }
}

// Close stops the event bridge
func (eb *EventBridge) Close() <span class="cov8" title="1">{
        if eb.unsubscribe != nil </span><span class="cov8" title="1">{
                eb.unsubscribe()
        }</span>
        <span class="cov8" title="1">close(eb.events)</span>
}
</pre>

		<pre class="file" id="file12" style="display: none">package web

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
)

// VuePackageJSON represents the structure of package.json for Vue.js project
type VuePackageJSON struct {
        Name            string            `json:"name"`
        Version         string            `json:"version"`
        Private         bool              `json:"private"`
        Scripts         map[string]string `json:"scripts"`
        Dependencies    map[string]string `json:"dependencies"`
        DevDependencies map[string]string `json:"devDependencies"`
}

// VueFrontendStructure defines the Vue.js frontend project structure
type VueFrontendStructure struct {
        BaseDir string
}

// NewVueFrontendStructure creates a new Vue frontend structure helper
func NewVueFrontendStructure(baseDir string) *VueFrontendStructure <span class="cov8" title="1">{
        return &amp;VueFrontendStructure{
                BaseDir: baseDir,
        }
}</span>

// setupVueFrontendStructure creates the Vue.js frontend directory structure
func setupVueFrontendStructure(frontendDir string) error <span class="cov8" title="1">{
        structure := NewVueFrontendStructure(frontendDir)
        return structure.Create()
}</span>

// Create builds the complete Vue.js frontend structure
func (vfs *VueFrontendStructure) Create() error <span class="cov8" title="1">{
        // Create directory structure
        if err := vfs.createDirectories(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create configuration files
        <span class="cov8" title="1">if err := vfs.createConfigurationFiles(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create source files
        <span class="cov8" title="1">if err := vfs.createSourceFiles(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// createDirectories creates the Vue.js directory structure
func (vfs *VueFrontendStructure) createDirectories() error <span class="cov8" title="1">{
        // Create main frontend directory
        if err := os.MkdirAll(vfs.BaseDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create frontend directory: %w", err)
        }</span>

        // Define Vue.js standard directory structure
        <span class="cov8" title="1">dirs := []string{
                "src",
                "src/components",
                "src/views",
                "src/composables",
                "src/services",
        }

        for _, dir := range dirs </span><span class="cov8" title="1">{
                dirPath := filepath.Join(vfs.BaseDir, dir)
                if err := os.MkdirAll(dirPath, 0755); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create directory %s: %w", dirPath, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// createConfigurationFiles creates configuration files for Vue.js project
func (vfs *VueFrontendStructure) createConfigurationFiles() error <span class="cov8" title="1">{
        configFiles := []func() error{
                vfs.createPackageJSON,
                vfs.createViteConfig,
                vfs.createIndexHTML,
        }

        for _, createFile := range configFiles </span><span class="cov8" title="1">{
                if err := createFile(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// createSourceFiles creates source code files for Vue.js project
func (vfs *VueFrontendStructure) createSourceFiles() error <span class="cov8" title="1">{
        sourceFiles := []func() error{
                vfs.createMainJS,
                vfs.createAppVue,
        }

        for _, createFile := range sourceFiles </span><span class="cov8" title="1">{
                if err := createFile(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// createPackageJSON creates the package.json file with Vue.js dependencies
func (vfs *VueFrontendStructure) createPackageJSON() error <span class="cov8" title="1">{
        packageJSON := VuePackageJSON{
                Name:    "run-script-service-frontend",
                Version: "1.0.0",
                Private: true,
                Scripts: map[string]string{
                        "serve": "vite",
                        "build": "vite build",
                        "dev":   "vite",
                },
                Dependencies: map[string]string{
                        "vue":          "^3.4.0",
                        "vue-router":   "^4.2.0",
                        "@vueuse/core": "^10.7.0",
                },
                DevDependencies: map[string]string{
                        "vite":               "^5.0.0",
                        "@vitejs/plugin-vue": "^4.5.0",
                        "sass":               "^1.69.0",
                },
        }

        data, err := json.MarshalIndent(packageJSON, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal package.json: %w", err)
        }</span>

        <span class="cov8" title="1">packagePath := filepath.Join(vfs.BaseDir, "package.json")
        return os.WriteFile(packagePath, data, 0644)</span>
}

// createViteConfig creates the vite.config.js file
func (vfs *VueFrontendStructure) createViteConfig() error <span class="cov8" title="1">{
        viteConfig := `import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

export default defineConfig({
  plugins: [vue()],
  base: '/static/',
  build: {
    outDir: '../static',
    assetsInlineLimit: 8192,
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['vue', 'vue-router']
        }
      }
    }
  }
})
`
        viteConfigPath := filepath.Join(vfs.BaseDir, "vite.config.js")
        return os.WriteFile(viteConfigPath, []byte(viteConfig), 0644)
}</span>

// createIndexHTML creates the index.html file
func (vfs *VueFrontendStructure) createIndexHTML() error <span class="cov8" title="1">{
        indexHTML := `&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
  &lt;title&gt;Run Script Service&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id="app"&gt;&lt;/div&gt;
  &lt;script type="module" src="/src/main.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
`
        indexPath := filepath.Join(vfs.BaseDir, "index.html")
        return os.WriteFile(indexPath, []byte(indexHTML), 0644)
}</span>

// createMainJS creates the main.js file
func (vfs *VueFrontendStructure) createMainJS() error <span class="cov8" title="1">{
        mainJS := `import { createApp } from 'vue'
import App from './App.vue'

createApp(App).mount('#app')
`
        mainJSPath := filepath.Join(vfs.BaseDir, "src", "main.js")
        return os.WriteFile(mainJSPath, []byte(mainJS), 0644)
}</span>

// createAppVue creates the App.vue file
func (vfs *VueFrontendStructure) createAppVue() error <span class="cov8" title="1">{
        appVue := `&lt;template&gt;
  &lt;div id="app"&gt;
    &lt;h1&gt;Run Script Service&lt;/h1&gt;
    &lt;p&gt;Vue.js frontend is loading...&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: 'App'
}
&lt;/script&gt;

&lt;style&gt;
#app {
  font-family: Avenir, Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
  color: #2c3e50;
  margin-top: 60px;
}
&lt;/style&gt;
`
        appVuePath := filepath.Join(vfs.BaseDir, "src", "App.vue")
        return os.WriteFile(appVuePath, []byte(appVue), 0644)
}</span>
</pre>

		<pre class="file" id="file13" style="display: none">// Package web provides file operation handlers for the HTTP API server
package web

import (
        "fmt"
        "net/http"
        "strings"

        "github.com/gin-gonic/gin"

        "run-script-service/service"
)

// FileOperationRequest represents a file operation request
type FileOperationRequest struct {
        Path    string `json:"path,omitempty"`
        Content string `json:"content,omitempty"`
}

// ValidationRequest represents a script validation request
type ValidationRequest struct {
        Content string `json:"content" binding:"required"`
}

// ValidationResponse represents validation results
type ValidationResponse struct {
        Valid  bool     `json:"valid"`
        Issues []string `json:"issues,omitempty"`
}

// SetFileManager sets the file manager for the web server
func (ws *WebServer) SetFileManager(fm *service.FileManager) <span class="cov8" title="1">{
        ws.fileManager = fm

        // Setup file routes now that file manager is available
        api := ws.router.Group("/api")
        ws.setupFileRoutes(api)
}</span>

// setupFileRoutes configures file operation API routes
func (ws *WebServer) setupFileRoutes(api *gin.RouterGroup) <span class="cov8" title="1">{
        if ws.fileManager == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // File operation endpoints
        <span class="cov8" title="1">api.GET("/files/*path", ws.handleGetFile)
        api.PUT("/files/*path", ws.handlePutFile)
        api.POST("/files/validate", ws.handleValidateFile)
        api.GET("/files-list/*path", ws.handleListFiles)</span>
}

// handleGetFile reads and returns a file's content
func (ws *WebServer) handleGetFile(c *gin.Context) <span class="cov8" title="1">{
        if ws.fileManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "File manager not initialized",
                })
                return
        }</span>

        // Extract path from URL parameter
        <span class="cov8" title="1">filePath := c.Param("path")
        if filePath == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   "File path is required",
                })
                return
        }</span>

        // Remove leading slash from path parameter
        <span class="cov8" title="1">if filePath[0] == '/' </span><span class="cov8" title="1">{
                filePath = filePath[1:]
        }</span>

        <span class="cov8" title="1">fileContent, err := ws.fileManager.ReadFile(filePath)
        if err != nil </span><span class="cov8" title="1">{
                statusCode := http.StatusInternalServerError
                if err.Error() == "access denied: path not allowed" </span><span class="cov8" title="1">{
                        statusCode = http.StatusForbidden
                }</span> else<span class="cov8" title="1"> if strings.Contains(err.Error(), "no such file or directory") </span><span class="cov8" title="1">{
                        statusCode = http.StatusNotFound
                }</span>

                <span class="cov8" title="1">c.JSON(statusCode, APIResponse{
                        Success: false,
                        Error:   err.Error(),
                })
                return</span>
        }

        <span class="cov8" title="1">c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data:    fileContent,
        })</span>
}

// handlePutFile writes content to a file
func (ws *WebServer) handlePutFile(c *gin.Context) <span class="cov8" title="1">{
        if ws.fileManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "File manager not initialized",
                })
                return
        }</span>

        // Extract path from URL parameter
        <span class="cov8" title="1">filePath := c.Param("path")
        if filePath == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   "File path is required",
                })
                return
        }</span>

        // Remove leading slash from path parameter
        <span class="cov8" title="1">if filePath[0] == '/' </span><span class="cov8" title="1">{
                filePath = filePath[1:]
        }</span>

        <span class="cov8" title="1">var request FileOperationRequest
        if err := c.ShouldBindJSON(&amp;request); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   fmt.Sprintf("Invalid request body: %v", err),
                })
                return
        }</span>

        // Use content from request body
        <span class="cov8" title="1">content := request.Content

        err := ws.fileManager.WriteFile(filePath, content)
        if err != nil </span><span class="cov8" title="1">{
                statusCode := http.StatusInternalServerError
                if err.Error() == "access denied: path not allowed" </span><span class="cov8" title="1">{
                        statusCode = http.StatusForbidden
                }</span>

                <span class="cov8" title="1">c.JSON(statusCode, APIResponse{
                        Success: false,
                        Error:   err.Error(),
                })
                return</span>
        }

        <span class="cov8" title="1">c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data: map[string]interface{}{
                        "message": fmt.Sprintf("File '%s' written successfully", filePath),
                        "path":    filePath,
                },
        })</span>
}

// handleValidateFile validates script syntax
func (ws *WebServer) handleValidateFile(c *gin.Context) <span class="cov8" title="1">{
        if ws.fileManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "File manager not initialized",
                })
                return
        }</span>

        <span class="cov8" title="1">var request ValidationRequest
        if err := c.ShouldBindJSON(&amp;request); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   fmt.Sprintf("Invalid request body: %v", err),
                })
                return
        }</span>

        <span class="cov8" title="1">issues := ws.fileManager.ValidateScriptSyntax(request.Content)

        response := ValidationResponse{
                Valid:  len(issues) == 0,
                Issues: issues,
        }

        c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data:    response,
        })</span>
}

// handleListFiles lists files in a directory
func (ws *WebServer) handleListFiles(c *gin.Context) <span class="cov8" title="1">{
        if ws.fileManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "File manager not initialized",
                })
                return
        }</span>

        // Extract path from URL parameter
        <span class="cov8" title="1">dirPath := c.Param("path")
        if dirPath == "" </span><span class="cov0" title="0">{
                dirPath = "." // Default to current directory
        }</span>

        // Remove leading slash from path parameter
        <span class="cov8" title="1">if dirPath[0] == '/' </span><span class="cov8" title="1">{
                dirPath = dirPath[1:]
        }</span>

        <span class="cov8" title="1">files, err := ws.fileManager.ListFiles(dirPath)
        if err != nil </span><span class="cov8" title="1">{
                statusCode := http.StatusInternalServerError
                if err.Error() == "access denied: path not allowed" </span><span class="cov8" title="1">{
                        statusCode = http.StatusForbidden
                }</span> else<span class="cov0" title="0"> if strings.Contains(err.Error(), "no such file or directory") </span><span class="cov0" title="0">{
                        statusCode = http.StatusNotFound
                }</span>

                <span class="cov8" title="1">c.JSON(statusCode, APIResponse{
                        Success: false,
                        Error:   err.Error(),
                })
                return</span>
        }

        // Convert file info to JSON-serializable format
        <span class="cov8" title="1">fileList := make([]map[string]interface{}, len(files))
        for i, file := range files </span><span class="cov8" title="1">{
                fileList[i] = map[string]interface{}{
                        "name":     file.Name(),
                        "size":     file.Size(),
                        "mode":     file.Mode().String(),
                        "is_dir":   file.IsDir(),
                        "mod_time": file.ModTime().Unix(),
                }
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data:    fileList,
        })</span>
}
</pre>

		<pre class="file" id="file14" style="display: none">// Package web provides HTTP API server functionality
package web

import (
        "context"
        "embed"
        "fmt"
        "io"
        "io/fs"
        "net/http"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/gin-contrib/cors"
        "github.com/gin-gonic/gin"

        "run-script-service/service"
)

//go:embed frontend/dist/*
var frontendFS embed.FS

// WebServer represents the HTTP API server
type WebServer struct {
        router        *gin.Engine
        service       *service.Service
        scriptManager *service.ScriptManager
        fileManager   *service.FileManager
        wsHub         *WebSocketHub
        systemMonitor *service.SystemMonitor
        port          int
}

// APIResponse represents the standard API response format
type APIResponse struct {
        Success bool        `json:"success"`
        Data    interface{} `json:"data,omitempty"`
        Error   string      `json:"error,omitempty"`
}

// NewWebServer creates a new web server instance
func NewWebServer(svc *service.Service, port int) *WebServer <span class="cov8" title="1">{
        // Set Gin to release mode for production
        gin.SetMode(gin.ReleaseMode)

        router := gin.New()

        // Add middleware
        router.Use(gin.Logger())
        router.Use(gin.Recovery())
        router.Use(cors.Default())

        // Create WebSocket hub
        wsHub := NewWebSocketHub()
        go wsHub.Run()

        server := &amp;WebServer{
                router:  router,
                service: svc,
                wsHub:   wsHub,
                port:    port,
        }

        // Setup routes
        server.setupRoutes()

        return server
}</span>

// SetScriptManager sets the script manager for the web server
func (ws *WebServer) SetScriptManager(sm *service.ScriptManager) <span class="cov8" title="1">{
        ws.scriptManager = sm
}</span>

// GetWebSocketHub returns the WebSocket hub for broadcasting messages
func (ws *WebServer) GetWebSocketHub() *WebSocketHub <span class="cov0" title="0">{
        return ws.wsHub
}</span>

// SetSystemMonitor sets the system monitor for the web server
func (ws *WebServer) SetSystemMonitor(monitor *service.SystemMonitor) <span class="cov8" title="1">{
        ws.systemMonitor = monitor
}</span>

// StartSystemMetricsBroadcasting starts periodic system metrics broadcasting via WebSocket
func (ws *WebServer) StartSystemMetricsBroadcasting(ctx context.Context, interval time.Duration) error <span class="cov8" title="1">{
        if ws.systemMonitor == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("system monitor not configured")
        }</span>

        // Create event publisher that broadcasts via WebSocket
        <span class="cov8" title="1">publisher := func(msgType string, data map[string]interface{}) error </span><span class="cov0" title="0">{
                if ws.wsHub != nil </span><span class="cov0" title="0">{
                        return ws.wsHub.BroadcastMessage(msgType, data)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        // Start periodic broadcasting in a goroutine
        <span class="cov8" title="1">go ws.systemMonitor.StartPeriodicBroadcasting(ctx, interval, publisher)

        return nil</span>
}

// setupRoutes configures all API routes
func (ws *WebServer) setupRoutes() <span class="cov8" title="1">{
        // Create a sub filesystem for the dist directory
        distFS, err := fs.Sub(frontendFS, "frontend/dist")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("DEBUG: embed fs.Sub failed: %v, using fallback\n", err)
                // Fallback to file system if embed fails (development mode)
                ws.router.Static("/static", "./web/frontend/dist")
                ws.router.GET("/", func(c *gin.Context) </span><span class="cov0" title="0">{
                        c.File("./web/frontend/dist/index.html")
                }</span>)
        } else<span class="cov8" title="1"> {
                fmt.Println("DEBUG: Using embedded filesystem")
                // Use embedded filesystem for static files
                ws.router.StaticFS("/static", http.FS(distFS))

                // Root route serves index.html from embedded FS
                ws.router.GET("/", func(c *gin.Context) </span><span class="cov8" title="1">{
                        indexFile, err := distFS.Open("index.html")
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("DEBUG: Failed to open embedded index.html: %v\n", err)
                                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to load frontend"})
                                return
                        }</span>
                        <span class="cov8" title="1">defer indexFile.Close()

                        c.Header("Content-Type", "text/html")
                        http.ServeContent(c.Writer, c.Request, "index.html", time.Now(), indexFile.(io.ReadSeeker))</span>
                })

                // Serve index.html for SPA routes (NoRoute handler)
                <span class="cov8" title="1">ws.router.NoRoute(func(c *gin.Context) </span><span class="cov8" title="1">{
                        path := c.Request.URL.Path

                        // If it's an API route, let it 404
                        if strings.HasPrefix(path, "/api/") || strings.HasPrefix(path, "/ws") </span><span class="cov8" title="1">{
                                c.JSON(http.StatusNotFound, gin.H{"error": "Not found"})
                                return
                        }</span>

                        // For all other routes, serve index.html (Vue.js SPA)
                        <span class="cov8" title="1">indexFile, err := distFS.Open("index.html")
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("DEBUG: Failed to open embedded index.html in NoRoute: %v\n", err)
                                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to load frontend"})
                                return
                        }</span>
                        <span class="cov8" title="1">defer indexFile.Close()

                        c.Header("Content-Type", "text/html")
                        http.ServeContent(c.Writer, c.Request, "index.html", time.Now(), indexFile.(io.ReadSeeker))</span>
                })
        }

        // WebSocket endpoint
        <span class="cov8" title="1">ws.router.GET("/ws", func(c *gin.Context) </span><span class="cov8" title="1">{
                HandleWebSocket(ws.wsHub, c)
        }</span>)

        <span class="cov8" title="1">api := ws.router.Group("/api")

        // System status endpoint
        api.GET("/status", ws.handleStatus)

        // Script management endpoints
        api.GET("/scripts", ws.handleGetScripts)
        api.POST("/scripts", ws.handlePostScript)
        api.GET("/scripts/:name", ws.handleGetScript)
        api.PUT("/scripts/:name", ws.handleUpdateScript)
        api.DELETE("/scripts/:name", ws.handleDeleteScript)
        api.POST("/scripts/:name/run", ws.handleRunScript)
        api.POST("/scripts/:name/enable", ws.handleEnableScript)
        api.POST("/scripts/:name/disable", ws.handleDisableScript)

        // Log management endpoints
        api.GET("/logs", ws.handleGetLogs)
        api.GET("/logs/:script", ws.handleGetScriptLogs)
        api.GET("/logs/raw/:script", ws.handleGetRawLogs) // New simple endpoint
        api.DELETE("/logs/:script", ws.handleClearScriptLogs)

        // Configuration endpoints
        api.GET("/config", ws.handleGetConfig)
        api.PUT("/config", ws.handleUpdateConfig)</span>
}

// handleStatus returns system status information
func (ws *WebServer) handleStatus(c *gin.Context) <span class="cov8" title="1">{
        uptime := "Unknown"
        runningScripts := 0
        totalScripts := 0

        // Get script counts if script manager is available
        if ws.scriptManager != nil </span><span class="cov0" title="0">{
                config := ws.scriptManager.GetConfig()
                totalScripts = len(config.Scripts)

                // Count running/enabled scripts
                for _, script := range config.Scripts </span><span class="cov0" title="0">{
                        if script.Enabled &amp;&amp; ws.scriptManager.IsScriptRunning(script.Name) </span><span class="cov0" title="0">{
                                runningScripts++
                        }</span>
                }
        }

        // Calculate uptime if system monitor is available
        <span class="cov8" title="1">if ws.systemMonitor != nil </span><span class="cov0" title="0">{
                uptimeStr := ws.systemMonitor.GetUptime()
                if uptimeStr != "" </span><span class="cov0" title="0">{
                        uptime = uptimeStr
                }</span>
        }

        <span class="cov8" title="1">statusData := map[string]interface{}{
                "status":         "running",
                "uptime":         uptime,
                "runningScripts": runningScripts,
                "totalScripts":   totalScripts,
        }

        c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data:    statusData,
        })</span>
}

// handleGetScripts returns all scripts
func (ws *WebServer) handleGetScripts(c *gin.Context) <span class="cov8" title="1">{
        if ws.scriptManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "Script manager not initialized",
                })
                return
        }</span>

        // Get script configs from the manager
        <span class="cov8" title="1">var scripts []map[string]interface{}
        for _, scriptConfig := range ws.scriptManager.GetConfig().Scripts </span><span class="cov8" title="1">{
                running := ws.scriptManager.IsScriptRunning(scriptConfig.Name)

                scripts = append(scripts, map[string]interface{}{
                        "name":          scriptConfig.Name,
                        "path":          scriptConfig.Path,
                        "interval":      scriptConfig.Interval,
                        "enabled":       scriptConfig.Enabled,
                        "max_log_lines": scriptConfig.MaxLogLines,
                        "timeout":       scriptConfig.Timeout,
                        "running":       running,
                })
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data:    scripts,
        })</span>
}

// handlePostScript creates a new script
func (ws *WebServer) handlePostScript(c *gin.Context) <span class="cov8" title="1">{
        if ws.scriptManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "Script manager not initialized",
                })
                return
        }</span>

        <span class="cov8" title="1">var scriptConfig service.ScriptConfig
        if err := c.ShouldBindJSON(&amp;scriptConfig); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   fmt.Sprintf("Invalid request body: %v", err),
                })
                return
        }</span>

        // Validate required fields
        <span class="cov8" title="1">if scriptConfig.Name == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   "Script name is required",
                })
                return
        }</span>

        <span class="cov8" title="1">if scriptConfig.Path == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   "Script path is required",
                })
                return
        }</span>

        // Set defaults for optional fields
        <span class="cov8" title="1">if scriptConfig.Interval &lt;= 0 </span><span class="cov0" title="0">{
                scriptConfig.Interval = 60 // Default to 1 minute
        }</span>
        <span class="cov8" title="1">if scriptConfig.MaxLogLines &lt;= 0 </span><span class="cov0" title="0">{
                scriptConfig.MaxLogLines = 100 // Default to 100 lines
        }</span>

        // Add the script
        <span class="cov8" title="1">if err := ws.scriptManager.AddScript(scriptConfig); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusConflict, APIResponse{
                        Success: false,
                        Error:   err.Error(),
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusCreated, APIResponse{
                Success: true,
                Data: map[string]interface{}{
                        "name":          scriptConfig.Name,
                        "path":          scriptConfig.Path,
                        "interval":      scriptConfig.Interval,
                        "enabled":       scriptConfig.Enabled,
                        "max_log_lines": scriptConfig.MaxLogLines,
                        "timeout":       scriptConfig.Timeout,
                },
        })</span>
}

// handleRunScript executes a script once
func (ws *WebServer) handleRunScript(c *gin.Context) <span class="cov8" title="1">{
        if ws.scriptManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "Script manager not initialized",
                })
                return
        }</span>

        <span class="cov8" title="1">scriptName := c.Param("name")
        if scriptName == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   "Script name is required",
                })
                return
        }</span>

        // Run the script with a timeout context
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(c.Request.Context(), 30*time.Second)
        defer cancel()

        if err := ws.scriptManager.RunScriptOnce(ctx, scriptName); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusNotFound, APIResponse{
                        Success: false,
                        Error:   err.Error(),
                })
                return
        }</span>

        // Note: Logs are now handled via raw file access in /logs/raw/:script endpoint

        <span class="cov0" title="0">c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data: map[string]interface{}{
                        "message": fmt.Sprintf("Script %s executed successfully", scriptName),
                        "script":  scriptName,
                },
        })</span>
}

// handleGetScript returns information about a specific script
func (ws *WebServer) handleGetScript(c *gin.Context) <span class="cov8" title="1">{
        if ws.scriptManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "Script manager not initialized",
                })
                return
        }</span>

        <span class="cov8" title="1">scriptName := c.Param("name")
        if scriptName == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   "Script name is required",
                })
                return
        }</span>

        // Find the script in configuration
        <span class="cov8" title="1">config := ws.scriptManager.GetConfig()
        for _, scriptConfig := range config.Scripts </span><span class="cov8" title="1">{
                if scriptConfig.Name == scriptName </span><span class="cov8" title="1">{
                        running := ws.scriptManager.IsScriptRunning(scriptConfig.Name)

                        scriptData := map[string]interface{}{
                                "name":          scriptConfig.Name,
                                "path":          scriptConfig.Path,
                                "interval":      scriptConfig.Interval,
                                "enabled":       scriptConfig.Enabled,
                                "max_log_lines": scriptConfig.MaxLogLines,
                                "timeout":       scriptConfig.Timeout,
                                "running":       running,
                        }

                        c.JSON(http.StatusOK, APIResponse{
                                Success: true,
                                Data:    scriptData,
                        })
                        return
                }</span>
        }

        <span class="cov8" title="1">c.JSON(http.StatusNotFound, APIResponse{
                Success: false,
                Error:   fmt.Sprintf("Script '%s' not found", scriptName),
        })</span>
}

// handleUpdateScript updates a script configuration
func (ws *WebServer) handleUpdateScript(c *gin.Context) <span class="cov8" title="1">{
        if ws.scriptManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "Script manager not initialized",
                })
                return
        }</span>

        <span class="cov8" title="1">scriptName := c.Param("name")
        if scriptName == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   "Script name is required",
                })
                return
        }</span>

        <span class="cov8" title="1">var updateData service.ScriptConfig
        if err := c.ShouldBindJSON(&amp;updateData); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   fmt.Sprintf("Invalid request body: %v", err),
                })
                return
        }</span>

        // Set defaults for optional fields
        <span class="cov8" title="1">if updateData.Interval &lt;= 0 </span><span class="cov0" title="0">{
                updateData.Interval = 60 // Default to 1 minute
        }</span>
        <span class="cov8" title="1">if updateData.MaxLogLines &lt;= 0 </span><span class="cov0" title="0">{
                updateData.MaxLogLines = 100 // Default to 100 lines
        }</span>

        // Update the script
        <span class="cov8" title="1">if err := ws.scriptManager.UpdateScript(scriptName, updateData); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusNotFound, APIResponse{
                        Success: false,
                        Error:   err.Error(),
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data: map[string]interface{}{
                        "message":       fmt.Sprintf("Script %s updated successfully", scriptName),
                        "script":        scriptName,
                        "name":          updateData.Name,
                        "path":          updateData.Path,
                        "interval":      updateData.Interval,
                        "enabled":       updateData.Enabled,
                        "max_log_lines": updateData.MaxLogLines,
                        "timeout":       updateData.Timeout,
                },
        })</span>
}

// handleDeleteScript removes a script
func (ws *WebServer) handleDeleteScript(c *gin.Context) <span class="cov8" title="1">{
        if ws.scriptManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "Script manager not initialized",
                })
                return
        }</span>

        <span class="cov8" title="1">scriptName := c.Param("name")
        if scriptName == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   "Script name is required",
                })
                return
        }</span>

        // Remove the script
        <span class="cov8" title="1">if err := ws.scriptManager.RemoveScript(scriptName); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusNotFound, APIResponse{
                        Success: false,
                        Error:   err.Error(),
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data: map[string]interface{}{
                        "message": fmt.Sprintf("Script %s deleted successfully", scriptName),
                        "script":  scriptName,
                },
        })</span>
}

// handleScriptToggle handles both enable and disable script operations
func (ws *WebServer) handleScriptToggle(c *gin.Context, enable bool) <span class="cov8" title="1">{
        if ws.scriptManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "Script manager not initialized",
                })
                return
        }</span>

        <span class="cov8" title="1">scriptName := c.Param("name")
        if scriptName == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   "Script name is required",
                })
                return
        }</span>

        <span class="cov8" title="1">var err error
        var action string
        if enable </span><span class="cov8" title="1">{
                err = ws.scriptManager.EnableScript(scriptName)
                action = "enabled"
        }</span> else<span class="cov8" title="1"> {
                err = ws.scriptManager.DisableScript(scriptName)
                action = "disabled"
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, APIResponse{
                        Success: false,
                        Error:   err.Error(),
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data: map[string]interface{}{
                        "message": fmt.Sprintf("Script %s %s successfully", scriptName, action),
                        "script":  scriptName,
                        "enabled": enable,
                },
        })</span>
}

// handleEnableScript enables a script
func (ws *WebServer) handleEnableScript(c *gin.Context) <span class="cov8" title="1">{
        ws.handleScriptToggle(c, true)
}</span>

// handleDisableScript disables a script
func (ws *WebServer) handleDisableScript(c *gin.Context) <span class="cov8" title="1">{
        ws.handleScriptToggle(c, false)
}</span>

// handleGetLogs returns raw log content (simplified approach)
func (ws *WebServer) handleGetLogs(c *gin.Context) <span class="cov8" title="1">{
        scriptName := c.Query("script")

        // If no script specified, return empty content
        if scriptName == "" </span><span class="cov8" title="1">{
                c.JSON(http.StatusOK, APIResponse{
                        Success: true,
                        Data: map[string]interface{}{
                                "content": "",
                                "script":  "",
                        },
                })
                return
        }</span>

        // Get log file path
        <span class="cov0" title="0">dir, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                dir, _ = os.Getwd()
        }</span> else<span class="cov0" title="0"> {
                dir = filepath.Dir(dir)
        }</span>

        <span class="cov0" title="0">logFile := filepath.Join(dir, fmt.Sprintf("%s.log", scriptName))

        // Check if log file exists
        if _, err := os.Stat(logFile); os.IsNotExist(err) </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, APIResponse{
                        Success: true,
                        Data: map[string]interface{}{
                                "content": "",
                                "script":  scriptName,
                                "message": "No log file found",
                        },
                })
                return
        }</span>

        // Read raw log file content
        <span class="cov0" title="0">content, err := os.ReadFile(logFile)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   fmt.Sprintf("Failed to read log file: %v", err),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data: map[string]interface{}{
                        "content": string(content),
                        "script":  scriptName,
                },
        })</span>
}

// handleGetScriptLogs returns raw log content for a specific script
func (ws *WebServer) handleGetScriptLogs(c *gin.Context) <span class="cov8" title="1">{
        scriptName := c.Param("script")
        if scriptName == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   "Script name is required",
                })
                return
        }</span>

        // Get log file path
        <span class="cov8" title="1">dir, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                dir, _ = os.Getwd()
        }</span> else<span class="cov8" title="1"> {
                dir = filepath.Dir(dir)
        }</span>

        <span class="cov8" title="1">logFile := filepath.Join(dir, fmt.Sprintf("%s.log", scriptName))

        // Check if log file exists
        if _, err := os.Stat(logFile); os.IsNotExist(err) </span><span class="cov8" title="1">{
                c.JSON(http.StatusOK, APIResponse{
                        Success: true,
                        Data: map[string]interface{}{
                                "content": "",
                                "script":  scriptName,
                                "message": "No log file found",
                        },
                })
                return
        }</span>

        // Read raw log file content
        <span class="cov0" title="0">content, err := os.ReadFile(logFile)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   fmt.Sprintf("Failed to read log file: %v", err),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data: map[string]interface{}{
                        "content": string(content),
                        "script":  scriptName,
                },
        })</span>
}

// handleClearScriptLogs clears logs for a specific script (simplified)
func (ws *WebServer) handleClearScriptLogs(c *gin.Context) <span class="cov0" title="0">{
        scriptName := c.Param("script")
        if scriptName == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   "Script name is required",
                })
                return
        }</span>

        // Get log file path
        <span class="cov0" title="0">dir, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                dir, _ = os.Getwd()
        }</span> else<span class="cov0" title="0"> {
                dir = filepath.Dir(dir)
        }</span>

        <span class="cov0" title="0">logFile := filepath.Join(dir, fmt.Sprintf("%s.log", scriptName))

        // Clear the log file by truncating it
        if err := os.Truncate(logFile, 0); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   fmt.Sprintf("Failed to clear log file: %v", err),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data: map[string]interface{}{
                        "message": fmt.Sprintf("Logs cleared for script %s", scriptName),
                        "script":  scriptName,
                },
        })</span>
}

// handleGetRawLogs returns raw log file content (simple approach)
func (ws *WebServer) handleGetRawLogs(c *gin.Context) <span class="cov0" title="0">{
        scriptName := c.Param("script")
        if scriptName == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   "Script name is required",
                })
                return
        }</span>

        // Get log file path
        <span class="cov0" title="0">dir, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                dir, _ = os.Getwd()
        }</span> else<span class="cov0" title="0"> {
                dir = filepath.Dir(dir)
        }</span>

        <span class="cov0" title="0">logFile := filepath.Join(dir, fmt.Sprintf("%s.log", scriptName))

        // Check if log file exists
        if _, err := os.Stat(logFile); os.IsNotExist(err) </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, APIResponse{
                        Success: true,
                        Data: map[string]interface{}{
                                "script":  scriptName,
                                "content": "",
                                "message": "No log file found",
                        },
                })
                return
        }</span>

        // Read log file content
        <span class="cov0" title="0">content, err := os.ReadFile(logFile)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   fmt.Sprintf("Failed to read log file: %v", err),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data: map[string]interface{}{
                        "script":  scriptName,
                        "content": string(content),
                },
        })</span>
}

// ConfigResponse represents the configuration format expected by the frontend
type ConfigResponse struct {
        WebPort      int    `json:"webPort"`
        Interval     string `json:"interval"`
        LogRetention int    `json:"logRetention"`
        AutoRefresh  bool   `json:"autoRefresh"`
}

// handleGetConfig returns system configuration
func (ws *WebServer) handleGetConfig(c *gin.Context) <span class="cov0" title="0">{
        if ws.scriptManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "Script manager not initialized",
                })
                return
        }</span>

        <span class="cov0" title="0">config := ws.scriptManager.GetConfig()

        // Convert to frontend-expected format
        response := ConfigResponse{
                WebPort:      config.WebPort,
                Interval:     "1h", // default interval as string
                LogRetention: 100,  // default log retention
                AutoRefresh:  true, // default auto-refresh setting
        }

        c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data:    response,
        })</span>
}

// handleUpdateConfig updates system configuration
func (ws *WebServer) handleUpdateConfig(c *gin.Context) <span class="cov8" title="1">{
        if ws.scriptManager == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   "Script manager not initialized",
                })
                return
        }</span>

        <span class="cov8" title="1">var updateData map[string]interface{}
        if err := c.ShouldBindJSON(&amp;updateData); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, APIResponse{
                        Success: false,
                        Error:   fmt.Sprintf("Invalid request body: %v", err),
                })
                return
        }</span>

        // Get current configuration
        <span class="cov8" title="1">config := ws.scriptManager.GetConfig()

        // Update web port if provided (handle both camelCase and snake_case)
        if webPort, ok := updateData["webPort"]; ok </span><span class="cov0" title="0">{
                if port, isFloat := webPort.(float64); isFloat </span><span class="cov0" title="0">{
                        if port &gt;= 1 &amp;&amp; port &lt;= 65535 </span><span class="cov0" title="0">{
                                config.WebPort = int(port)
                        }</span> else<span class="cov0" title="0"> {
                                c.JSON(http.StatusBadRequest, APIResponse{
                                        Success: false,
                                        Error:   "Web port must be between 1 and 65535",
                                })
                                return
                        }</span>
                } else<span class="cov0" title="0"> {
                        c.JSON(http.StatusBadRequest, APIResponse{
                                Success: false,
                                Error:   "Web port must be a number",
                        })
                        return
                }</span>
        } else<span class="cov8" title="1"> if webPort, ok := updateData["web_port"]; ok </span><span class="cov8" title="1">{
                if port, isFloat := webPort.(float64); isFloat </span><span class="cov8" title="1">{
                        if port &gt;= 1 &amp;&amp; port &lt;= 65535 </span><span class="cov8" title="1">{
                                config.WebPort = int(port)
                        }</span> else<span class="cov0" title="0"> {
                                c.JSON(http.StatusBadRequest, APIResponse{
                                        Success: false,
                                        Error:   "Web port must be between 1 and 65535",
                                })
                                return
                        }</span>
                } else<span class="cov0" title="0"> {
                        c.JSON(http.StatusBadRequest, APIResponse{
                                Success: false,
                                Error:   "Web port must be a number",
                        })
                        return
                }</span>
        }

        // Save updated configuration
        <span class="cov8" title="1">if err := ws.scriptManager.SaveConfig(); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, APIResponse{
                        Success: false,
                        Error:   fmt.Sprintf("Failed to save configuration: %v", err),
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, APIResponse{
                Success: true,
                Data: map[string]interface{}{
                        "message": "Configuration updated successfully",
                        "config":  config,
                },
        })</span>
}

// Start starts the web server
func (ws *WebServer) Start() error <span class="cov0" title="0">{
        addr := fmt.Sprintf(":%d", ws.port)
        return ws.router.Run(addr)
}</span>
</pre>

		<pre class="file" id="file15" style="display: none">package web

import (
        "fmt"
        "os"
        "path/filepath"
)

// VueBuildManager handles the Vue.js frontend build process
type VueBuildManager struct {
        ProjectRoot string
        FrontendDir string
        StaticDir   string
}

// NewVueBuildManager creates a new Vue build manager
func NewVueBuildManager(projectRoot string) *VueBuildManager <span class="cov8" title="1">{
        return &amp;VueBuildManager{
                ProjectRoot: projectRoot,
                FrontendDir: filepath.Join(projectRoot, "web", "frontend"),
                StaticDir:   filepath.Join(projectRoot, "web", "frontend", "dist"),
        }
}</span>

// InitializeFrontendProject sets up the complete Vue.js frontend project structure
func (vbm *VueBuildManager) InitializeFrontendProject() error <span class="cov0" title="0">{
        // Create main frontend directory
        if err := os.MkdirAll(vbm.FrontendDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create frontend directory: %w", err)
        }</span>

        // Initialize TypeScript Vue project (new approach)
        <span class="cov0" title="0">if err := vbm.initializeTypeScriptProject(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize TypeScript project: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// initializeTypeScriptProject sets up a complete TypeScript + Vue.js project
func (vbm *VueBuildManager) initializeTypeScriptProject() error <span class="cov0" title="0">{
        // For now, we assume the TypeScript frontend files are already in place
        // This method validates that all required TypeScript files exist

        // Check if TypeScript files exist (they should have been created by external process)
        requiredFiles := []string{
                "package.json",
                "tsconfig.json",
                "vite.config.ts",
                "vitest.config.ts",
                "index.html",
                "src/main.ts",
                "src/App.vue",
                "src/router/index.ts",
                "src/types/api.ts",
                "src/services/api.ts",
                "src/composables/useScripts.ts",
                "src/composables/useLogs.ts",
                "src/composables/useSystemMetrics.ts",
                "src/composables/useWebSocket.ts",
                "src/views/Dashboard.vue",
                "src/style.css",
                "tests/setup.ts",
                "tests/unit/services/api.test.ts",
                "tests/unit/composables/useScripts.test.ts",
                "tests/unit/components/Dashboard.test.ts",
        }

        missingFiles := []string{}
        for _, file := range requiredFiles </span><span class="cov0" title="0">{
                filePath := filepath.Join(vbm.FrontendDir, file)
                if _, err := os.Stat(filePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        missingFiles = append(missingFiles, file)
                }</span>
        }

        <span class="cov0" title="0">if len(missingFiles) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("missing required TypeScript files: %v", missingFiles)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetFrontendDir returns the frontend directory path
func (vbm *VueBuildManager) GetFrontendDir() string <span class="cov8" title="1">{
        return vbm.FrontendDir
}</span>

// GetStaticDir returns the static directory path
func (vbm *VueBuildManager) GetStaticDir() string <span class="cov8" title="1">{
        return vbm.StaticDir
}</span>

// CheckFrontendExists checks if the frontend directory structure exists
func (vbm *VueBuildManager) CheckFrontendExists() bool <span class="cov0" title="0">{
        requiredPaths := []string{
                filepath.Join(vbm.FrontendDir, "package.json"),
                filepath.Join(vbm.FrontendDir, "src", "main.ts"),
                filepath.Join(vbm.FrontendDir, "src", "App.vue"),
                filepath.Join(vbm.FrontendDir, "tsconfig.json"),
                filepath.Join(vbm.FrontendDir, "vite.config.ts"),
        }

        for _, path := range requiredPaths </span><span class="cov0" title="0">{
                if _, err := os.Stat(path); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}
</pre>

		<pre class="file" id="file16" style="display: none">package web

import (
        "encoding/json"
        "log"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/gorilla/websocket"
)

// WebSocketMessage represents a message sent through WebSocket
type WebSocketMessage struct {
        Type      string                 `json:"type"`
        Timestamp time.Time              `json:"timestamp"`
        Data      map[string]interface{} `json:"data"`
}

var upgrader = websocket.Upgrader{
        CheckOrigin: func(r *http.Request) bool <span class="cov0" title="0">{
                return true // Allow connections from any origin
        }</span>,
}

// WebSocketClient represents a connected WebSocket client
type WebSocketClient struct {
        hub  *WebSocketHub
        conn *websocket.Conn
        send chan []byte
}

// WebSocketHub manages WebSocket connections and message broadcasting
type WebSocketHub struct {
        // Registered clients
        clients map[*WebSocketClient]bool

        // Inbound messages from the clients
        broadcast chan []byte

        // Register requests from the clients
        register chan *WebSocketClient

        // Unregister requests from clients
        unregister chan *WebSocketClient

        // Maximum number of concurrent connections
        maxConnections int
}

const (
        // MaxWebSocketConnections defines the maximum number of concurrent WebSocket connections
        MaxWebSocketConnections = 100
)

// NewWebSocketHub creates a new WebSocket hub
func NewWebSocketHub() *WebSocketHub <span class="cov8" title="1">{
        return &amp;WebSocketHub{
                broadcast:      make(chan []byte, 256),
                register:       make(chan *WebSocketClient),
                unregister:     make(chan *WebSocketClient),
                clients:        make(map[*WebSocketClient]bool),
                maxConnections: MaxWebSocketConnections,
        }
}</span>

// Run starts the WebSocket hub
func (h *WebSocketHub) Run() <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                case client := &lt;-h.register:<span class="cov0" title="0">
                        // Check connection limit
                        if len(h.clients) &gt;= h.maxConnections </span><span class="cov0" title="0">{
                                log.Printf("WebSocket connection limit reached (%d), rejecting new connection", h.maxConnections)
                                close(client.send)
                                client.conn.Close()
                        }</span> else<span class="cov0" title="0"> {
                                h.clients[client] = true
                                log.Printf("WebSocket client connected, total: %d", len(h.clients))
                        }</span>

                case client := &lt;-h.unregister:<span class="cov0" title="0">
                        if _, ok := h.clients[client]; ok </span><span class="cov0" title="0">{
                                delete(h.clients, client)
                                close(client.send)
                                log.Printf("WebSocket client disconnected, total: %d", len(h.clients))
                        }</span>

                case message := &lt;-h.broadcast:<span class="cov0" title="0">
                        for client := range h.clients </span><span class="cov0" title="0">{
                                select </span>{
                                case client.send &lt;- message:<span class="cov0" title="0"></span>
                                default:<span class="cov0" title="0">
                                        // Client can't receive message, disconnect it
                                        close(client.send)
                                        delete(h.clients, client)
                                        client.conn.Close()</span>
                                }
                        }
                }
        }
}

// BroadcastMessage sends a message to all connected clients
func (h *WebSocketHub) BroadcastMessage(msgType string, data map[string]interface{}) error <span class="cov8" title="1">{
        message := WebSocketMessage{
                Type:      msgType,
                Timestamp: time.Now(),
                Data:      data,
        }

        messageBytes, err := json.Marshal(message)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">select </span>{
        case h.broadcast &lt;- messageBytes:<span class="cov8" title="1"></span>
        default:<span class="cov0" title="0"></span>
                // Channel is full, skip message
        }

        <span class="cov8" title="1">return nil</span>
}

// GetConnectionCount returns the number of active connections
func (h *WebSocketHub) GetConnectionCount() int <span class="cov0" title="0">{
        return len(h.clients)
}</span>

// HandleWebSocket handles WebSocket connections
func HandleWebSocket(hub *WebSocketHub, c *gin.Context) <span class="cov8" title="1">{
        conn, err := upgrader.Upgrade(c.Writer, c.Request, nil)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("WebSocket upgrade error: %v", err)
                return
        }</span>

        <span class="cov0" title="0">client := &amp;WebSocketClient{
                hub:  hub,
                conn: conn,
                send: make(chan []byte, 256),
        }

        client.hub.register &lt;- client

        // Start goroutines for reading and writing
        go client.writePump()
        go client.readPump()</span>
}

// readPump handles reading messages from the WebSocket connection
func (c *WebSocketClient) readPump() <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                c.hub.unregister &lt;- c
                c.conn.Close()
        }</span>()

        <span class="cov0" title="0">c.conn.SetReadLimit(512)
        c.conn.SetReadDeadline(time.Now().Add(60 * time.Second))
        c.conn.SetPongHandler(func(string) error </span><span class="cov0" title="0">{
                c.conn.SetReadDeadline(time.Now().Add(60 * time.Second))
                return nil
        }</span>)

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                _, _, err := c.conn.ReadMessage()
                if err != nil </span><span class="cov0" title="0">{
                        if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) </span><span class="cov0" title="0">{
                                log.Printf("WebSocket error: %v", err)
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
        }
}

// writePump handles writing messages to the WebSocket connection
func (c *WebSocketClient) writePump() <span class="cov0" title="0">{
        ticker := time.NewTicker(54 * time.Second)
        defer func() </span><span class="cov0" title="0">{
                ticker.Stop()
                c.conn.Close()
        }</span>()

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case message, ok := &lt;-c.send:<span class="cov0" title="0">
                        c.conn.SetWriteDeadline(time.Now().Add(10 * time.Second))
                        if !ok </span><span class="cov0" title="0">{
                                c.conn.WriteMessage(websocket.CloseMessage, []byte{})
                                return
                        }</span>

                        <span class="cov0" title="0">w, err := c.conn.NextWriter(websocket.TextMessage)
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">w.Write(message)

                        // Add queued messages to the current message
                        n := len(c.send)
                        for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                                w.Write([]byte{'\n'})
                                w.Write(&lt;-c.send)
                        }</span>

                        <span class="cov0" title="0">if err := w.Close(); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>

                case &lt;-ticker.C:<span class="cov0" title="0">
                        c.conn.SetWriteDeadline(time.Now().Add(10 * time.Second))
                        if err := c.conn.WriteMessage(websocket.PingMessage, nil); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }
}
</pre>

		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
